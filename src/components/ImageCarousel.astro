---
/**
 * Image carousel component for showcasing band photos
 * Mobile-friendly with touch swipe support and keyboard navigation
 * Uses Astro Image optimization and consistent design patterns
 */
import { Image } from 'astro:assets';
import type { ImageMetadata } from 'astro';
import { Card } from './ui';

interface CarouselImage {
	src: ImageMetadata;
	alt: string;
}

interface Props {
	images: CarouselImage[];
	class?: string;
}

const { images, class: className } = Astro.props;
---

<section class:list={['relative', className]}>
	<Card skew="up" shadow="red" class="overflow-hidden p-0">
		<div class="carousel-container relative" tabindex="0">
			<!-- Images Container -->
			<div class="carousel-track flex transition-transform duration-500 ease-out">
				{
					images.map((image, index) => (
						<div class="carousel-slide w-full flex-shrink-0" data-index={index}>
							<Image
								src={image.src}
								alt={image.alt}
								width={1200}
								class="h-64 w-full object-cover md:h-96"
								loading={index === 0 ? 'eager' : 'lazy'}
							/>
						</div>
					))
				}
			</div>

			<!-- Navigation Controls -->
			<div class="absolute inset-0 flex items-center justify-between px-4 pointer-events-none">
				<button
					class="carousel-prev pointer-events-auto rounded-full bg-mexi-black/70 p-3 text-mexi-white hover:bg-mexi-red transition-colors border-2 border-mexi-white disabled:opacity-50 disabled:cursor-not-allowed"
					aria-label="Previous image"
				>
					<svg
						xmlns="http://www.w3.org/2000/svg"
						class="h-6 w-6"
						fill="none"
						viewBox="0 0 24 24"
						stroke="currentColor"
					>
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"
						></path>
					</svg>
				</button>
				<button
					class="carousel-next pointer-events-auto rounded-full bg-mexi-black/70 p-3 text-mexi-white hover:bg-mexi-red transition-colors border-2 border-mexi-white disabled:opacity-50 disabled:cursor-not-allowed"
					aria-label="Next image"
				>
					<svg
						xmlns="http://www.w3.org/2000/svg"
						class="h-6 w-6"
						fill="none"
						viewBox="0 0 24 24"
						stroke="currentColor"
					>
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"
						></path>
					</svg>
				</button>
			</div>

			<!-- Indicators -->
			<div class="absolute bottom-4 left-0 right-0 flex justify-center gap-2">
				{
					images.map((_, index) => (
						<button
							class="carousel-indicator h-2 w-2 rounded-full transition-all border border-mexi-white"
							data-index={index}
							aria-label={`Go to image ${index + 1}`}
						/>
					))
				}
			</div>
		</div>
	</Card>
</section>

<script>
	document.addEventListener('astro:page-load', () => {
		const carousels = document.querySelectorAll('.carousel-container');
		const keydownHandlers: ((e: Event) => void)[] = [];
		const autoplayIntervals: (number | undefined)[] = [];

		carousels.forEach((carousel, carouselIndex) => {
			const track = carousel.querySelector('.carousel-track') as HTMLElement;
			const slides = carousel.querySelectorAll('.carousel-slide');
			const prevBtn = carousel.querySelector('.carousel-prev') as HTMLButtonElement;
			const nextBtn = carousel.querySelector('.carousel-next') as HTMLButtonElement;
			const indicators = carousel.querySelectorAll('.carousel-indicator');

			let currentIndex = 0;
			const totalSlides = slides.length;

			// Touch support
			let touchStartX = 0;
			let touchEndX = 0;
			let isDragging = false;

			function updateCarousel() {
				const offset = -currentIndex * 100;
				track.style.transform = `translateX(${offset}%)`;

				// Update indicators
				indicators.forEach((indicator, index) => {
					if (index === currentIndex) {
						indicator.classList.add('bg-mexi-white', 'w-8');
						indicator.classList.remove('bg-mexi-white/30');
					} else {
						indicator.classList.add('bg-mexi-white/30');
						indicator.classList.remove('bg-mexi-white', 'w-8');
					}
				});

				// Update button states
				prevBtn.disabled = currentIndex === 0;
				nextBtn.disabled = currentIndex === totalSlides - 1;
			}

			function goToSlide(index: number) {
				currentIndex = Math.max(0, Math.min(index, totalSlides - 1));
				updateCarousel();
			}

			// Button navigation
			prevBtn?.addEventListener('click', () => goToSlide(currentIndex - 1));
			nextBtn?.addEventListener('click', () => goToSlide(currentIndex + 1));

			// Indicator navigation
			indicators.forEach((indicator, index) => {
				indicator.addEventListener('click', () => goToSlide(index));
			});

			// Keyboard navigation handler
			const handleKeydown = (e: Event) => {
				// Only handle if carousel is focused or in view
				if (document.activeElement?.closest('.carousel-container') === carousel) {
					if ((e as KeyboardEvent).key === 'ArrowLeft') goToSlide(currentIndex - 1);
					if ((e as KeyboardEvent).key === 'ArrowRight') goToSlide(currentIndex + 1);
				}
			};
			document.addEventListener('keydown', handleKeydown);
			keydownHandlers.push(handleKeydown);

			// Touch/swipe support with passive flag
			track.addEventListener('touchstart', (e) => {
				touchStartX = e.touches[0].clientX;
				isDragging = true;
				stopAutoplay();
			}, { passive: true });

			track.addEventListener('touchmove', (e) => {
				if (!isDragging) return;
				touchEndX = e.touches[0].clientX;
				
				// Prevent default scroll if it's a horizontal swipe
				const diff = Math.abs(touchStartX - touchEndX);
				if (diff > 10) {
					e.preventDefault();
				}
			}, { passive: false });

			track.addEventListener('touchend', () => {
				if (!isDragging) return;
				isDragging = false;

				const swipeThreshold = 50;
				const diff = touchStartX - touchEndX;

				if (Math.abs(diff) > swipeThreshold) {
					if (diff > 0) {
						goToSlide(currentIndex + 1);
					} else {
						goToSlide(currentIndex - 1);
					}
				}

				// Resume autoplay after a delay
				setTimeout(startAutoplay, 1000);
			}, { passive: true });

			// Initialize
			updateCarousel();

			// Auto-play (optional)
			const startAutoplay = () => {
				// Don't start if already running
				if (autoplayIntervals[carouselIndex]) return;
				
				autoplayIntervals[carouselIndex] = window.setInterval(() => {
					if (currentIndex < totalSlides - 1) {
						goToSlide(currentIndex + 1);
					} else {
						goToSlide(0);
					}
				}, 5000);
			};

			const stopAutoplay = () => {
				if (autoplayIntervals[carouselIndex]) {
					clearInterval(autoplayIntervals[carouselIndex]);
					autoplayIntervals[carouselIndex] = undefined;
				}
			};

			// Start autoplay
			startAutoplay();

			// Pause on hover
			carousel.addEventListener('mouseenter', stopAutoplay);
			carousel.addEventListener('mouseleave', startAutoplay);
		});

		// Cleanup function for page transitions (outside forEach to run once)
		document.addEventListener('astro:before-preparation', () => {
			// Clean up all keyboard handlers
			keydownHandlers.forEach((handler) => {
				document.removeEventListener('keydown', handler);
			});
			
			// Stop all autoplay intervals
			autoplayIntervals.forEach((interval) => {
				if (interval) {
					clearInterval(interval);
				}
			});
		}, { once: true });
	});
</script>

<style>
	.carousel-indicator {
		cursor: pointer;
	}

	.carousel-indicator:hover {
		background-color: rgba(250, 250, 250, 0.6);
	}

	.carousel-track {
		touch-action: pan-y pinch-zoom;
	}
</style>
