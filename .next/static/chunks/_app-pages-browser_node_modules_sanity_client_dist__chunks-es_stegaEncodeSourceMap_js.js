"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_sanity_client_dist__chunks-es_stegaEncodeSourceMap_js"],{

/***/ "(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeIntoResult: () => (/* binding */ encodeIntoResult),\n/* harmony export */   stegaEncodeSourceMap: () => (/* binding */ stegaEncodeSourceMap),\n/* harmony export */   stegaEncodeSourceMap$1: () => (/* binding */ stegaEncodeSourceMap$1)\n/* harmony export */ });\n/* harmony import */ var _stegaClean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stegaClean.js */ \"(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\")\n      return `${target}[${segment}]`;\n    if (segmentType === \"string\")\n      return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": `\n`,\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return `$${path.map((segment) => typeof segment == \"string\" ? `['${segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => ESCAPE[match])}']` : typeof segment == \"number\" ? `[${segment}]` : segment._key !== \"\" ? `[?(@._key=='${segment._key.replace(/['\\\\]/g, (match) => ESCAPE[match])}')]` : `[${segment._index}]`).join(\"\")}`;\n}\nfunction parseJsonPath(path) {\n  const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  for (; (match = parseRe.exec(path)) !== null; ) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => UNESCAPE[m]);\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => UNESCAPE[m]);\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._key !== \"\")\n      return { _key: segment._key };\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!csm?.mappings)\n    return;\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0)\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0)\n    return;\n  const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value))\n    return value.map((v, idx) => {\n      if ((0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.isRecord)(v)) {\n        const _key = v._key;\n        if (typeof _key == \"string\")\n          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  if ((0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.isRecord)(value)) {\n    if (value._type === \"block\" || value._type === \"span\") {\n      const result = { ...value };\n      return value._type === \"block\" ? result.children = walkMap(value.children, mappingFn, path.concat(\"children\")) : value._type === \"span\" && (result.text = walkMap(value.text, mappingFn, path.concat(\"text\"))), result;\n    }\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n    );\n  }\n  return mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value != \"string\")\n      return value;\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult)\n      return value;\n    const { mapping, matchedPath } = resolveMappingResult;\n    if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\")\n      return value;\n    const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\nconst DRAFTS_FOLDER = \"drafts\", VERSION_FOLDER = \"versions\", PATH_SEPARATOR = \".\", DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`, VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`;\nfunction isDraftId(id) {\n  return id.startsWith(DRAFTS_PREFIX);\n}\nfunction isVersionId(id) {\n  return id.startsWith(VERSION_PREFIX);\n}\nfunction isPublishedId(id) {\n  return !isDraftId(id) && !isVersionId(id);\n}\nfunction getVersionFromId(id) {\n  if (!isVersionId(id)) return;\n  const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR);\n  return versionId;\n}\nfunction getPublishedId(id) {\n  return isVersionId(id) ? id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) : isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset\n  } = options;\n  if (!baseUrl)\n    throw new Error(\"baseUrl is required\");\n  if (!path)\n    throw new Error(\"path is required\");\n  if (!_id)\n    throw new Error(\"id is required\");\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\"))\n    throw new Error(\"baseUrl must not end with a slash\");\n  const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  if (workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), isPublishedId(_id))\n    searchParams.set(\"perspective\", \"published\");\n  else if (isVersionId(_id)) {\n    const versionId = getVersionFromId(_id);\n    searchParams.set(\"perspective\", versionId);\n  }\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  workspace && segments.push(workspace);\n  const routerParams = [\n    \"mode=presentation\",\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`\n  ];\n  return tool && routerParams.push(`tool=${tool}`), segments.push(\"intent\", \"edit\", `${routerParams.join(\";\")}?${searchParams}`), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n  return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? { baseUrl } : { ...studioUrl, baseUrl };\n}\nconst filterDefault = ({ sourcePath, resultPath, value }) => {\n  if (isValidDate(value) || isValidURL(value))\n    return !1;\n  const endPath = sourcePath.at(-1);\n  return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && (endPath.startsWith(\"_\") || endPath.endsWith(\"Id\")) || sourcePath.some(\n    (path) => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\"\n  ) || hasTypeLike(sourcePath) || hasTypeLike(resultPath) || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n  \"color\",\n  \"colour\",\n  \"currency\",\n  \"email\",\n  \"format\",\n  \"gid\",\n  \"hex\",\n  \"href\",\n  \"hsl\",\n  \"hsla\",\n  \"icon\",\n  \"id\",\n  \"index\",\n  \"key\",\n  \"language\",\n  \"layout\",\n  \"link\",\n  \"linkAction\",\n  \"locale\",\n  \"lqip\",\n  \"page\",\n  \"path\",\n  \"ref\",\n  \"rgb\",\n  \"rgba\",\n  \"route\",\n  \"secret\",\n  \"slug\",\n  \"status\",\n  \"tag\",\n  \"template\",\n  \"theme\",\n  \"type\",\n  \"textTheme\",\n  \"unit\",\n  \"url\",\n  \"username\",\n  \"variant\",\n  \"website\"\n]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nconst allowedProtocols = /* @__PURE__ */ new Set([\n  \"app:\",\n  \"data:\",\n  \"discord:\",\n  \"file:\",\n  \"ftp:\",\n  \"ftps:\",\n  \"geo:\",\n  \"http:\",\n  \"https:\",\n  \"imap:\",\n  \"javascript:\",\n  \"magnet:\",\n  \"mailto:\",\n  \"maps:\",\n  \"ms-excel:\",\n  \"ms-powerpoint:\",\n  \"ms-word:\",\n  \"slack:\",\n  \"sms:\",\n  \"spotify:\",\n  \"steam:\",\n  \"teams:\",\n  \"tel:\",\n  \"vscode:\",\n  \"zoom:\"\n]);\nfunction isValidURL(url) {\n  try {\n    const { protocol } = new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n    return allowedProtocols.has(protocol) || protocol.startsWith(\"web+\");\n  } catch {\n    return !1;\n  }\n}\nfunction hasTypeLike(path) {\n  return path.some((segment) => typeof segment == \"string\" && segment.match(/type/i) !== null);\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  const { filter, logger, enabled } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  if (!resultSourceMap)\n    return logger?.error?.(\"[@sanity/client]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    }), result;\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  }, resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({ sourcePath, sourceDocument, resultPath, value }) => {\n      if ((typeof filter == \"function\" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, value })) === !1)\n        return logger && report.skipped.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n          length: value.length\n        }), value;\n      logger && report.encoded.push({\n        path: prettyPathForLogging(sourcePath),\n        value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n        length: value.length\n      });\n      const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n        typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl\n      );\n      if (!baseUrl) return value;\n      const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n      return (0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.C)(\n        value,\n        {\n          origin: \"sanity.io\",\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n            ...!config.omitCrossDatasetReferenceData && { dataset, projectId }\n          })\n        },\n        // We use custom logic to determine if we should skip encoding\n        !1\n      );\n    }\n  );\n  if (logger) {\n    const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n    if ((isSkipping || isEncoding) && ((logger?.groupCollapsed || logger.log)?.(\"[@sanity/client]: Encoding source map into result\"), logger.log?.(\n      `[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`\n    )), report.encoded.length > 0 && (logger?.log?.(\"[@sanity/client]: Table of encoded paths\"), (logger?.table || logger.log)?.(report.encoded)), report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */ new Set();\n      for (const { path } of report.skipped)\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      logger?.log?.(\"[@sanity/client]: List of skipped paths\", [...skipped.values()]);\n    }\n    (isSkipping || isEncoding) && logger?.groupEnd?.();\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap\n});\n\n//# sourceMappingURL=stegaEncodeSourceMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvc3RlZ2FFbmNvZGVTb3VyY2VNYXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLEdBQUcsUUFBUTtBQUNsQztBQUNBLGdCQUFnQixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsUUFBUTtBQUN0RDtBQUNBLGdCQUFnQixPQUFPLFVBQVUsYUFBYTtBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sR0FBRyxLQUFLLEdBQUcsR0FBRztBQUNyQztBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBd0QsNERBQTRELHVDQUF1QyxRQUFRLDBDQUEwQyx5REFBeUQsV0FBVyxlQUFlLGFBQWE7QUFDMVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVDQUF1QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsYUFBYSxzQkFBc0I7QUFDbkc7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUtDO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb2hhbi9kZXYvcGVyc29uYWwvbWV4aXdlYi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUmVjb3JkLCBDIH0gZnJvbSBcIi4vc3RlZ2FDbGVhbi5qc1wiO1xuY29uc3QgcmVLZXlTZWdtZW50ID0gL19rZXlcXHMqPT1cXHMqWydcIl0oLiopWydcIl0vO1xuZnVuY3Rpb24gaXNLZXlTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgPyByZUtleVNlZ21lbnQudGVzdChzZWdtZW50LnRyaW0oKSkgOiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHNlZ21lbnQ7XG59XG5mdW5jdGlvbiB0b1N0cmluZyhwYXRoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGlzIG5vdCBhbiBhcnJheVwiKTtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKCh0YXJnZXQsIHNlZ21lbnQsIGkpID0+IHtcbiAgICBjb25zdCBzZWdtZW50VHlwZSA9IHR5cGVvZiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50VHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9WyR7c2VnbWVudH1dYDtcbiAgICBpZiAoc2VnbWVudFR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fSR7aSA9PT0gMCA/IFwiXCIgOiBcIi5cIn0ke3NlZ21lbnR9YDtcbiAgICBpZiAoaXNLZXlTZWdtZW50KHNlZ21lbnQpICYmIHNlZ21lbnQuX2tleSlcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9W19rZXk9PVwiJHtzZWdtZW50Ll9rZXl9XCJdYDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgICAgY29uc3QgW2Zyb20sIHRvXSA9IHNlZ21lbnQ7XG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVske2Zyb219OiR7dG99XWA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGF0aCBzZWdtZW50IFxcYCR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9XFxgYCk7XG4gIH0sIFwiXCIpO1xufVxuY29uc3QgRVNDQVBFID0ge1xuICBcIlxcZlwiOiBcIlxcXFxmXCIsXG4gIFwiXFxuXCI6IFwiXFxcXG5cIixcbiAgXCJcXHJcIjogXCJcXFxcclwiLFxuICBcIlx0XCI6IFwiXFxcXHRcIixcbiAgXCInXCI6IFwiXFxcXCdcIixcbiAgXCJcXFxcXCI6IFwiXFxcXFxcXFxcIlxufSwgVU5FU0NBUEUgPSB7XG4gIFwiXFxcXGZcIjogXCJcXGZcIixcbiAgXCJcXFxcblwiOiBgXG5gLFxuICBcIlxcXFxyXCI6IFwiXFxyXCIsXG4gIFwiXFxcXHRcIjogXCJcdFwiLFxuICBcIlxcXFwnXCI6IFwiJ1wiLFxuICBcIlxcXFxcXFxcXCI6IFwiXFxcXFwiXG59O1xuZnVuY3Rpb24ganNvblBhdGgocGF0aCkge1xuICByZXR1cm4gYCQke3BhdGgubWFwKChzZWdtZW50KSA9PiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiID8gYFsnJHtzZWdtZW50LnJlcGxhY2UoL1tcXGZcXG5cXHJcXHQnXFxcXF0vZywgKG1hdGNoKSA9PiBFU0NBUEVbbWF0Y2hdKX0nXWAgOiB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiID8gYFske3NlZ21lbnR9XWAgOiBzZWdtZW50Ll9rZXkgIT09IFwiXCIgPyBgWz8oQC5fa2V5PT0nJHtzZWdtZW50Ll9rZXkucmVwbGFjZSgvWydcXFxcXS9nLCAobWF0Y2gpID0+IEVTQ0FQRVttYXRjaF0pfScpXWAgOiBgWyR7c2VnbWVudC5faW5kZXh9XWApLmpvaW4oXCJcIil9YDtcbn1cbmZ1bmN0aW9uIHBhcnNlSnNvblBhdGgocGF0aCkge1xuICBjb25zdCBwYXJzZWQgPSBbXSwgcGFyc2VSZSA9IC9cXFsnKC4qPyknXFxdfFxcWyhcXGQrKVxcXXxcXFtcXD9cXChAXFwuX2tleT09JyguKj8pJ1xcKVxcXS9nO1xuICBsZXQgbWF0Y2g7XG4gIGZvciAoOyAobWF0Y2ggPSBwYXJzZVJlLmV4ZWMocGF0aCkpICE9PSBudWxsOyApIHtcbiAgICBpZiAobWF0Y2hbMV0gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qga2V5ID0gbWF0Y2hbMV0ucmVwbGFjZSgvXFxcXChcXFxcfGZ8bnxyfHR8JykvZywgKG0pID0+IFVORVNDQVBFW21dKTtcbiAgICAgIHBhcnNlZC5wdXNoKGtleSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlSW50KG1hdGNoWzJdLCAxMCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtYXRjaFszXSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBfa2V5ID0gbWF0Y2hbM10ucmVwbGFjZSgvXFxcXChcXFxcJykvZywgKG0pID0+IFVORVNDQVBFW21dKTtcbiAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgX2tleSxcbiAgICAgICAgX2luZGV4OiAtMVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50Ll9rZXkgIT09IFwiXCIpXG4gICAgICByZXR1cm4geyBfa2V5OiBzZWdtZW50Ll9rZXkgfTtcbiAgICBpZiAoc2VnbWVudC5faW5kZXggIT09IC0xKVxuICAgICAgcmV0dXJuIHNlZ21lbnQuX2luZGV4O1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWdtZW50OiR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9YCk7XG4gIH0pO1xufVxuZnVuY3Rpb24ganNvblBhdGhUb01hcHBpbmdQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50Ll9pbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm4gc2VnbWVudC5faW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZ21lbnQ6JHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlTWFwcGluZyhyZXN1bHRQYXRoLCBjc20pIHtcbiAgaWYgKCFjc20/Lm1hcHBpbmdzKVxuICAgIHJldHVybjtcbiAgY29uc3QgcmVzdWx0TWFwcGluZ1BhdGggPSBqc29uUGF0aChqc29uUGF0aFRvTWFwcGluZ1BhdGgocmVzdWx0UGF0aCkpO1xuICBpZiAoY3NtLm1hcHBpbmdzW3Jlc3VsdE1hcHBpbmdQYXRoXSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB7XG4gICAgICBtYXBwaW5nOiBjc20ubWFwcGluZ3NbcmVzdWx0TWFwcGluZ1BhdGhdLFxuICAgICAgbWF0Y2hlZFBhdGg6IHJlc3VsdE1hcHBpbmdQYXRoLFxuICAgICAgcGF0aFN1ZmZpeDogXCJcIlxuICAgIH07XG4gIGNvbnN0IG1hcHBpbmdzID0gT2JqZWN0LmVudHJpZXMoY3NtLm1hcHBpbmdzKS5maWx0ZXIoKFtrZXldKSA9PiByZXN1bHRNYXBwaW5nUGF0aC5zdGFydHNXaXRoKGtleSkpLnNvcnQoKFtrZXkxXSwgW2tleTJdKSA9PiBrZXkyLmxlbmd0aCAtIGtleTEubGVuZ3RoKTtcbiAgaWYgKG1hcHBpbmdzLmxlbmd0aCA9PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgW21hdGNoZWRQYXRoLCBtYXBwaW5nXSA9IG1hcHBpbmdzWzBdLCBwYXRoU3VmZml4ID0gcmVzdWx0TWFwcGluZ1BhdGguc3Vic3RyaW5nKG1hdGNoZWRQYXRoLmxlbmd0aCk7XG4gIHJldHVybiB7IG1hcHBpbmcsIG1hdGNoZWRQYXRoLCBwYXRoU3VmZml4IH07XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHdhbGtNYXAodmFsdWUsIG1hcHBpbmdGbiwgcGF0aCA9IFtdKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpZHgpID0+IHtcbiAgICAgIGlmIChpc1JlY29yZCh2KSkge1xuICAgICAgICBjb25zdCBfa2V5ID0gdi5fa2V5O1xuICAgICAgICBpZiAodHlwZW9mIF9rZXkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KHsgX2tleSwgX2luZGV4OiBpZHggfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChpZHgpKTtcbiAgICB9KTtcbiAgaWYgKGlzUmVjb3JkKHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS5fdHlwZSA9PT0gXCJibG9ja1wiIHx8IHZhbHVlLl90eXBlID09PSBcInNwYW5cIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0geyAuLi52YWx1ZSB9O1xuICAgICAgcmV0dXJuIHZhbHVlLl90eXBlID09PSBcImJsb2NrXCIgPyByZXN1bHQuY2hpbGRyZW4gPSB3YWxrTWFwKHZhbHVlLmNoaWxkcmVuLCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KFwiY2hpbGRyZW5cIikpIDogdmFsdWUuX3R5cGUgPT09IFwic3BhblwiICYmIChyZXN1bHQudGV4dCA9IHdhbGtNYXAodmFsdWUudGV4dCwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChcInRleHRcIikpKSwgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2ssIHZdKSA9PiBbaywgd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KGspKV0pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWFwcGluZ0ZuKHZhbHVlLCBwYXRoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUludG9SZXN1bHQocmVzdWx0LCBjc20sIGVuY29kZXIpIHtcbiAgcmV0dXJuIHdhbGtNYXAocmVzdWx0LCAodmFsdWUsIHBhdGgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgcmVzb2x2ZU1hcHBpbmdSZXN1bHQgPSByZXNvbHZlTWFwcGluZyhwYXRoLCBjc20pO1xuICAgIGlmICghcmVzb2x2ZU1hcHBpbmdSZXN1bHQpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgeyBtYXBwaW5nLCBtYXRjaGVkUGF0aCB9ID0gcmVzb2x2ZU1hcHBpbmdSZXN1bHQ7XG4gICAgaWYgKG1hcHBpbmcudHlwZSAhPT0gXCJ2YWx1ZVwiIHx8IG1hcHBpbmcuc291cmNlLnR5cGUgIT09IFwiZG9jdW1lbnRWYWx1ZVwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHNvdXJjZURvY3VtZW50ID0gY3NtLmRvY3VtZW50c1ttYXBwaW5nLnNvdXJjZS5kb2N1bWVudF0sIHNvdXJjZVBhdGggPSBjc20ucGF0aHNbbWFwcGluZy5zb3VyY2UucGF0aF0sIG1hdGNoUGF0aFNlZ21lbnRzID0gcGFyc2VKc29uUGF0aChtYXRjaGVkUGF0aCksIGZ1bGxTb3VyY2VTZWdtZW50cyA9IHBhcnNlSnNvblBhdGgoc291cmNlUGF0aCkuY29uY2F0KHBhdGguc2xpY2UobWF0Y2hQYXRoU2VnbWVudHMubGVuZ3RoKSk7XG4gICAgcmV0dXJuIGVuY29kZXIoe1xuICAgICAgc291cmNlUGF0aDogZnVsbFNvdXJjZVNlZ21lbnRzLFxuICAgICAgc291cmNlRG9jdW1lbnQsXG4gICAgICByZXN1bHRQYXRoOiBwYXRoLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBEUkFGVFNfRk9MREVSID0gXCJkcmFmdHNcIiwgVkVSU0lPTl9GT0xERVIgPSBcInZlcnNpb25zXCIsIFBBVEhfU0VQQVJBVE9SID0gXCIuXCIsIERSQUZUU19QUkVGSVggPSBgJHtEUkFGVFNfRk9MREVSfSR7UEFUSF9TRVBBUkFUT1J9YCwgVkVSU0lPTl9QUkVGSVggPSBgJHtWRVJTSU9OX0ZPTERFUn0ke1BBVEhfU0VQQVJBVE9SfWA7XG5mdW5jdGlvbiBpc0RyYWZ0SWQoaWQpIHtcbiAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoRFJBRlRTX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBpc1ZlcnNpb25JZChpZCkge1xuICByZXR1cm4gaWQuc3RhcnRzV2l0aChWRVJTSU9OX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBpc1B1Ymxpc2hlZElkKGlkKSB7XG4gIHJldHVybiAhaXNEcmFmdElkKGlkKSAmJiAhaXNWZXJzaW9uSWQoaWQpO1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbkZyb21JZChpZCkge1xuICBpZiAoIWlzVmVyc2lvbklkKGlkKSkgcmV0dXJuO1xuICBjb25zdCBbX3ZlcnNpb25QcmVmaXgsIHZlcnNpb25JZCwgLi4uX3B1Ymxpc2hlZElkXSA9IGlkLnNwbGl0KFBBVEhfU0VQQVJBVE9SKTtcbiAgcmV0dXJuIHZlcnNpb25JZDtcbn1cbmZ1bmN0aW9uIGdldFB1Ymxpc2hlZElkKGlkKSB7XG4gIHJldHVybiBpc1ZlcnNpb25JZChpZCkgPyBpZC5zcGxpdChQQVRIX1NFUEFSQVRPUikuc2xpY2UoMikuam9pbihQQVRIX1NFUEFSQVRPUikgOiBpc0RyYWZ0SWQoaWQpID8gaWQuc2xpY2UoRFJBRlRTX1BSRUZJWC5sZW5ndGgpIDogaWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVFZGl0VXJsKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGJhc2VVcmwsXG4gICAgd29ya3NwYWNlOiBfd29ya3NwYWNlID0gXCJkZWZhdWx0XCIsXG4gICAgdG9vbDogX3Rvb2wgPSBcImRlZmF1bHRcIixcbiAgICBpZDogX2lkLFxuICAgIHR5cGUsXG4gICAgcGF0aCxcbiAgICBwcm9qZWN0SWQsXG4gICAgZGF0YXNldFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKCFiYXNlVXJsKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhc2VVcmwgaXMgcmVxdWlyZWRcIik7XG4gIGlmICghcGF0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXRoIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoIV9pZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKGJhc2VVcmwgIT09IFwiL1wiICYmIGJhc2VVcmwuZW5kc1dpdGgoXCIvXCIpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhc2VVcmwgbXVzdCBub3QgZW5kIHdpdGggYSBzbGFzaFwiKTtcbiAgY29uc3Qgd29ya3NwYWNlID0gX3dvcmtzcGFjZSA9PT0gXCJkZWZhdWx0XCIgPyB2b2lkIDAgOiBfd29ya3NwYWNlLCB0b29sID0gX3Rvb2wgPT09IFwiZGVmYXVsdFwiID8gdm9pZCAwIDogX3Rvb2wsIGlkID0gZ2V0UHVibGlzaGVkSWQoX2lkKSwgc3RyaW5naWZpZWRQYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHRvU3RyaW5nKGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpKSA6IHBhdGgsIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgIGJhc2VVcmwsXG4gICAgaWQsXG4gICAgdHlwZSxcbiAgICBwYXRoOiBzdHJpbmdpZmllZFBhdGhcbiAgfSk7XG4gIGlmICh3b3Jrc3BhY2UgJiYgc2VhcmNoUGFyYW1zLnNldChcIndvcmtzcGFjZVwiLCB3b3Jrc3BhY2UpLCB0b29sICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJ0b29sXCIsIHRvb2wpLCBwcm9qZWN0SWQgJiYgc2VhcmNoUGFyYW1zLnNldChcInByb2plY3RJZFwiLCBwcm9qZWN0SWQpLCBkYXRhc2V0ICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJkYXRhc2V0XCIsIGRhdGFzZXQpLCBpc1B1Ymxpc2hlZElkKF9pZCkpXG4gICAgc2VhcmNoUGFyYW1zLnNldChcInBlcnNwZWN0aXZlXCIsIFwicHVibGlzaGVkXCIpO1xuICBlbHNlIGlmIChpc1ZlcnNpb25JZChfaWQpKSB7XG4gICAgY29uc3QgdmVyc2lvbklkID0gZ2V0VmVyc2lvbkZyb21JZChfaWQpO1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJwZXJzcGVjdGl2ZVwiLCB2ZXJzaW9uSWQpO1xuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gW2Jhc2VVcmwgPT09IFwiL1wiID8gXCJcIiA6IGJhc2VVcmxdO1xuICB3b3Jrc3BhY2UgJiYgc2VnbWVudHMucHVzaCh3b3Jrc3BhY2UpO1xuICBjb25zdCByb3V0ZXJQYXJhbXMgPSBbXG4gICAgXCJtb2RlPXByZXNlbnRhdGlvblwiLFxuICAgIGBpZD0ke2lkfWAsXG4gICAgYHR5cGU9JHt0eXBlfWAsXG4gICAgYHBhdGg9JHtlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZpZWRQYXRoKX1gXG4gIF07XG4gIHJldHVybiB0b29sICYmIHJvdXRlclBhcmFtcy5wdXNoKGB0b29sPSR7dG9vbH1gKSwgc2VnbWVudHMucHVzaChcImludGVudFwiLCBcImVkaXRcIiwgYCR7cm91dGVyUGFyYW1zLmpvaW4oXCI7XCIpfT8ke3NlYXJjaFBhcmFtc31gKSwgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiByZXNvbHZlU3R1ZGlvQmFzZVJvdXRlKHN0dWRpb1VybCkge1xuICBsZXQgYmFzZVVybCA9IHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHN0dWRpb1VybCA6IHN0dWRpb1VybC5iYXNlVXJsO1xuICByZXR1cm4gYmFzZVVybCAhPT0gXCIvXCIgJiYgKGJhc2VVcmwgPSBiYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSksIHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHsgYmFzZVVybCB9IDogeyAuLi5zdHVkaW9VcmwsIGJhc2VVcmwgfTtcbn1cbmNvbnN0IGZpbHRlckRlZmF1bHQgPSAoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCB2YWx1ZSB9KSA9PiB7XG4gIGlmIChpc1ZhbGlkRGF0ZSh2YWx1ZSkgfHwgaXNWYWxpZFVSTCh2YWx1ZSkpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlbmRQYXRoID0gc291cmNlUGF0aC5hdCgtMSk7XG4gIHJldHVybiAhKHNvdXJjZVBhdGguYXQoLTIpID09PSBcInNsdWdcIiAmJiBlbmRQYXRoID09PSBcImN1cnJlbnRcIiB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIChlbmRQYXRoLnN0YXJ0c1dpdGgoXCJfXCIpIHx8IGVuZFBhdGguZW5kc1dpdGgoXCJJZFwiKSkgfHwgc291cmNlUGF0aC5zb21lKFxuICAgIChwYXRoKSA9PiBwYXRoID09PSBcIm1ldGFcIiB8fCBwYXRoID09PSBcIm1ldGFkYXRhXCIgfHwgcGF0aCA9PT0gXCJvcGVuR3JhcGhcIiB8fCBwYXRoID09PSBcInNlb1wiXG4gICkgfHwgaGFzVHlwZUxpa2Uoc291cmNlUGF0aCkgfHwgaGFzVHlwZUxpa2UocmVzdWx0UGF0aCkgfHwgdHlwZW9mIGVuZFBhdGggPT0gXCJzdHJpbmdcIiAmJiBkZW55bGlzdC5oYXMoZW5kUGF0aCkpO1xufSwgZGVueWxpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY29sb3JcIixcbiAgXCJjb2xvdXJcIixcbiAgXCJjdXJyZW5jeVwiLFxuICBcImVtYWlsXCIsXG4gIFwiZm9ybWF0XCIsXG4gIFwiZ2lkXCIsXG4gIFwiaGV4XCIsXG4gIFwiaHJlZlwiLFxuICBcImhzbFwiLFxuICBcImhzbGFcIixcbiAgXCJpY29uXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImtleVwiLFxuICBcImxhbmd1YWdlXCIsXG4gIFwibGF5b3V0XCIsXG4gIFwibGlua1wiLFxuICBcImxpbmtBY3Rpb25cIixcbiAgXCJsb2NhbGVcIixcbiAgXCJscWlwXCIsXG4gIFwicGFnZVwiLFxuICBcInBhdGhcIixcbiAgXCJyZWZcIixcbiAgXCJyZ2JcIixcbiAgXCJyZ2JhXCIsXG4gIFwicm91dGVcIixcbiAgXCJzZWNyZXRcIixcbiAgXCJzbHVnXCIsXG4gIFwic3RhdHVzXCIsXG4gIFwidGFnXCIsXG4gIFwidGVtcGxhdGVcIixcbiAgXCJ0aGVtZVwiLFxuICBcInR5cGVcIixcbiAgXCJ0ZXh0VGhlbWVcIixcbiAgXCJ1bml0XCIsXG4gIFwidXJsXCIsXG4gIFwidXNlcm5hbWVcIixcbiAgXCJ2YXJpYW50XCIsXG4gIFwid2Vic2l0ZVwiXG5dKTtcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKGRhdGVTdHJpbmcpIHtcbiAgcmV0dXJuIC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3QoZGF0ZVN0cmluZykgPyAhIURhdGUucGFyc2UoZGF0ZVN0cmluZykgOiAhMTtcbn1cbmNvbnN0IGFsbG93ZWRQcm90b2NvbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYXBwOlwiLFxuICBcImRhdGE6XCIsXG4gIFwiZGlzY29yZDpcIixcbiAgXCJmaWxlOlwiLFxuICBcImZ0cDpcIixcbiAgXCJmdHBzOlwiLFxuICBcImdlbzpcIixcbiAgXCJodHRwOlwiLFxuICBcImh0dHBzOlwiLFxuICBcImltYXA6XCIsXG4gIFwiamF2YXNjcmlwdDpcIixcbiAgXCJtYWduZXQ6XCIsXG4gIFwibWFpbHRvOlwiLFxuICBcIm1hcHM6XCIsXG4gIFwibXMtZXhjZWw6XCIsXG4gIFwibXMtcG93ZXJwb2ludDpcIixcbiAgXCJtcy13b3JkOlwiLFxuICBcInNsYWNrOlwiLFxuICBcInNtczpcIixcbiAgXCJzcG90aWZ5OlwiLFxuICBcInN0ZWFtOlwiLFxuICBcInRlYW1zOlwiLFxuICBcInRlbDpcIixcbiAgXCJ2c2NvZGU6XCIsXG4gIFwiem9vbTpcIlxuXSk7XG5mdW5jdGlvbiBpc1ZhbGlkVVJMKHVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IHsgcHJvdG9jb2wgfSA9IG5ldyBVUkwodXJsLCB1cmwuc3RhcnRzV2l0aChcIi9cIikgPyBcImh0dHBzOi8vYWNtZS5jb21cIiA6IHZvaWQgMCk7XG4gICAgcmV0dXJuIGFsbG93ZWRQcm90b2NvbHMuaGFzKHByb3RvY29sKSB8fCBwcm90b2NvbC5zdGFydHNXaXRoKFwid2ViK1wiKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBoYXNUeXBlTGlrZShwYXRoKSB7XG4gIHJldHVybiBwYXRoLnNvbWUoKHNlZ21lbnQpID0+IHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgJiYgc2VnbWVudC5tYXRjaCgvdHlwZS9pKSAhPT0gbnVsbCk7XG59XG5jb25zdCBUUlVOQ0FURV9MRU5HVEggPSAyMDtcbmZ1bmN0aW9uIHN0ZWdhRW5jb2RlU291cmNlTWFwKHJlc3VsdCwgcmVzdWx0U291cmNlTWFwLCBjb25maWcpIHtcbiAgY29uc3QgeyBmaWx0ZXIsIGxvZ2dlciwgZW5hYmxlZCB9ID0gY29uZmlnO1xuICBpZiAoIWVuYWJsZWQpIHtcbiAgICBjb25zdCBtc2cgPSBcImNvbmZpZy5lbmFibGVkIG11c3QgYmUgdHJ1ZSwgZG9uJ3QgY2FsbCB0aGlzIGZ1bmN0aW9uIG90aGVyd2lzZVwiO1xuICAgIHRocm93IGxvZ2dlcj8uZXJyb3I/LihgW0BzYW5pdHkvY2xpZW50XTogJHttc2d9YCwgeyByZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgY29uZmlnIH0pLCBuZXcgVHlwZUVycm9yKG1zZyk7XG4gIH1cbiAgaWYgKCFyZXN1bHRTb3VyY2VNYXApXG4gICAgcmV0dXJuIGxvZ2dlcj8uZXJyb3I/LihcIltAc2FuaXR5L2NsaWVudF06IE1pc3NpbmcgQ29udGVudCBTb3VyY2UgTWFwIGZyb20gcmVzcG9uc2UgYm9keVwiLCB7XG4gICAgICByZXN1bHQsXG4gICAgICByZXN1bHRTb3VyY2VNYXAsXG4gICAgICBjb25maWdcbiAgICB9KSwgcmVzdWx0O1xuICBpZiAoIWNvbmZpZy5zdHVkaW9VcmwpIHtcbiAgICBjb25zdCBtc2cgPSBcImNvbmZpZy5zdHVkaW9VcmwgbXVzdCBiZSBkZWZpbmVkXCI7XG4gICAgdGhyb3cgbG9nZ2VyPy5lcnJvcj8uKGBbQHNhbml0eS9jbGllbnRdOiAke21zZ31gLCB7IHJlc3VsdCwgcmVzdWx0U291cmNlTWFwLCBjb25maWcgfSksIG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgfVxuICBjb25zdCByZXBvcnQgPSB7XG4gICAgZW5jb2RlZDogW10sXG4gICAgc2tpcHBlZDogW11cbiAgfSwgcmVzdWx0V2l0aFN0ZWdhID0gZW5jb2RlSW50b1Jlc3VsdChcbiAgICByZXN1bHQsXG4gICAgcmVzdWx0U291cmNlTWFwLFxuICAgICh7IHNvdXJjZVBhdGgsIHNvdXJjZURvY3VtZW50LCByZXN1bHRQYXRoLCB2YWx1ZSB9KSA9PiB7XG4gICAgICBpZiAoKHR5cGVvZiBmaWx0ZXIgPT0gXCJmdW5jdGlvblwiID8gZmlsdGVyKHsgc291cmNlUGF0aCwgcmVzdWx0UGF0aCwgZmlsdGVyRGVmYXVsdCwgc291cmNlRG9jdW1lbnQsIHZhbHVlIH0pIDogZmlsdGVyRGVmYXVsdCh7IHNvdXJjZVBhdGgsIHJlc3VsdFBhdGgsIHZhbHVlIH0pKSA9PT0gITEpXG4gICAgICAgIHJldHVybiBsb2dnZXIgJiYgcmVwb3J0LnNraXBwZWQucHVzaCh7XG4gICAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgICAgdmFsdWU6IGAke3ZhbHVlLnNsaWNlKDAsIFRSVU5DQVRFX0xFTkdUSCl9JHt2YWx1ZS5sZW5ndGggPiBUUlVOQ0FURV9MRU5HVEggPyBcIi4uLlwiIDogXCJcIn1gLFxuICAgICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoXG4gICAgICAgIH0pLCB2YWx1ZTtcbiAgICAgIGxvZ2dlciAmJiByZXBvcnQuZW5jb2RlZC5wdXNoKHtcbiAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgIHZhbHVlOiBgJHt2YWx1ZS5zbGljZSgwLCBUUlVOQ0FURV9MRU5HVEgpfSR7dmFsdWUubGVuZ3RoID4gVFJVTkNBVEVfTEVOR1RIID8gXCIuLi5cIiA6IFwiXCJ9YCxcbiAgICAgICAgbGVuZ3RoOiB2YWx1ZS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBiYXNlVXJsLCB3b3Jrc3BhY2UsIHRvb2wgfSA9IHJlc29sdmVTdHVkaW9CYXNlUm91dGUoXG4gICAgICAgIHR5cGVvZiBjb25maWcuc3R1ZGlvVXJsID09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZy5zdHVkaW9Vcmwoc291cmNlRG9jdW1lbnQpIDogY29uZmlnLnN0dWRpb1VybFxuICAgICAgKTtcbiAgICAgIGlmICghYmFzZVVybCkgcmV0dXJuIHZhbHVlO1xuICAgICAgY29uc3QgeyBfaWQ6IGlkLCBfdHlwZTogdHlwZSwgX3Byb2plY3RJZDogcHJvamVjdElkLCBfZGF0YXNldDogZGF0YXNldCB9ID0gc291cmNlRG9jdW1lbnQ7XG4gICAgICByZXR1cm4gQyhcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW46IFwic2FuaXR5LmlvXCIsXG4gICAgICAgICAgaHJlZjogY3JlYXRlRWRpdFVybCh7XG4gICAgICAgICAgICBiYXNlVXJsLFxuICAgICAgICAgICAgd29ya3NwYWNlLFxuICAgICAgICAgICAgdG9vbCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBhdGg6IHNvdXJjZVBhdGgsXG4gICAgICAgICAgICAuLi4hY29uZmlnLm9taXRDcm9zc0RhdGFzZXRSZWZlcmVuY2VEYXRhICYmIHsgZGF0YXNldCwgcHJvamVjdElkIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvLyBXZSB1c2UgY3VzdG9tIGxvZ2ljIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgc2tpcCBlbmNvZGluZ1xuICAgICAgICAhMVxuICAgICAgKTtcbiAgICB9XG4gICk7XG4gIGlmIChsb2dnZXIpIHtcbiAgICBjb25zdCBpc1NraXBwaW5nID0gcmVwb3J0LnNraXBwZWQubGVuZ3RoLCBpc0VuY29kaW5nID0gcmVwb3J0LmVuY29kZWQubGVuZ3RoO1xuICAgIGlmICgoaXNTa2lwcGluZyB8fCBpc0VuY29kaW5nKSAmJiAoKGxvZ2dlcj8uZ3JvdXBDb2xsYXBzZWQgfHwgbG9nZ2VyLmxvZyk/LihcIltAc2FuaXR5L2NsaWVudF06IEVuY29kaW5nIHNvdXJjZSBtYXAgaW50byByZXN1bHRcIiksIGxvZ2dlci5sb2c/LihcbiAgICAgIGBbQHNhbml0eS9jbGllbnRdOiBQYXRocyBlbmNvZGVkOiAke3JlcG9ydC5lbmNvZGVkLmxlbmd0aH0sIHNraXBwZWQ6ICR7cmVwb3J0LnNraXBwZWQubGVuZ3RofWBcbiAgICApKSwgcmVwb3J0LmVuY29kZWQubGVuZ3RoID4gMCAmJiAobG9nZ2VyPy5sb2c/LihcIltAc2FuaXR5L2NsaWVudF06IFRhYmxlIG9mIGVuY29kZWQgcGF0aHNcIiksIChsb2dnZXI/LnRhYmxlIHx8IGxvZ2dlci5sb2cpPy4ocmVwb3J0LmVuY29kZWQpKSwgcmVwb3J0LnNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2tpcHBlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IHsgcGF0aCB9IG9mIHJlcG9ydC5za2lwcGVkKVxuICAgICAgICBza2lwcGVkLmFkZChwYXRoLnJlcGxhY2UocmVLZXlTZWdtZW50LCBcIjBcIikucmVwbGFjZSgvXFxbXFxkK1xcXS9nLCBcIltdXCIpKTtcbiAgICAgIGxvZ2dlcj8ubG9nPy4oXCJbQHNhbml0eS9jbGllbnRdOiBMaXN0IG9mIHNraXBwZWQgcGF0aHNcIiwgWy4uLnNraXBwZWQudmFsdWVzKCldKTtcbiAgICB9XG4gICAgKGlzU2tpcHBpbmcgfHwgaXNFbmNvZGluZykgJiYgbG9nZ2VyPy5ncm91cEVuZD8uKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFdpdGhTdGVnYTtcbn1cbmZ1bmN0aW9uIHByZXR0eVBhdGhGb3JMb2dnaW5nKHBhdGgpIHtcbiAgcmV0dXJuIHRvU3RyaW5nKGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpKTtcbn1cbnZhciBzdGVnYUVuY29kZVNvdXJjZU1hcCQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwXG59KTtcbmV4cG9ydCB7XG4gIGVuY29kZUludG9SZXN1bHQsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwLFxuICBzdGVnYUVuY29kZVNvdXJjZU1hcCQxXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RlZ2FFbmNvZGVTb3VyY2VNYXAuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\n"));

/***/ })

}]);