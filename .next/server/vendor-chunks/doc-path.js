"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/doc-path";
exports.ids = ["vendor-chunks/doc-path"];
exports.modules = {

/***/ "(ssr)/./node_modules/doc-path/lib/path.js":
/*!*******************************************!*\
  !*** ./node_modules/doc-path/lib/path.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license MIT\n * doc-path <https://github.com/mrodrig/doc-path>\n * Copyright (c) 2015-present, Michael Rodrigues.\n */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setPath = exports.evaluatePath = void 0;\n/**\n * Main function that evaluates the path in a particular object\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction evaluatePath(obj, kp) {\n    if (!obj) {\n        return null;\n    }\n    const { dotIndex, key, remaining } = state(kp);\n    const kpVal = typeof obj === 'object' && kp in obj ? obj[kp] : undefined;\n    const keyVal = typeof obj === 'object' && key in obj ? obj[key] : undefined;\n    if (dotIndex >= 0 && typeof obj === 'object' && !(kp in obj)) {\n        const { key: nextKey } = state(remaining);\n        const nextKeyAsInt = parseInt(nextKey);\n        // If there's an array at the current key in the object, then iterate over those items evaluating the remaining path\n        if (Array.isArray(keyVal) && isNaN(nextKeyAsInt)) {\n            return keyVal.map((doc) => evaluatePath(doc, remaining));\n        }\n        // Otherwise, we can just recur\n        return evaluatePath(keyVal, remaining);\n    }\n    else if (Array.isArray(obj)) {\n        const keyAsInt = parseInt(key);\n        if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {\n            return keyVal;\n        }\n        // If this object is actually an array, then iterate over those items evaluating the path\n        return obj.map((doc) => evaluatePath(doc, kp));\n    }\n    else if (dotIndex >= 0 && kp !== key && typeof obj === 'object' && key in obj) {\n        // If there's a field with a non-nested dot, then recur into that sub-value\n        return evaluatePath(keyVal, remaining);\n    }\n    else if (dotIndex === -1 && typeof obj === 'object' && key in obj && !(kp in obj)) {\n        // If the field is here, but the key was escaped\n        return keyVal;\n    }\n    // Otherwise, we can just return value directly\n    return kpVal;\n}\nexports.evaluatePath = evaluatePath;\n/**\n * Main function that performs validation before passing off to _sp\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction setPath(obj, kp, v) {\n    if (!obj) {\n        throw new Error('No object was provided.');\n    }\n    else if (!kp) {\n        throw new Error('No keyPath was provided.');\n    }\n    return _sp(obj, kp, v);\n}\nexports.setPath = setPath;\n// Helper function that will set the value in the provided object/array.\nfunction _sp(obj, kp, v) {\n    const { dotIndex, key, remaining } = state(kp);\n    // If this is clearly a prototype pollution attempt, then refuse to modify the path\n    if (kp.startsWith('__proto__') || kp.startsWith('constructor') || kp.startsWith('prototype')) {\n        return obj;\n    }\n    if (dotIndex >= 0) {\n        const keyAsInt = parseInt(key);\n        // If there is a '.' in the key path, recur on the subdoc and ...\n        if (typeof obj === 'object' && obj !== null && !(key in obj) && Array.isArray(obj) && !isNaN(keyAsInt)) {\n            // If there's no value at obj[key] then populate an empty object\n            obj[key] = obj[key] ?? {};\n            // Continue iterating on the rest of the key path to set the appropriate value where intended and then return\n            _sp(obj[key], remaining, v);\n            return obj;\n        }\n        else if (typeof obj === 'object' && obj !== null && !(key in obj) && Array.isArray(obj)) {\n            // If this is an array and there are multiple levels of keys to iterate over, recur.\n            obj.forEach((doc) => _sp(doc, kp, v));\n            return obj;\n        }\n        else if (typeof obj === 'object' && obj !== null && !(key in obj) && !Array.isArray(obj)) {\n            const { key: nextKey } = state(remaining);\n            const nextKeyAsInt = parseInt(nextKey);\n            if (!isNaN(nextKeyAsInt)) {\n                // If the current key doesn't exist yet and the next key is a number (likely array index), populate an empty array\n                obj[key] = [];\n            }\n            else if (remaining === '') {\n                // If the remaining key is empty, then a `.` character appeared right at the end of the path and wasn't actually indicating a separate level\n                obj[kp] = v;\n                return obj;\n            }\n            else {\n                // If the current key doesn't exist yet, populate it\n                obj[key] = {};\n            }\n        }\n        _sp(obj[key], remaining, v);\n    }\n    else if (Array.isArray(obj)) {\n        const keyAsInt = parseInt(key);\n        // If the object is an array and this key is an int (likely array index), then set the value directly and return\n        if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {\n            obj[key] = v;\n            return obj;\n        }\n        // If this \"obj\" is actually an array, then we can loop over each of the values and set the path\n        obj.forEach((doc) => _sp(doc, remaining, v));\n        return obj;\n    }\n    else {\n        // Otherwise, we can set the path directly\n        obj[key] = v;\n    }\n    return obj;\n}\n// Helper function that returns some information necessary to evaluate or set a path  based on the provided keyPath value\nfunction state(kp) {\n    const dotIndex = findFirstNonEscapedDotIndex(kp);\n    return {\n        dotIndex,\n        key: kp.slice(0, dotIndex >= 0 ? dotIndex : undefined).replace(/\\\\./g, '.'),\n        remaining: kp.slice(dotIndex + 1)\n    };\n}\nfunction findFirstNonEscapedDotIndex(kp) {\n    for (let i = 0; i < kp.length; i++) {\n        const previousChar = i > 0 ? kp[i - 1] : '', currentChar = kp[i];\n        if (currentChar === '.' && previousChar !== '\\\\')\n            return i;\n    }\n    return -1;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jLXBhdGgvbGliL3BhdGguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxvQkFBb0I7QUFDdEM7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvam9oYW4vZGV2L3BlcnNvbmFsL21leGl3ZWIvbm9kZV9tb2R1bGVzL2RvYy1wYXRoL2xpYi9wYXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgTUlUXG4gKiBkb2MtcGF0aCA8aHR0cHM6Ly9naXRodWIuY29tL21yb2RyaWcvZG9jLXBhdGg+XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgTWljaGFlbCBSb2RyaWd1ZXMuXG4gKi9cbid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0UGF0aCA9IGV4cG9ydHMuZXZhbHVhdGVQYXRoID0gdm9pZCAwO1xuLyoqXG4gKiBNYWluIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIHRoZSBwYXRoIGluIGEgcGFydGljdWxhciBvYmplY3RcbiAqIEB0aHJvd3Mge0Vycm9yfSBwb3NzaWJsZSBlcnJvciBpZiBjYWxsIHN0YWNrIHNpemUgaXMgZXhjZWVkZWRcbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVQYXRoKG9iaiwga3ApIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBkb3RJbmRleCwga2V5LCByZW1haW5pbmcgfSA9IHN0YXRlKGtwKTtcbiAgICBjb25zdCBrcFZhbCA9IHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGtwIGluIG9iaiA/IG9ialtrcF0gOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qga2V5VmFsID0gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYga2V5IGluIG9iaiA/IG9ialtrZXldIDogdW5kZWZpbmVkO1xuICAgIGlmIChkb3RJbmRleCA+PSAwICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICEoa3AgaW4gb2JqKSkge1xuICAgICAgICBjb25zdCB7IGtleTogbmV4dEtleSB9ID0gc3RhdGUocmVtYWluaW5nKTtcbiAgICAgICAgY29uc3QgbmV4dEtleUFzSW50ID0gcGFyc2VJbnQobmV4dEtleSk7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYW4gYXJyYXkgYXQgdGhlIGN1cnJlbnQga2V5IGluIHRoZSBvYmplY3QsIHRoZW4gaXRlcmF0ZSBvdmVyIHRob3NlIGl0ZW1zIGV2YWx1YXRpbmcgdGhlIHJlbWFpbmluZyBwYXRoXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleVZhbCkgJiYgaXNOYU4obmV4dEtleUFzSW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleVZhbC5tYXAoKGRvYykgPT4gZXZhbHVhdGVQYXRoKGRvYywgcmVtYWluaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBjYW4ganVzdCByZWN1clxuICAgICAgICByZXR1cm4gZXZhbHVhdGVQYXRoKGtleVZhbCwgcmVtYWluaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGNvbnN0IGtleUFzSW50ID0gcGFyc2VJbnQoa2V5KTtcbiAgICAgICAgaWYgKGtwID09PSBrZXkgJiYgZG90SW5kZXggPT09IC0xICYmICFpc05hTihrZXlBc0ludCkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlWYWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyBvYmplY3QgaXMgYWN0dWFsbHkgYW4gYXJyYXksIHRoZW4gaXRlcmF0ZSBvdmVyIHRob3NlIGl0ZW1zIGV2YWx1YXRpbmcgdGhlIHBhdGhcbiAgICAgICAgcmV0dXJuIG9iai5tYXAoKGRvYykgPT4gZXZhbHVhdGVQYXRoKGRvYywga3ApKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG90SW5kZXggPj0gMCAmJiBrcCAhPT0ga2V5ICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGtleSBpbiBvYmopIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIGZpZWxkIHdpdGggYSBub24tbmVzdGVkIGRvdCwgdGhlbiByZWN1ciBpbnRvIHRoYXQgc3ViLXZhbHVlXG4gICAgICAgIHJldHVybiBldmFsdWF0ZVBhdGgoa2V5VmFsLCByZW1haW5pbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb3RJbmRleCA9PT0gLTEgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYga2V5IGluIG9iaiAmJiAhKGtwIGluIG9iaikpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZpZWxkIGlzIGhlcmUsIGJ1dCB0aGUga2V5IHdhcyBlc2NhcGVkXG4gICAgICAgIHJldHVybiBrZXlWYWw7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgd2UgY2FuIGp1c3QgcmV0dXJuIHZhbHVlIGRpcmVjdGx5XG4gICAgcmV0dXJuIGtwVmFsO1xufVxuZXhwb3J0cy5ldmFsdWF0ZVBhdGggPSBldmFsdWF0ZVBhdGg7XG4vKipcbiAqIE1haW4gZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB2YWxpZGF0aW9uIGJlZm9yZSBwYXNzaW5nIG9mZiB0byBfc3BcbiAqIEB0aHJvd3Mge0Vycm9yfSBwb3NzaWJsZSBlcnJvciBpZiBjYWxsIHN0YWNrIHNpemUgaXMgZXhjZWVkZWRcbiAqL1xuZnVuY3Rpb24gc2V0UGF0aChvYmosIGtwLCB2KSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBvYmplY3Qgd2FzIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgha3ApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBrZXlQYXRoIHdhcyBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIF9zcChvYmosIGtwLCB2KTtcbn1cbmV4cG9ydHMuc2V0UGF0aCA9IHNldFBhdGg7XG4vLyBIZWxwZXIgZnVuY3Rpb24gdGhhdCB3aWxsIHNldCB0aGUgdmFsdWUgaW4gdGhlIHByb3ZpZGVkIG9iamVjdC9hcnJheS5cbmZ1bmN0aW9uIF9zcChvYmosIGtwLCB2KSB7XG4gICAgY29uc3QgeyBkb3RJbmRleCwga2V5LCByZW1haW5pbmcgfSA9IHN0YXRlKGtwKTtcbiAgICAvLyBJZiB0aGlzIGlzIGNsZWFybHkgYSBwcm90b3R5cGUgcG9sbHV0aW9uIGF0dGVtcHQsIHRoZW4gcmVmdXNlIHRvIG1vZGlmeSB0aGUgcGF0aFxuICAgIGlmIChrcC5zdGFydHNXaXRoKCdfX3Byb3RvX18nKSB8fCBrcC5zdGFydHNXaXRoKCdjb25zdHJ1Y3RvcicpIHx8IGtwLnN0YXJ0c1dpdGgoJ3Byb3RvdHlwZScpKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGlmIChkb3RJbmRleCA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGtleUFzSW50ID0gcGFyc2VJbnQoa2V5KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSAnLicgaW4gdGhlIGtleSBwYXRoLCByZWN1ciBvbiB0aGUgc3ViZG9jIGFuZCAuLi5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiAhKGtleSBpbiBvYmopICYmIEFycmF5LmlzQXJyYXkob2JqKSAmJiAhaXNOYU4oa2V5QXNJbnQpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHZhbHVlIGF0IG9ialtrZXldIHRoZW4gcG9wdWxhdGUgYW4gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICBvYmpba2V5XSA9IG9ialtrZXldID8/IHt9O1xuICAgICAgICAgICAgLy8gQ29udGludWUgaXRlcmF0aW5nIG9uIHRoZSByZXN0IG9mIHRoZSBrZXkgcGF0aCB0byBzZXQgdGhlIGFwcHJvcHJpYXRlIHZhbHVlIHdoZXJlIGludGVuZGVkIGFuZCB0aGVuIHJldHVyblxuICAgICAgICAgICAgX3NwKG9ialtrZXldLCByZW1haW5pbmcsIHYpO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwgJiYgIShrZXkgaW4gb2JqKSAmJiBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gYXJyYXkgYW5kIHRoZXJlIGFyZSBtdWx0aXBsZSBsZXZlbHMgb2Yga2V5cyB0byBpdGVyYXRlIG92ZXIsIHJlY3VyLlxuICAgICAgICAgICAgb2JqLmZvckVhY2goKGRvYykgPT4gX3NwKGRvYywga3AsIHYpKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmICEoa2V5IGluIG9iaikgJiYgIUFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgY29uc3QgeyBrZXk6IG5leHRLZXkgfSA9IHN0YXRlKHJlbWFpbmluZyk7XG4gICAgICAgICAgICBjb25zdCBuZXh0S2V5QXNJbnQgPSBwYXJzZUludChuZXh0S2V5KTtcbiAgICAgICAgICAgIGlmICghaXNOYU4obmV4dEtleUFzSW50KSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGtleSBkb2Vzbid0IGV4aXN0IHlldCBhbmQgdGhlIG5leHQga2V5IGlzIGEgbnVtYmVyIChsaWtlbHkgYXJyYXkgaW5kZXgpLCBwb3B1bGF0ZSBhbiBlbXB0eSBhcnJheVxuICAgICAgICAgICAgICAgIG9ialtrZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZW1haW5pbmcgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlbWFpbmluZyBrZXkgaXMgZW1wdHksIHRoZW4gYSBgLmAgY2hhcmFjdGVyIGFwcGVhcmVkIHJpZ2h0IGF0IHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdhc24ndCBhY3R1YWxseSBpbmRpY2F0aW5nIGEgc2VwYXJhdGUgbGV2ZWxcbiAgICAgICAgICAgICAgICBvYmpba3BdID0gdjtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQga2V5IGRvZXNuJ3QgZXhpc3QgeWV0LCBwb3B1bGF0ZSBpdFxuICAgICAgICAgICAgICAgIG9ialtrZXldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3NwKG9ialtrZXldLCByZW1haW5pbmcsIHYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgY29uc3Qga2V5QXNJbnQgPSBwYXJzZUludChrZXkpO1xuICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGlzIGFuIGFycmF5IGFuZCB0aGlzIGtleSBpcyBhbiBpbnQgKGxpa2VseSBhcnJheSBpbmRleCksIHRoZW4gc2V0IHRoZSB2YWx1ZSBkaXJlY3RseSBhbmQgcmV0dXJuXG4gICAgICAgIGlmIChrcCA9PT0ga2V5ICYmIGRvdEluZGV4ID09PSAtMSAmJiAhaXNOYU4oa2V5QXNJbnQpKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHY7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgXCJvYmpcIiBpcyBhY3R1YWxseSBhbiBhcnJheSwgdGhlbiB3ZSBjYW4gbG9vcCBvdmVyIGVhY2ggb2YgdGhlIHZhbHVlcyBhbmQgc2V0IHRoZSBwYXRoXG4gICAgICAgIG9iai5mb3JFYWNoKChkb2MpID0+IF9zcChkb2MsIHJlbWFpbmluZywgdikpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBjYW4gc2V0IHRoZSBwYXRoIGRpcmVjdGx5XG4gICAgICAgIG9ialtrZXldID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbi8vIEhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgc29tZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gZXZhbHVhdGUgb3Igc2V0IGEgcGF0aCAgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGtleVBhdGggdmFsdWVcbmZ1bmN0aW9uIHN0YXRlKGtwKSB7XG4gICAgY29uc3QgZG90SW5kZXggPSBmaW5kRmlyc3ROb25Fc2NhcGVkRG90SW5kZXgoa3ApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvdEluZGV4LFxuICAgICAgICBrZXk6IGtwLnNsaWNlKDAsIGRvdEluZGV4ID49IDAgPyBkb3RJbmRleCA6IHVuZGVmaW5lZCkucmVwbGFjZSgvXFxcXC4vZywgJy4nKSxcbiAgICAgICAgcmVtYWluaW5nOiBrcC5zbGljZShkb3RJbmRleCArIDEpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRGaXJzdE5vbkVzY2FwZWREb3RJbmRleChrcCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNDaGFyID0gaSA+IDAgPyBrcFtpIC0gMV0gOiAnJywgY3VycmVudENoYXIgPSBrcFtpXTtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnLicgJiYgcHJldmlvdXNDaGFyICE9PSAnXFxcXCcpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/doc-path/lib/path.js\n");

/***/ })

};
;