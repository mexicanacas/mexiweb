"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-2-csv";
exports.ids = ["vendor-chunks/json-2-csv"];
exports.modules = {

/***/ "(ssr)/./node_modules/json-2-csv/lib/constants.js":
/*!**************************************************!*\
  !*** ./node_modules/json-2-csv/lib/constants.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.excelBOM = exports.defaultCsv2JsonOptions = exports.defaultJson2CsvOptions = exports.errors = void 0;\nexports.errors = {\n    optionsRequired: 'Options were not passed and are required.',\n    json2csv: {\n        cannotCallOn: 'Cannot call json2csv on',\n        dataCheckFailure: 'Data provided was not an array of documents.',\n        notSameSchema: 'Not all documents have the same schema.'\n    },\n    csv2json: {\n        cannotCallOn: 'Cannot call csv2json on',\n        dataCheckFailure: 'CSV is not a string.'\n    }\n};\nexports.defaultJson2CsvOptions = {\n    arrayIndexesAsKeys: false,\n    checkSchemaDifferences: false,\n    delimiter: {\n        field: ',',\n        wrap: '\"',\n        eol: '\\n'\n    },\n    emptyFieldValue: undefined,\n    escapeHeaderNestedDots: true,\n    excelBOM: false,\n    excludeKeys: [],\n    expandNestedObjects: true,\n    expandArrayObjects: false,\n    prependHeader: true,\n    preventCsvInjection: false,\n    sortHeader: false,\n    trimFieldValues: false,\n    trimHeaderFields: false,\n    unwindArrays: false,\n    useDateIso8601Format: false,\n    useLocaleFormat: false,\n    wrapBooleans: false,\n};\nexports.defaultCsv2JsonOptions = {\n    delimiter: {\n        field: ',',\n        wrap: '\"',\n        eol: '\\n'\n    },\n    excelBOM: false,\n    preventCsvInjection: false,\n    trimFieldValues: false,\n    trimHeaderFields: false,\n};\nexports.excelBOM = '\\ufeff';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLDhCQUE4QixHQUFHLDhCQUE4QixHQUFHLGNBQWM7QUFDbkcsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiL1VzZXJzL2pvaGFuL2Rldi9wZXJzb25hbC9tZXhpd2ViL25vZGVfbW9kdWxlcy9qc29uLTItY3N2L2xpYi9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leGNlbEJPTSA9IGV4cG9ydHMuZGVmYXVsdENzdjJKc29uT3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdEpzb24yQ3N2T3B0aW9ucyA9IGV4cG9ydHMuZXJyb3JzID0gdm9pZCAwO1xuZXhwb3J0cy5lcnJvcnMgPSB7XG4gICAgb3B0aW9uc1JlcXVpcmVkOiAnT3B0aW9ucyB3ZXJlIG5vdCBwYXNzZWQgYW5kIGFyZSByZXF1aXJlZC4nLFxuICAgIGpzb24yY3N2OiB7XG4gICAgICAgIGNhbm5vdENhbGxPbjogJ0Nhbm5vdCBjYWxsIGpzb24yY3N2IG9uJyxcbiAgICAgICAgZGF0YUNoZWNrRmFpbHVyZTogJ0RhdGEgcHJvdmlkZWQgd2FzIG5vdCBhbiBhcnJheSBvZiBkb2N1bWVudHMuJyxcbiAgICAgICAgbm90U2FtZVNjaGVtYTogJ05vdCBhbGwgZG9jdW1lbnRzIGhhdmUgdGhlIHNhbWUgc2NoZW1hLidcbiAgICB9LFxuICAgIGNzdjJqc29uOiB7XG4gICAgICAgIGNhbm5vdENhbGxPbjogJ0Nhbm5vdCBjYWxsIGNzdjJqc29uIG9uJyxcbiAgICAgICAgZGF0YUNoZWNrRmFpbHVyZTogJ0NTViBpcyBub3QgYSBzdHJpbmcuJ1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHRKc29uMkNzdk9wdGlvbnMgPSB7XG4gICAgYXJyYXlJbmRleGVzQXNLZXlzOiBmYWxzZSxcbiAgICBjaGVja1NjaGVtYURpZmZlcmVuY2VzOiBmYWxzZSxcbiAgICBkZWxpbWl0ZXI6IHtcbiAgICAgICAgZmllbGQ6ICcsJyxcbiAgICAgICAgd3JhcDogJ1wiJyxcbiAgICAgICAgZW9sOiAnXFxuJ1xuICAgIH0sXG4gICAgZW1wdHlGaWVsZFZhbHVlOiB1bmRlZmluZWQsXG4gICAgZXNjYXBlSGVhZGVyTmVzdGVkRG90czogdHJ1ZSxcbiAgICBleGNlbEJPTTogZmFsc2UsXG4gICAgZXhjbHVkZUtleXM6IFtdLFxuICAgIGV4cGFuZE5lc3RlZE9iamVjdHM6IHRydWUsXG4gICAgZXhwYW5kQXJyYXlPYmplY3RzOiBmYWxzZSxcbiAgICBwcmVwZW5kSGVhZGVyOiB0cnVlLFxuICAgIHByZXZlbnRDc3ZJbmplY3Rpb246IGZhbHNlLFxuICAgIHNvcnRIZWFkZXI6IGZhbHNlLFxuICAgIHRyaW1GaWVsZFZhbHVlczogZmFsc2UsXG4gICAgdHJpbUhlYWRlckZpZWxkczogZmFsc2UsXG4gICAgdW53aW5kQXJyYXlzOiBmYWxzZSxcbiAgICB1c2VEYXRlSXNvODYwMUZvcm1hdDogZmFsc2UsXG4gICAgdXNlTG9jYWxlRm9ybWF0OiBmYWxzZSxcbiAgICB3cmFwQm9vbGVhbnM6IGZhbHNlLFxufTtcbmV4cG9ydHMuZGVmYXVsdENzdjJKc29uT3B0aW9ucyA9IHtcbiAgICBkZWxpbWl0ZXI6IHtcbiAgICAgICAgZmllbGQ6ICcsJyxcbiAgICAgICAgd3JhcDogJ1wiJyxcbiAgICAgICAgZW9sOiAnXFxuJ1xuICAgIH0sXG4gICAgZXhjZWxCT006IGZhbHNlLFxuICAgIHByZXZlbnRDc3ZJbmplY3Rpb246IGZhbHNlLFxuICAgIHRyaW1GaWVsZFZhbHVlczogZmFsc2UsXG4gICAgdHJpbUhlYWRlckZpZWxkczogZmFsc2UsXG59O1xuZXhwb3J0cy5leGNlbEJPTSA9ICdcXHVmZWZmJztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/converter.js":
/*!**************************************************!*\
  !*** ./node_modules/json-2-csv/lib/converter.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.csv2json = exports.json2csv = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst json2csv_1 = __webpack_require__(/*! ./json2csv */ \"(ssr)/./node_modules/json-2-csv/lib/json2csv.js\");\nconst csv2json_1 = __webpack_require__(/*! ./csv2json */ \"(ssr)/./node_modules/json-2-csv/lib/csv2json.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\");\nfunction json2csv(data, options) {\n    const builtOptions = (0, utils_1.buildJ2COptions)(options ?? {});\n    // Validate the parameters before calling the converter's convert function\n    (0, utils_1.validate)(data, utils_1.isObject, constants_1.errors.json2csv);\n    return (0, json2csv_1.Json2Csv)(builtOptions).convert(data);\n}\nexports.json2csv = json2csv;\nfunction csv2json(data, options) {\n    const builtOptions = (0, utils_1.buildC2JOptions)(options ?? {});\n    // Validate the parameters before calling the converter's convert function\n    (0, utils_1.validate)(data, utils_1.isString, constants_1.errors.csv2json);\n    return (0, csv2json_1.Csv2Json)(builtOptions).convert(data);\n}\nexports.csv2json = csv2json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGdCQUFnQjtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRUFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRUFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBUztBQUNqQztBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiL1VzZXJzL2pvaGFuL2Rldi9wZXJzb25hbC9tZXhpd2ViL25vZGVfbW9kdWxlcy9qc29uLTItY3N2L2xpYi9jb252ZXJ0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jc3YyanNvbiA9IGV4cG9ydHMuanNvbjJjc3YgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGpzb24yY3N2XzEgPSByZXF1aXJlKFwiLi9qc29uMmNzdlwiKTtcbmNvbnN0IGNzdjJqc29uXzEgPSByZXF1aXJlKFwiLi9jc3YyanNvblwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGpzb24yY3N2KGRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBidWlsdE9wdGlvbnMgPSAoMCwgdXRpbHNfMS5idWlsZEoyQ09wdGlvbnMpKG9wdGlvbnMgPz8ge30pO1xuICAgIC8vIFZhbGlkYXRlIHRoZSBwYXJhbWV0ZXJzIGJlZm9yZSBjYWxsaW5nIHRoZSBjb252ZXJ0ZXIncyBjb252ZXJ0IGZ1bmN0aW9uXG4gICAgKDAsIHV0aWxzXzEudmFsaWRhdGUpKGRhdGEsIHV0aWxzXzEuaXNPYmplY3QsIGNvbnN0YW50c18xLmVycm9ycy5qc29uMmNzdik7XG4gICAgcmV0dXJuICgwLCBqc29uMmNzdl8xLkpzb24yQ3N2KShidWlsdE9wdGlvbnMpLmNvbnZlcnQoZGF0YSk7XG59XG5leHBvcnRzLmpzb24yY3N2ID0ganNvbjJjc3Y7XG5mdW5jdGlvbiBjc3YyanNvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYnVpbHRPcHRpb25zID0gKDAsIHV0aWxzXzEuYnVpbGRDMkpPcHRpb25zKShvcHRpb25zID8/IHt9KTtcbiAgICAvLyBWYWxpZGF0ZSB0aGUgcGFyYW1ldGVycyBiZWZvcmUgY2FsbGluZyB0aGUgY29udmVydGVyJ3MgY29udmVydCBmdW5jdGlvblxuICAgICgwLCB1dGlsc18xLnZhbGlkYXRlKShkYXRhLCB1dGlsc18xLmlzU3RyaW5nLCBjb25zdGFudHNfMS5lcnJvcnMuY3N2Mmpzb24pO1xuICAgIHJldHVybiAoMCwgY3N2Mmpzb25fMS5Dc3YySnNvbikoYnVpbHRPcHRpb25zKS5jb252ZXJ0KGRhdGEpO1xufVxuZXhwb3J0cy5jc3YyanNvbiA9IGNzdjJqc29uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/converter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/csv2json.js":
/*!*************************************************!*\
  !*** ./node_modules/json-2-csv/lib/csv2json.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Csv2Json = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\"));\nconst Csv2Json = function (options) {\n    const escapedWrapDelimiterRegex = new RegExp(options.delimiter.wrap + options.delimiter.wrap, 'g'), excelBOMRegex = new RegExp('^' + constants_1.excelBOM), valueParserFn = options.parseValue && typeof options.parseValue === 'function' ? options.parseValue : JSON.parse;\n    /**\n     * Trims the header key, if specified by the user via the provided options\n     */\n    function processHeaderKey(headerKey) {\n        headerKey = removeWrapDelimitersFromValue(headerKey);\n        if (options.trimHeaderFields) {\n            return headerKey.split('.')\n                .map((component) => component.trim())\n                .join('.');\n        }\n        return headerKey;\n    }\n    /**\n     * Generate the JSON heading from the CSV\n     */\n    function retrieveHeading(lines) {\n        let headerFields = [];\n        if (options.headerFields) {\n            headerFields = options.headerFields.map((headerField, index) => ({\n                value: processHeaderKey(headerField),\n                index\n            }));\n        }\n        else {\n            // Generate and return the heading keys\n            const headerRow = lines[0];\n            headerFields = headerRow.map((headerKey, index) => ({\n                value: processHeaderKey(headerKey),\n                index\n            }));\n            // If the user provided keys, filter the generated keys to just the user provided keys so we also have the key index\n            if (options.keys) {\n                const keys = options.keys; // TypeScript type checking work around to get it to recognize the option is not undefined\n                headerFields = headerFields.filter((headerKey) => keys.includes(headerKey.value));\n            }\n        }\n        return {\n            lines,\n            headerFields,\n            recordLines: [],\n        };\n    }\n    /**\n     * Removes the Excel BOM value, if specified by the options object\n     */\n    function stripExcelBOM(csv) {\n        if (options.excelBOM) {\n            return csv.replace(excelBOMRegex, '');\n        }\n        return csv;\n    }\n    /**\n     * Helper function that splits a line so that we can handle wrapped fields\n     */\n    function splitLines(csv) {\n        // Parse out the line...\n        const lines = [], lastCharacterIndex = csv.length - 1, eolDelimiterLength = options.delimiter.eol.length, stateVariables = {\n            insideWrapDelimiter: false,\n            parsingValue: true,\n            justParsedDoubleQuote: false,\n            startIndex: 0\n        };\n        let splitLine = [], character, charBefore, charAfter, nextNChar, index = 0;\n        // Loop through each character in the line to identify where to split the values\n        while (index < csv.length) {\n            // Current character\n            character = csv[index];\n            // Previous character\n            charBefore = index ? csv[index - 1] : '';\n            // Next character\n            charAfter = index < lastCharacterIndex ? csv[index + 1] : '';\n            // Next n characters, including the current character, where n = length(EOL delimiter)\n            // This allows for the checking of an EOL delimiter when if it is more than a single character (eg. '\\r\\n')\n            nextNChar = utils.getNCharacters(csv, index, eolDelimiterLength);\n            if ((nextNChar === options.delimiter.eol && !stateVariables.insideWrapDelimiter ||\n                index === lastCharacterIndex) && charBefore === options.delimiter.field) {\n                // If we reached an EOL delimiter or the end of the csv and the previous character is a field delimiter...\n                // If the start index is the current index (and since the previous character is a comma),\n                //   then the value being parsed is an empty value accordingly, add an empty string\n                if (nextNChar === options.delimiter.eol && stateVariables.startIndex === index) {\n                    splitLine.push('');\n                }\n                else if (character === options.delimiter.field) {\n                    // If we reached the end of the CSV, there's no new line, and the current character is a comma\n                    // then add an empty string for the current value\n                    splitLine.push('');\n                }\n                else {\n                    // Otherwise, there's a valid value, and the start index isn't the current index, grab the whole value\n                    splitLine.push(csv.substring(stateVariables.startIndex));\n                }\n                // Since the last character is a comma, there's still an additional implied field value trailing the comma.\n                //   Since this value is empty, we push an extra empty value\n                splitLine.push('');\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            }\n            else if (index === lastCharacterIndex && character === options.delimiter.field) {\n                // If we reach the end of the CSV and the current character is a field delimiter\n                // Parse the previously seen value and add it to the line\n                const parsedValue = csv.substring(stateVariables.startIndex, index);\n                splitLine.push(parsedValue);\n                // Then add an empty string to the line since the last character being a field delimiter indicates an empty field\n                splitLine.push('');\n                lines.push(splitLine);\n            }\n            else if (index === lastCharacterIndex || nextNChar === options.delimiter.eol &&\n                // if we aren't inside wrap delimiters or if we are but the character before was a wrap delimiter and we didn't just see two\n                (!stateVariables.insideWrapDelimiter ||\n                    stateVariables.insideWrapDelimiter && charBefore === options.delimiter.wrap && !stateVariables.justParsedDoubleQuote)) {\n                // Otherwise if we reached the end of the line or csv (and current character is not a field delimiter)\n                const toIndex = index !== lastCharacterIndex || charBefore === options.delimiter.wrap ? index : undefined;\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, toIndex));\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            }\n            else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && !stateVariables.parsingValue) {\n                // If we reached a wrap delimiter after a comma and we aren't inside a wrap delimiter\n                stateVariables.startIndex = index;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                // If the next character(s) are an EOL delimiter, then skip them so we don't parse what we've seen as another value\n                if (utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                    index += options.delimiter.eol.length + 1; // Skip past EOL\n                }\n            }\n            else if (charBefore === options.delimiter.field && character === options.delimiter.wrap && charAfter === options.delimiter.eol) {\n                // We reached the start of a wrapped new field that begins with an EOL delimiter\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.startIndex = index;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.justParsedDoubleQuote = true;\n                index += 1;\n            }\n            else if ((charBefore !== options.delimiter.wrap || stateVariables.justParsedDoubleQuote && charBefore === options.delimiter.wrap) &&\n                character === options.delimiter.wrap && utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                // If we reach a wrap which is not preceded by a wrap delim and the next character is an EOL delim (ie. *\"\\n)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n                // Next iteration will substring, add the value to the line, and push the line onto the array of lines\n            }\n            else if (character === options.delimiter.wrap && (index === 0 || utils.getNCharacters(csv, index - eolDelimiterLength, eolDelimiterLength) === options.delimiter.eol && !stateVariables.insideWrapDelimiter)) {\n                // If the line starts with a wrap delimiter (ie. \"*)\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            }\n            else if (character === options.delimiter.wrap && charAfter === options.delimiter.field && stateVariables.insideWrapDelimiter) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. *\",)\n                splitLine.push(csv.substring(stateVariables.startIndex, index + 1));\n                stateVariables.startIndex = index + 2; // next value starts after the field delimiter\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n            }\n            else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. ,\"*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            }\n            else if (character === options.delimiter.wrap && charAfter === options.delimiter.wrap && index !== stateVariables.startIndex) {\n                // If we run into an escaped quote (ie. \"\") skip past the second quote\n                index += 2;\n                stateVariables.justParsedDoubleQuote = true;\n                continue;\n            }\n            else if (character === options.delimiter.field && charBefore !== options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.insideWrapDelimiter &&\n                stateVariables.parsingValue) {\n                // If we reached a field delimiter and are not inside the wrap delimiters (ie. *,*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index));\n                stateVariables.startIndex = index + 1;\n            }\n            else if (character === options.delimiter.field && charBefore === options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.parsingValue) {\n                // If we reached a field delimiter, the previous character was a wrap delimiter, and the\n                //   next character is not a wrap delimiter (ie. \",*)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index + 1;\n            }\n            // Otherwise increment to the next character\n            index++;\n            // Reset the double quote state variable\n            stateVariables.justParsedDoubleQuote = false;\n        }\n        return lines;\n    }\n    /**\n     * Retrieves the record lines from the split CSV lines and sets it on the params object\n     */\n    function retrieveRecordLines(params) {\n        if (options.headerFields) { // This option is passed for instances where the CSV has no header line\n            params.recordLines = params.lines;\n        }\n        else { // All lines except for the header line\n            params.recordLines = params.lines.splice(1);\n        }\n        return params;\n    }\n    /**\n     * Retrieves the value for the record from the line at the provided key.\n     */\n    function retrieveRecordValueFromLine(headerField, line) {\n        // If there is a value at the key's index, use it; otherwise, null\n        const value = line[headerField.index];\n        // Perform any necessary value conversions on the record value\n        return processRecordValue(value);\n    }\n    /**\n     * Processes the record's value by parsing the data to ensure the CSV is\n     * converted to the JSON that created it.\n     */\n    function processRecordValue(fieldValue) {\n        // If the value is an array representation, convert it\n        const parsedJson = parseValue(fieldValue);\n        // If parsedJson is anything aside from an error, then we want to use the parsed value\n        // This allows us to interpret values like 'null' --> null, 'false' --> false\n        if (!utils.isError(parsedJson) && !utils.isInvalid(parsedJson)) {\n            return parsedJson;\n        }\n        else if (fieldValue === 'undefined') {\n            return undefined;\n        }\n        return fieldValue;\n    }\n    /**\n     * Trims the record value, if specified by the user via the options object\n     */\n    function trimRecordValue(fieldValue) {\n        if (options.trimFieldValues && fieldValue !== null) {\n            return fieldValue.trim();\n        }\n        return fieldValue;\n    }\n    /**\n     * Create a JSON document with the given keys (designated by the CSV header)\n     *   and the values (from the given line)\n     * @returns {Object} created json document\n     */\n    function createDocument(headerFields, line) {\n        // Reduce the keys into a JSON document representing the given line\n        return headerFields.reduce((document, headerField) => {\n            // If there is a value at the key's index in the line, set the value; otherwise null\n            const value = retrieveRecordValueFromLine(headerField, line);\n            try {\n                // Otherwise add the key and value to the document\n                return (0, doc_path_1.setPath)(document, headerField.value, value);\n            }\n            catch (error) {\n                // Catch any errors where key paths are null or '' and continue\n                return document;\n            }\n        }, {});\n    }\n    /**\n     * Removes the outermost wrap delimiters from a value, if they are present\n     * Otherwise, the non-wrapped value is returned as is\n     */\n    function removeWrapDelimitersFromValue(fieldValue) {\n        const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n        // If the field starts and ends with a wrap delimiter\n        if (firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap) {\n            // Handle the case where the field is just a pair of wrap delimiters \n            return fieldValue.length <= 2 ? '' : fieldValue.substring(1, lastIndex);\n        }\n        return fieldValue;\n    }\n    /**\n     * Unescapes wrap delimiters by replacing duplicates with a single (eg. \"\" -> \")\n     * This is done in order to parse RFC 4180 compliant CSV back to JSON\n     */\n    function unescapeWrapDelimiterInField(fieldValue) {\n        return fieldValue.replace(escapedWrapDelimiterRegex, options.delimiter.wrap);\n    }\n    /**\n     * Main helper function to convert the CSV to the JSON document array\n     */\n    function transformRecordLines(params) {\n        // For each line, create the document and add it to the array of documents\n        return params.recordLines.reduce((generatedJsonObjects, line) => {\n            line = line.map((fieldValue) => {\n                // Perform the necessary operations on each line\n                fieldValue = removeWrapDelimitersFromValue(fieldValue);\n                fieldValue = unescapeWrapDelimiterInField(fieldValue);\n                fieldValue = trimRecordValue(fieldValue);\n                return fieldValue;\n            });\n            const generatedDocument = createDocument(params.headerFields, line);\n            return generatedJsonObjects.concat(generatedDocument);\n        }, []);\n    }\n    /**\n     * Attempts to parse the provided value. If it is not parsable, then an error is returned\n     */\n    function parseValue(value) {\n        try {\n            if (utils.isStringRepresentation(value, options) && !utils.isDateRepresentation(value)) {\n                return value;\n            }\n            const parsedJson = valueParserFn(value);\n            // If the parsed value is an array, then we also need to trim record values, if specified\n            if (Array.isArray(parsedJson)) {\n                return parsedJson.map(trimRecordValue);\n            }\n            return parsedJson;\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    /**\n     * Internally exported csv2json function\n     */\n    function convert(data) {\n        // Split the CSV into lines using the specified EOL option\n        const stripped = stripExcelBOM(data);\n        const split = splitLines(stripped);\n        const heading = retrieveHeading(split); // Retrieve the headings from the CSV, unless the user specified the keys\n        const lines = retrieveRecordLines(heading); // Retrieve the record lines from the CSV\n        return transformRecordLines(lines); // Retrieve the JSON document array\n    }\n    return {\n        convert,\n    };\n};\nexports.Csv2Json = Csv2Json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY3N2Mmpzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixtQkFBbUIsbUJBQU8sQ0FBQywyREFBVTtBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN6QywyQkFBMkIsbUJBQU8sQ0FBQyw2REFBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxvREFBb0Q7QUFDcEQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb2hhbi9kZXYvcGVyc29uYWwvbWV4aXdlYi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY3N2Mmpzb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNzdjJKc29uID0gdm9pZCAwO1xuY29uc3QgZG9jX3BhdGhfMSA9IHJlcXVpcmUoXCJkb2MtcGF0aFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgQ3N2Mkpzb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGNvbnN0IGVzY2FwZWRXcmFwRGVsaW1pdGVyUmVnZXggPSBuZXcgUmVnRXhwKG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgKyBvcHRpb25zLmRlbGltaXRlci53cmFwLCAnZycpLCBleGNlbEJPTVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBjb25zdGFudHNfMS5leGNlbEJPTSksIHZhbHVlUGFyc2VyRm4gPSBvcHRpb25zLnBhcnNlVmFsdWUgJiYgdHlwZW9mIG9wdGlvbnMucGFyc2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMucGFyc2VWYWx1ZSA6IEpTT04ucGFyc2U7XG4gICAgLyoqXG4gICAgICogVHJpbXMgdGhlIGhlYWRlciBrZXksIGlmIHNwZWNpZmllZCBieSB0aGUgdXNlciB2aWEgdGhlIHByb3ZpZGVkIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyS2V5KGhlYWRlcktleSkge1xuICAgICAgICBoZWFkZXJLZXkgPSByZW1vdmVXcmFwRGVsaW1pdGVyc0Zyb21WYWx1ZShoZWFkZXJLZXkpO1xuICAgICAgICBpZiAob3B0aW9ucy50cmltSGVhZGVyRmllbGRzKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyS2V5LnNwbGl0KCcuJylcbiAgICAgICAgICAgICAgICAubWFwKChjb21wb25lbnQpID0+IGNvbXBvbmVudC50cmltKCkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVyS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgSlNPTiBoZWFkaW5nIGZyb20gdGhlIENTVlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJpZXZlSGVhZGluZyhsaW5lcykge1xuICAgICAgICBsZXQgaGVhZGVyRmllbGRzID0gW107XG4gICAgICAgIGlmIChvcHRpb25zLmhlYWRlckZpZWxkcykge1xuICAgICAgICAgICAgaGVhZGVyRmllbGRzID0gb3B0aW9ucy5oZWFkZXJGaWVsZHMubWFwKChoZWFkZXJGaWVsZCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2Nlc3NIZWFkZXJLZXkoaGVhZGVyRmllbGQpLFxuICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhbmQgcmV0dXJuIHRoZSBoZWFkaW5nIGtleXNcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclJvdyA9IGxpbmVzWzBdO1xuICAgICAgICAgICAgaGVhZGVyRmllbGRzID0gaGVhZGVyUm93Lm1hcCgoaGVhZGVyS2V5LCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvY2Vzc0hlYWRlcktleShoZWFkZXJLZXkpLFxuICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBrZXlzLCBmaWx0ZXIgdGhlIGdlbmVyYXRlZCBrZXlzIHRvIGp1c3QgdGhlIHVzZXIgcHJvdmlkZWQga2V5cyBzbyB3ZSBhbHNvIGhhdmUgdGhlIGtleSBpbmRleFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMua2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBvcHRpb25zLmtleXM7IC8vIFR5cGVTY3JpcHQgdHlwZSBjaGVja2luZyB3b3JrIGFyb3VuZCB0byBnZXQgaXQgdG8gcmVjb2duaXplIHRoZSBvcHRpb24gaXMgbm90IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGhlYWRlckZpZWxkcyA9IGhlYWRlckZpZWxkcy5maWx0ZXIoKGhlYWRlcktleSkgPT4ga2V5cy5pbmNsdWRlcyhoZWFkZXJLZXkudmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICBoZWFkZXJGaWVsZHMsXG4gICAgICAgICAgICByZWNvcmRMaW5lczogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIEV4Y2VsIEJPTSB2YWx1ZSwgaWYgc3BlY2lmaWVkIGJ5IHRoZSBvcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmlwRXhjZWxCT00oY3N2KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmV4Y2VsQk9NKSB7XG4gICAgICAgICAgICByZXR1cm4gY3N2LnJlcGxhY2UoZXhjZWxCT01SZWdleCwgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjc3Y7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHNwbGl0cyBhIGxpbmUgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHdyYXBwZWQgZmllbGRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXRMaW5lcyhjc3YpIHtcbiAgICAgICAgLy8gUGFyc2Ugb3V0IHRoZSBsaW5lLi4uXG4gICAgICAgIGNvbnN0IGxpbmVzID0gW10sIGxhc3RDaGFyYWN0ZXJJbmRleCA9IGNzdi5sZW5ndGggLSAxLCBlb2xEZWxpbWl0ZXJMZW5ndGggPSBvcHRpb25zLmRlbGltaXRlci5lb2wubGVuZ3RoLCBzdGF0ZVZhcmlhYmxlcyA9IHtcbiAgICAgICAgICAgIGluc2lkZVdyYXBEZWxpbWl0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2luZ1ZhbHVlOiB0cnVlLFxuICAgICAgICAgICAganVzdFBhcnNlZERvdWJsZVF1b3RlOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0SW5kZXg6IDBcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNwbGl0TGluZSA9IFtdLCBjaGFyYWN0ZXIsIGNoYXJCZWZvcmUsIGNoYXJBZnRlciwgbmV4dE5DaGFyLCBpbmRleCA9IDA7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIGNoYXJhY3RlciBpbiB0aGUgbGluZSB0byBpZGVudGlmeSB3aGVyZSB0byBzcGxpdCB0aGUgdmFsdWVzXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGNzdi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSBjc3ZbaW5kZXhdO1xuICAgICAgICAgICAgLy8gUHJldmlvdXMgY2hhcmFjdGVyXG4gICAgICAgICAgICBjaGFyQmVmb3JlID0gaW5kZXggPyBjc3ZbaW5kZXggLSAxXSA6ICcnO1xuICAgICAgICAgICAgLy8gTmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGNoYXJBZnRlciA9IGluZGV4IDwgbGFzdENoYXJhY3RlckluZGV4ID8gY3N2W2luZGV4ICsgMV0gOiAnJztcbiAgICAgICAgICAgIC8vIE5leHQgbiBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLCB3aGVyZSBuID0gbGVuZ3RoKEVPTCBkZWxpbWl0ZXIpXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBmb3IgdGhlIGNoZWNraW5nIG9mIGFuIEVPTCBkZWxpbWl0ZXIgd2hlbiBpZiBpdCBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgY2hhcmFjdGVyIChlZy4gJ1xcclxcbicpXG4gICAgICAgICAgICBuZXh0TkNoYXIgPSB1dGlscy5nZXROQ2hhcmFjdGVycyhjc3YsIGluZGV4LCBlb2xEZWxpbWl0ZXJMZW5ndGgpO1xuICAgICAgICAgICAgaWYgKChuZXh0TkNoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCAmJiAhc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciB8fFxuICAgICAgICAgICAgICAgIGluZGV4ID09PSBsYXN0Q2hhcmFjdGVySW5kZXgpICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhbiBFT0wgZGVsaW1pdGVyIG9yIHRoZSBlbmQgb2YgdGhlIGNzdiBhbmQgdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpcyBhIGZpZWxkIGRlbGltaXRlci4uLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdGFydCBpbmRleCBpcyB0aGUgY3VycmVudCBpbmRleCAoYW5kIHNpbmNlIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXMgYSBjb21tYSksXG4gICAgICAgICAgICAgICAgLy8gICB0aGVuIHRoZSB2YWx1ZSBiZWluZyBwYXJzZWQgaXMgYW4gZW1wdHkgdmFsdWUgYWNjb3JkaW5nbHksIGFkZCBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAobmV4dE5DaGFyID09PSBvcHRpb25zLmRlbGltaXRlci5lb2wgJiYgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgQ1NWLCB0aGVyZSdzIG5vIG5ldyBsaW5lLCBhbmQgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgY29tbWFcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBhZGQgYW4gZW1wdHkgc3RyaW5nIGZvciB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZXJlJ3MgYSB2YWxpZCB2YWx1ZSwgYW5kIHRoZSBzdGFydCBpbmRleCBpc24ndCB0aGUgY3VycmVudCBpbmRleCwgZ3JhYiB0aGUgd2hvbGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBsYXN0IGNoYXJhY3RlciBpcyBhIGNvbW1hLCB0aGVyZSdzIHN0aWxsIGFuIGFkZGl0aW9uYWwgaW1wbGllZCBmaWVsZCB2YWx1ZSB0cmFpbGluZyB0aGUgY29tbWEuXG4gICAgICAgICAgICAgICAgLy8gICBTaW5jZSB0aGlzIHZhbHVlIGlzIGVtcHR5LCB3ZSBwdXNoIGFuIGV4dHJhIGVtcHR5IHZhbHVlXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIHB1c2ggdGhlIHNwbGl0IGxpbmUgdmFsdWVzIGludG8gdGhlIGxpbmVzIGFycmF5IGFuZCBjbGVhciB0aGUgc3BsaXQgbGluZVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goc3BsaXRMaW5lKTtcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUgPSBbXTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXggKyBlb2xEZWxpbWl0ZXJMZW5ndGg7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IGxhc3RDaGFyYWN0ZXJJbmRleCAmJiBjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgQ1NWIGFuZCB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYSBmaWVsZCBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgcHJldmlvdXNseSBzZWVuIHZhbHVlIGFuZCBhZGQgaXQgdG8gdGhlIGxpbmVcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IGNzdi5zdWJzdHJpbmcoc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKHBhcnNlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGVuIGFkZCBhbiBlbXB0eSBzdHJpbmcgdG8gdGhlIGxpbmUgc2luY2UgdGhlIGxhc3QgY2hhcmFjdGVyIGJlaW5nIGEgZmllbGQgZGVsaW1pdGVyIGluZGljYXRlcyBhbiBlbXB0eSBmaWVsZFxuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHNwbGl0TGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gbGFzdENoYXJhY3RlckluZGV4IHx8IG5leHROQ2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sICYmXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlbid0IGluc2lkZSB3cmFwIGRlbGltaXRlcnMgb3IgaWYgd2UgYXJlIGJ1dCB0aGUgY2hhcmFjdGVyIGJlZm9yZSB3YXMgYSB3cmFwIGRlbGltaXRlciBhbmQgd2UgZGlkbid0IGp1c3Qgc2VlIHR3b1xuICAgICAgICAgICAgICAgICghc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgIXN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBsaW5lIG9yIGNzdiAoYW5kIGN1cnJlbnQgY2hhcmFjdGVyIGlzIG5vdCBhIGZpZWxkIGRlbGltaXRlcilcbiAgICAgICAgICAgICAgICBjb25zdCB0b0luZGV4ID0gaW5kZXggIT09IGxhc3RDaGFyYWN0ZXJJbmRleCB8fCBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwID8gaW5kZXggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIHJlbWFpbmluZyB2YWx1ZSBhbmQgYWRkIGl0IHRvIHRoZSBzcGxpdCBsaW5lIGxpc3Qgb2YgdmFsdWVzXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4LCB0b0luZGV4KSk7XG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgcHVzaCB0aGUgc3BsaXQgbGluZSB2YWx1ZXMgaW50byB0aGUgbGluZXMgYXJyYXkgYW5kIGNsZWFyIHRoZSBzcGxpdCBsaW5lXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChzcGxpdExpbmUpO1xuICAgICAgICAgICAgICAgIHNwbGl0TGluZSA9IFtdO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleCArIGVvbERlbGltaXRlckxlbmd0aDtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSBjaGFyQWZ0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiZcbiAgICAgICAgICAgICAgICAhc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciAmJiAhc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHdyYXAgZGVsaW1pdGVyIGFmdGVyIGEgY29tbWEgYW5kIHdlIGFyZW4ndCBpbnNpZGUgYSB3cmFwIGRlbGltaXRlclxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IGNoYXJhY3RlcihzKSBhcmUgYW4gRU9MIGRlbGltaXRlciwgdGhlbiBza2lwIHRoZW0gc28gd2UgZG9uJ3QgcGFyc2Ugd2hhdCB3ZSd2ZSBzZWVuIGFzIGFub3RoZXIgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuZ2V0TkNoYXJhY3RlcnMoY3N2LCBpbmRleCArIDEsIGVvbERlbGltaXRlckxlbmd0aCkgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBvcHRpb25zLmRlbGltaXRlci5lb2wubGVuZ3RoICsgMTsgLy8gU2tpcCBwYXN0IEVPTFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkICYmIGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBjaGFyQWZ0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlYWNoZWQgdGhlIHN0YXJ0IG9mIGEgd3JhcHBlZCBuZXcgZmllbGQgdGhhdCBiZWdpbnMgd2l0aCBhbiBFT0wgZGVsaW1pdGVyXG4gICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIHJlbWFpbmluZyB2YWx1ZSBhbmQgYWRkIGl0IHRvIHRoZSBzcGxpdCBsaW5lIGxpc3Qgb2YgdmFsdWVzXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4LCBpbmRleCAtIDEpKTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5qdXN0UGFyc2VkRG91YmxlUXVvdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoY2hhckJlZm9yZSAhPT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCB8fCBzdGF0ZVZhcmlhYmxlcy5qdXN0UGFyc2VkRG91YmxlUXVvdGUgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCkgJiZcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgdXRpbHMuZ2V0TkNoYXJhY3RlcnMoY3N2LCBpbmRleCArIDEsIGVvbERlbGltaXRlckxlbmd0aCkgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoIGEgd3JhcCB3aGljaCBpcyBub3QgcHJlY2VkZWQgYnkgYSB3cmFwIGRlbGltIGFuZCB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgYW4gRU9MIGRlbGltIChpZS4gKlwiXFxuKVxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGl0ZXJhdGlvbiB3aWxsIHN1YnN0cmluZywgYWRkIHRoZSB2YWx1ZSB0byB0aGUgbGluZSwgYW5kIHB1c2ggdGhlIGxpbmUgb250byB0aGUgYXJyYXkgb2YgbGluZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiAoaW5kZXggPT09IDAgfHwgdXRpbHMuZ2V0TkNoYXJhY3RlcnMoY3N2LCBpbmRleCAtIGVvbERlbGltaXRlckxlbmd0aCwgZW9sRGVsaW1pdGVyTGVuZ3RoKSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sICYmICFzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgd3JhcCBkZWxpbWl0ZXIgKGllLiBcIiopXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCAmJiBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHdyYXAgZGVsaW1pdGVyIHdpdGggYSBmaWVsZCBkZWxpbWl0ZXIgYWZ0ZXIgaXQgKGllLiAqXCIsKVxuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKGNzdi5zdWJzdHJpbmcoc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCwgaW5kZXggKyAxKSk7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4ICsgMjsgLy8gbmV4dCB2YWx1ZSBzdGFydHMgYWZ0ZXIgdGhlIGZpZWxkIGRlbGltaXRlclxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCAmJlxuICAgICAgICAgICAgICAgICFzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyICYmIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSB3cmFwIGRlbGltaXRlciB3aXRoIGEgZmllbGQgZGVsaW1pdGVyIGFmdGVyIGl0IChpZS4gLFwiKilcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIGluZGV4IC0gMSkpO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmIGNoYXJBZnRlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBpbmRleCAhPT0gc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJ1biBpbnRvIGFuIGVzY2FwZWQgcXVvdGUgKGllLiBcIlwiKSBza2lwIHBhc3QgdGhlIHNlY29uZCBxdW90ZVxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuanVzdFBhcnNlZERvdWJsZVF1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiYgY2hhckJlZm9yZSAhPT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJlxuICAgICAgICAgICAgICAgIGNoYXJBZnRlciAhPT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiAhc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciAmJlxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBmaWVsZCBkZWxpbWl0ZXIgYW5kIGFyZSBub3QgaW5zaWRlIHRoZSB3cmFwIGRlbGltaXRlcnMgKGllLiAqLCopXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4LCBpbmRleCkpO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiZcbiAgICAgICAgICAgICAgICBjaGFyQWZ0ZXIgIT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgIXN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBmaWVsZCBkZWxpbWl0ZXIsIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgd2FzIGEgd3JhcCBkZWxpbWl0ZXIsIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIG5leHQgY2hhcmFjdGVyIGlzIG5vdCBhIHdyYXAgZGVsaW1pdGVyIChpZS4gXCIsKilcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZG91YmxlIHF1b3RlIHN0YXRlIHZhcmlhYmxlXG4gICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5qdXN0UGFyc2VkRG91YmxlUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgcmVjb3JkIGxpbmVzIGZyb20gdGhlIHNwbGl0IENTViBsaW5lcyBhbmQgc2V0cyBpdCBvbiB0aGUgcGFyYW1zIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJpZXZlUmVjb3JkTGluZXMocGFyYW1zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmhlYWRlckZpZWxkcykgeyAvLyBUaGlzIG9wdGlvbiBpcyBwYXNzZWQgZm9yIGluc3RhbmNlcyB3aGVyZSB0aGUgQ1NWIGhhcyBubyBoZWFkZXIgbGluZVxuICAgICAgICAgICAgcGFyYW1zLnJlY29yZExpbmVzID0gcGFyYW1zLmxpbmVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBBbGwgbGluZXMgZXhjZXB0IGZvciB0aGUgaGVhZGVyIGxpbmVcbiAgICAgICAgICAgIHBhcmFtcy5yZWNvcmRMaW5lcyA9IHBhcmFtcy5saW5lcy5zcGxpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBmb3IgdGhlIHJlY29yZCBmcm9tIHRoZSBsaW5lIGF0IHRoZSBwcm92aWRlZCBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmVSZWNvcmRWYWx1ZUZyb21MaW5lKGhlYWRlckZpZWxkLCBsaW5lKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdmFsdWUgYXQgdGhlIGtleSdzIGluZGV4LCB1c2UgaXQ7IG90aGVyd2lzZSwgbnVsbFxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxpbmVbaGVhZGVyRmllbGQuaW5kZXhdO1xuICAgICAgICAvLyBQZXJmb3JtIGFueSBuZWNlc3NhcnkgdmFsdWUgY29udmVyc2lvbnMgb24gdGhlIHJlY29yZCB2YWx1ZVxuICAgICAgICByZXR1cm4gcHJvY2Vzc1JlY29yZFZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSByZWNvcmQncyB2YWx1ZSBieSBwYXJzaW5nIHRoZSBkYXRhIHRvIGVuc3VyZSB0aGUgQ1NWIGlzXG4gICAgICogY29udmVydGVkIHRvIHRoZSBKU09OIHRoYXQgY3JlYXRlZCBpdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVjb3JkVmFsdWUoZmllbGRWYWx1ZSkge1xuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXkgcmVwcmVzZW50YXRpb24sIGNvbnZlcnQgaXRcbiAgICAgICAgY29uc3QgcGFyc2VkSnNvbiA9IHBhcnNlVmFsdWUoZmllbGRWYWx1ZSk7XG4gICAgICAgIC8vIElmIHBhcnNlZEpzb24gaXMgYW55dGhpbmcgYXNpZGUgZnJvbSBhbiBlcnJvciwgdGhlbiB3ZSB3YW50IHRvIHVzZSB0aGUgcGFyc2VkIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIGludGVycHJldCB2YWx1ZXMgbGlrZSAnbnVsbCcgLS0+IG51bGwsICdmYWxzZScgLS0+IGZhbHNlXG4gICAgICAgIGlmICghdXRpbHMuaXNFcnJvcihwYXJzZWRKc29uKSAmJiAhdXRpbHMuaXNJbnZhbGlkKHBhcnNlZEpzb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkSnNvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpbXMgdGhlIHJlY29yZCB2YWx1ZSwgaWYgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIHZpYSB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltUmVjb3JkVmFsdWUoZmllbGRWYWx1ZSkge1xuICAgICAgICBpZiAob3B0aW9ucy50cmltRmllbGRWYWx1ZXMgJiYgZmllbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBKU09OIGRvY3VtZW50IHdpdGggdGhlIGdpdmVuIGtleXMgKGRlc2lnbmF0ZWQgYnkgdGhlIENTViBoZWFkZXIpXG4gICAgICogICBhbmQgdGhlIHZhbHVlcyAoZnJvbSB0aGUgZ2l2ZW4gbGluZSlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjcmVhdGVkIGpzb24gZG9jdW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEb2N1bWVudChoZWFkZXJGaWVsZHMsIGxpbmUpIHtcbiAgICAgICAgLy8gUmVkdWNlIHRoZSBrZXlzIGludG8gYSBKU09OIGRvY3VtZW50IHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gbGluZVxuICAgICAgICByZXR1cm4gaGVhZGVyRmllbGRzLnJlZHVjZSgoZG9jdW1lbnQsIGhlYWRlckZpZWxkKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHZhbHVlIGF0IHRoZSBrZXkncyBpbmRleCBpbiB0aGUgbGluZSwgc2V0IHRoZSB2YWx1ZTsgb3RoZXJ3aXNlIG51bGxcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmV0cmlldmVSZWNvcmRWYWx1ZUZyb21MaW5lKGhlYWRlckZpZWxkLCBsaW5lKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCB0aGUga2V5IGFuZCB2YWx1ZSB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGRvY19wYXRoXzEuc2V0UGF0aCkoZG9jdW1lbnQsIGhlYWRlckZpZWxkLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYXRjaCBhbnkgZXJyb3JzIHdoZXJlIGtleSBwYXRocyBhcmUgbnVsbCBvciAnJyBhbmQgY29udGludWVcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgb3V0ZXJtb3N0IHdyYXAgZGVsaW1pdGVycyBmcm9tIGEgdmFsdWUsIGlmIHRoZXkgYXJlIHByZXNlbnRcbiAgICAgKiBPdGhlcndpc2UsIHRoZSBub24td3JhcHBlZCB2YWx1ZSBpcyByZXR1cm5lZCBhcyBpc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZVdyYXBEZWxpbWl0ZXJzRnJvbVZhbHVlKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDaGFyID0gZmllbGRWYWx1ZVswXSwgbGFzdEluZGV4ID0gZmllbGRWYWx1ZS5sZW5ndGggLSAxLCBsYXN0Q2hhciA9IGZpZWxkVmFsdWVbbGFzdEluZGV4XTtcbiAgICAgICAgLy8gSWYgdGhlIGZpZWxkIHN0YXJ0cyBhbmQgZW5kcyB3aXRoIGEgd3JhcCBkZWxpbWl0ZXJcbiAgICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBsYXN0Q2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBmaWVsZCBpcyBqdXN0IGEgcGFpciBvZiB3cmFwIGRlbGltaXRlcnMgXG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS5sZW5ndGggPD0gMiA/ICcnIDogZmllbGRWYWx1ZS5zdWJzdHJpbmcoMSwgbGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5lc2NhcGVzIHdyYXAgZGVsaW1pdGVycyBieSByZXBsYWNpbmcgZHVwbGljYXRlcyB3aXRoIGEgc2luZ2xlIChlZy4gXCJcIiAtPiBcIilcbiAgICAgKiBUaGlzIGlzIGRvbmUgaW4gb3JkZXIgdG8gcGFyc2UgUkZDIDQxODAgY29tcGxpYW50IENTViBiYWNrIHRvIEpTT05cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZVdyYXBEZWxpbWl0ZXJJbkZpZWxkKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUucmVwbGFjZShlc2NhcGVkV3JhcERlbGltaXRlclJlZ2V4LCBvcHRpb25zLmRlbGltaXRlci53cmFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFpbiBoZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCB0aGUgQ1NWIHRvIHRoZSBKU09OIGRvY3VtZW50IGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUmVjb3JkTGluZXMocGFyYW1zKSB7XG4gICAgICAgIC8vIEZvciBlYWNoIGxpbmUsIGNyZWF0ZSB0aGUgZG9jdW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgYXJyYXkgb2YgZG9jdW1lbnRzXG4gICAgICAgIHJldHVybiBwYXJhbXMucmVjb3JkTGluZXMucmVkdWNlKChnZW5lcmF0ZWRKc29uT2JqZWN0cywgbGluZSkgPT4ge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUubWFwKChmaWVsZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSB0aGUgbmVjZXNzYXJ5IG9wZXJhdGlvbnMgb24gZWFjaCBsaW5lXG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHJlbW92ZVdyYXBEZWxpbWl0ZXJzRnJvbVZhbHVlKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSB1bmVzY2FwZVdyYXBEZWxpbWl0ZXJJbkZpZWxkKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSB0cmltUmVjb3JkVmFsdWUoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZERvY3VtZW50ID0gY3JlYXRlRG9jdW1lbnQocGFyYW1zLmhlYWRlckZpZWxkcywgbGluZSk7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSnNvbk9iamVjdHMuY29uY2F0KGdlbmVyYXRlZERvY3VtZW50KTtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBwYXJzZSB0aGUgcHJvdmlkZWQgdmFsdWUuIElmIGl0IGlzIG5vdCBwYXJzYWJsZSwgdGhlbiBhbiBlcnJvciBpcyByZXR1cm5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZ1JlcHJlc2VudGF0aW9uKHZhbHVlLCBvcHRpb25zKSAmJiAhdXRpbHMuaXNEYXRlUmVwcmVzZW50YXRpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkSnNvbiA9IHZhbHVlUGFyc2VyRm4odmFsdWUpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHBhcnNlZCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlbiB3ZSBhbHNvIG5lZWQgdG8gdHJpbSByZWNvcmQgdmFsdWVzLCBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZEpzb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEpzb24ubWFwKHRyaW1SZWNvcmRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkSnNvbjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgZXhwb3J0ZWQgY3N2Mmpzb24gZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0KGRhdGEpIHtcbiAgICAgICAgLy8gU3BsaXQgdGhlIENTViBpbnRvIGxpbmVzIHVzaW5nIHRoZSBzcGVjaWZpZWQgRU9MIG9wdGlvblxuICAgICAgICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwRXhjZWxCT00oZGF0YSk7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gc3BsaXRMaW5lcyhzdHJpcHBlZCk7XG4gICAgICAgIGNvbnN0IGhlYWRpbmcgPSByZXRyaWV2ZUhlYWRpbmcoc3BsaXQpOyAvLyBSZXRyaWV2ZSB0aGUgaGVhZGluZ3MgZnJvbSB0aGUgQ1NWLCB1bmxlc3MgdGhlIHVzZXIgc3BlY2lmaWVkIHRoZSBrZXlzXG4gICAgICAgIGNvbnN0IGxpbmVzID0gcmV0cmlldmVSZWNvcmRMaW5lcyhoZWFkaW5nKTsgLy8gUmV0cmlldmUgdGhlIHJlY29yZCBsaW5lcyBmcm9tIHRoZSBDU1ZcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVJlY29yZExpbmVzKGxpbmVzKTsgLy8gUmV0cmlldmUgdGhlIEpTT04gZG9jdW1lbnQgYXJyYXlcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udmVydCxcbiAgICB9O1xufTtcbmV4cG9ydHMuQ3N2Mkpzb24gPSBDc3YySnNvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/csv2json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/json2csv.js":
/*!*************************************************!*\
  !*** ./node_modules/json-2-csv/lib/json2csv.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Json2Csv = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst deeks_1 = __webpack_require__(/*! deeks */ \"(ssr)/./node_modules/deeks/lib/deeks.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\"));\nconst Json2Csv = function (options) {\n    const wrapDelimiterCheckRegex = new RegExp(options.delimiter.wrap, 'g'), crlfSearchRegex = /\\r?\\n|\\r/, customValueParser = options.parseValue && typeof options.parseValue === 'function' ? options.parseValue : null, expandingWithoutUnwinding = options.expandArrayObjects && !options.unwindArrays, deeksOptions = {\n        arrayIndexesAsKeys: options.arrayIndexesAsKeys,\n        expandNestedObjects: options.expandNestedObjects,\n        expandArrayObjects: expandingWithoutUnwinding,\n        ignoreEmptyArraysWhenExpanding: expandingWithoutUnwinding,\n        escapeNestedDots: true,\n    };\n    /** HEADER FIELD FUNCTIONS **/\n    /**\n     * Returns the list of data field names of all documents in the provided list\n     */\n    function getFieldNameList(data) {\n        // If keys weren't specified, then we'll use the list of keys generated by the deeks module\n        return (0, deeks_1.deepKeysFromList)(data, deeksOptions);\n    }\n    /**\n     * Processes the schemas by checking for schema differences, if so desired.\n     * If schema differences are not to be checked, then it resolves the unique\n     * list of field names.\n     */\n    function processSchemas(documentSchemas) {\n        // If there are no document schemas then there is nothing to diff and no unique fields to get\n        if (documentSchemas.length === 0) {\n            return [];\n        }\n        // If the user wants to check for the same schema (regardless of schema ordering)\n        if (options.checkSchemaDifferences) {\n            return checkSchemaDifferences(documentSchemas);\n        }\n        else {\n            // Otherwise, we do not care if the schemas are different, so we should get the unique list of keys\n            const uniqueFieldNames = utils.unique(utils.flatten(documentSchemas));\n            return uniqueFieldNames;\n        }\n    }\n    /**\n     * This function performs the schema difference check, if the user specifies that it should be checked.\n     * If there are no field names, then there are no differences.\n     * Otherwise, we get the first schema and the remaining list of schemas\n     */\n    function checkSchemaDifferences(documentSchemas) {\n        // have multiple documents - ensure only one schema (regardless of field ordering)\n        const firstDocSchema = documentSchemas[0], restOfDocumentSchemas = documentSchemas.slice(1), schemaDifferences = computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas);\n        // If there are schema inconsistencies, throw a schema not the same error\n        if (schemaDifferences) {\n            throw new Error(constants_1.errors.json2csv.notSameSchema);\n        }\n        return firstDocSchema;\n    }\n    /**\n     * Computes the number of schema differences\n     */\n    function computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas) {\n        return restOfDocumentSchemas.reduce((schemaDifferences, documentSchema) => {\n            // If there is a difference between the schemas, increment the counter of schema inconsistencies\n            const numberOfDifferences = utils.computeSchemaDifferences(firstDocSchema, documentSchema).length;\n            return numberOfDifferences > 0\n                ? schemaDifferences + 1\n                : schemaDifferences;\n        }, 0);\n    }\n    /**\n     * If so specified, this filters the detected key paths to exclude any keys that have been specified\n     */\n    function filterExcludedKeys(keyPaths) {\n        if (options.excludeKeys) {\n            return keyPaths.filter((keyPath) => {\n                for (const excludedKey of options.excludeKeys) {\n                    // Only match if the excludedKey appears at the beginning of the string so we don't accidentally match a key farther down in a key path\n                    const regex = excludedKey instanceof RegExp ? excludedKey : new RegExp(`^${excludedKey}`);\n                    if (excludedKey === keyPath || keyPath.match(regex)) {\n                        return false; // Exclude the key\n                    }\n                }\n                return true; // Otherwise, include the key\n            });\n        }\n        return keyPaths;\n    }\n    /**\n     * If so specified, this sorts the header field names alphabetically\n     */\n    function sortHeaderFields(fieldNames) {\n        if (options.sortHeader && typeof options.sortHeader === 'function') {\n            return fieldNames.sort(options.sortHeader);\n        }\n        else if (options.sortHeader) {\n            return fieldNames.sort();\n        }\n        return fieldNames;\n    }\n    /**\n     * Trims the header fields, if the user desires them to be trimmed.\n     */\n    function trimHeaderFields(params) {\n        if (options.trimHeaderFields) {\n            params.headerFields = params.headerFields.map((field) => field.split('.')\n                .map((component) => component.trim())\n                .join('.'));\n        }\n        return params;\n    }\n    /**\n     * Wrap the headings, if desired by the user.\n     */\n    function wrapHeaderFields(params) {\n        // only perform this if we are actually prepending the header\n        if (options.prependHeader) {\n            params.headerFields = params.headerFields.map(function (headingKey) {\n                return wrapFieldValueIfNecessary(headingKey);\n            });\n        }\n        return params;\n    }\n    /**\n     * Generates the CSV header string by joining the headerFields by the field delimiter\n     */\n    function generateCsvHeader(params) {\n        // #185 - generate a keys list to avoid finding native Map() methods\n        const fieldTitleMapKeys = Object.keys(options.fieldTitleMap);\n        params.header = params.headerFields\n            .map(function (field) {\n            let headerKey = field;\n            // If a custom field title was provided for this field, use that\n            if (fieldTitleMapKeys.includes(field)) {\n                headerKey = options.fieldTitleMap[field];\n            }\n            else if (!options.escapeHeaderNestedDots) {\n                // Otherwise, if the user doesn't want nested dots in keys to be escaped, then unescape them\n                headerKey = headerKey.replace(/\\\\\\./g, '.');\n            }\n            return headerKey;\n        })\n            .join(options.delimiter.field);\n        return params;\n    }\n    function convertKeysToHeaderFields() {\n        if (!options.keys)\n            return [];\n        return options.keys.map((key) => {\n            if (typeof key === 'object' && 'field' in key) {\n                options.fieldTitleMap[key.field] = key.title ?? key.field;\n                return key.field;\n            }\n            return key;\n        });\n    }\n    function extractWildcardMatchKeys() {\n        if (!options.keys)\n            return [];\n        return options.keys.flatMap(item => {\n            if (typeof item === 'string') {\n                // Exclude plain strings that were passed in options.keys\n                return [];\n            }\n            else if (item?.wildcardMatch) {\n                // Return \"field\" value for objects with wildcardMatch: true\n                return item.field;\n            }\n            // Exclude other objects\n            return [];\n        });\n    }\n    /**\n     * Retrieve the headings for all documents and return it.\n     * This checks that all documents have the same schema.\n     */\n    function retrieveHeaderFields(data) {\n        const wildcardMatchKeys = extractWildcardMatchKeys();\n        const keyStrings = convertKeysToHeaderFields();\n        const fieldNames = getFieldNameList(data);\n        const processed = processSchemas(fieldNames);\n        if (options.keys) {\n            options.keys = keyStrings;\n            const matchedKeys = keyStrings.flatMap((userProvidedKey) => {\n                // If this is not a wildcard matched key, then just return and include it in the resulting key list\n                if (!wildcardMatchKeys.includes(userProvidedKey)) {\n                    return userProvidedKey;\n                }\n                // Otherwise, identify all detected keys that match with the provided wildcard key:\n                const matches = [];\n                const regex = new RegExp(`^${userProvidedKey}`);\n                for (const detectedKey of processed) {\n                    if (userProvidedKey === detectedKey || detectedKey.match(regex)) {\n                        matches.push(detectedKey);\n                    }\n                }\n                return matches;\n            });\n            if (!options.unwindArrays) {\n                const filtered = filterExcludedKeys(matchedKeys);\n                return sortHeaderFields(filtered);\n            }\n        }\n        const filtered = filterExcludedKeys(processed);\n        return sortHeaderFields(filtered);\n    }\n    /** RECORD FIELD FUNCTIONS **/\n    function stillNeedsUnwind(params) {\n        for (const record of params.records) {\n            for (const field of params.headerFields) {\n                const value = (0, doc_path_1.evaluatePath)(record, field);\n                if (Array.isArray(value)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Unwinds objects in arrays within record objects if the user specifies the\n     * expandArrayObjects option. If not specified, this passes the params\n     * argument through to the next function in the promise chain.\n     *\n     * The `finalPass` parameter is used to trigger one last pass to ensure no more\n     * arrays need to be expanded\n     */\n    function unwindRecordsIfNecessary(params, finalPass = false) {\n        if (options.unwindArrays) {\n            // Unwind each document at each header field\n            params.headerFields.forEach((headerField) => {\n                params.records = utils.unwind(params.records, headerField);\n            });\n            params.headerFields = retrieveHeaderFields(params.records);\n            // Continue unwinding if any nested arrays remain\n            if (stillNeedsUnwind(params)) {\n                return unwindRecordsIfNecessary(params, finalPass);\n            }\n            // Run a final time in case the earlier unwinding exposed additional\n            // arrays to unwind...\n            if (!finalPass) {\n                return unwindRecordsIfNecessary(params, true);\n            }\n            // If keys were provided, set the headerFields back to the provided keys after unwinding:\n            if (options.keys) {\n                const userSelectedFields = convertKeysToHeaderFields();\n                params.headerFields = filterExcludedKeys(userSelectedFields);\n            }\n            return params;\n        }\n        return params;\n    }\n    /**\n     * Main function which handles the processing of a record, or document to be converted to CSV format\n     * This function specifies and performs the necessary operations in the necessary order\n     * in order to obtain the data and convert it to CSV form while maintaining RFC 4180 compliance.\n     * * Order of operations:\n     * - Get fields from provided key list (as array of actual values)\n     * - Convert the values to csv/string representation [possible option here for custom converters?]\n     * - Trim fields\n     * - Determine if they need to be wrapped (& wrap if necessary)\n     * - Combine values for each line (by joining by field delimiter)\n     */\n    function processRecords(params) {\n        params.recordString = params.records.map((record) => {\n            // Retrieve data for each of the headerFields from this record\n            const recordFieldData = retrieveRecordFieldData(record, params.headerFields), \n            // Process the data in this record and return the\n            processedRecordData = recordFieldData.map((fieldValue) => {\n                fieldValue = trimRecordFieldValue(fieldValue);\n                fieldValue = preventCsvInjection(fieldValue);\n                let stringified = customValueParser ? customValueParser(fieldValue, recordFieldValueToString) : recordFieldValueToString(fieldValue);\n                stringified = wrapFieldValueIfNecessary(stringified);\n                return stringified;\n            });\n            // Join the record data by the field delimiter\n            return generateCsvRowFromRecord(processedRecordData);\n        }).join(options.delimiter.eol);\n        return params;\n    }\n    /**\n     * Helper function intended to process *just* array values when the expandArrayObjects setting is set to true\n     */\n    function processRecordFieldDataForExpandedArrayObject(recordFieldValue) {\n        const filteredRecordFieldValue = utils.removeEmptyFields(recordFieldValue);\n        // If we have an array and it's either empty of full of empty values, then use an empty value representation\n        if (!recordFieldValue.length || !filteredRecordFieldValue.length) {\n            return options.emptyFieldValue || '';\n        }\n        else if (filteredRecordFieldValue.length === 1) {\n            // Otherwise, we have an array of actual values...\n            // Since we are expanding array objects, we will want to key in on values of objects.\n            return filteredRecordFieldValue[0]; // Extract the single value in the array\n        }\n        return recordFieldValue;\n    }\n    /**\n     * Gets all field values from a particular record for the given list of fields\n     */\n    function retrieveRecordFieldData(record, fields) {\n        const recordValues = [];\n        fields.forEach((field) => {\n            let recordFieldValue = (0, doc_path_1.evaluatePath)(record, field);\n            if (!utils.isUndefined(options.emptyFieldValue) && utils.isEmptyField(recordFieldValue)) {\n                recordFieldValue = options.emptyFieldValue;\n            }\n            else if (options.expandArrayObjects && Array.isArray(recordFieldValue)) {\n                recordFieldValue = processRecordFieldDataForExpandedArrayObject(recordFieldValue);\n            }\n            recordValues.push(recordFieldValue);\n        });\n        return recordValues;\n    }\n    /**\n     * Converts a record field value to its string representation\n     */\n    function recordFieldValueToString(fieldValue) {\n        const isDate = fieldValue instanceof Date; // store to avoid checking twice\n        if (fieldValue === null || Array.isArray(fieldValue) || typeof fieldValue === 'object' && !isDate) {\n            return JSON.stringify(fieldValue);\n        }\n        else if (typeof fieldValue === 'undefined') {\n            return 'undefined';\n        }\n        else if (isDate && options.useDateIso8601Format) {\n            return fieldValue.toISOString();\n        }\n        else {\n            return !options.useLocaleFormat ? fieldValue.toString() : fieldValue.toLocaleString();\n        }\n    }\n    /**\n     * Trims the record field value, if specified by the user's provided options\n     */\n    function trimRecordFieldValue(fieldValue) {\n        if (options.trimFieldValues) {\n            if (Array.isArray(fieldValue)) {\n                return fieldValue.map(trimRecordFieldValue);\n            }\n            else if (typeof fieldValue === 'string') {\n                return fieldValue.trim();\n            }\n            return fieldValue;\n        }\n        return fieldValue;\n    }\n    /**\n     * Prevent CSV injection on strings if specified by the user's provided options.\n     * Mitigation will be done by ensuring that the first character doesn't being with:\n     * Equals (=), Plus (+), Minus (-), At (@), Tab (0x09), Carriage return (0x0D).\n     * More info: https://owasp.org/www-community/attacks/CSV_Injection\n     */\n    function preventCsvInjection(fieldValue) {\n        if (options.preventCsvInjection) {\n            if (Array.isArray(fieldValue)) {\n                return fieldValue.map(preventCsvInjection);\n            }\n            else if (typeof fieldValue === 'string' && !utils.isNumber(fieldValue)) {\n                return fieldValue.replace(/^[=+\\-@\\t\\r]+/g, '');\n            }\n            return fieldValue;\n        }\n        return fieldValue;\n    }\n    /**\n     * Escapes quotation marks in the field value, if necessary, and appropriately\n     * wraps the record field value if it contains a comma (field delimiter),\n     * quotation mark (wrap delimiter), or a line break (CRLF)\n     */\n    function wrapFieldValueIfNecessary(fieldValue) {\n        const wrapDelimiter = options.delimiter.wrap;\n        // eg. includes quotation marks (default delimiter)\n        if (fieldValue.includes(options.delimiter.wrap)) {\n            // add an additional quotation mark before each quotation mark appearing in the field value\n            fieldValue = fieldValue.replace(wrapDelimiterCheckRegex, wrapDelimiter + wrapDelimiter);\n        }\n        // if the field contains a comma (field delimiter), quotation mark (wrap delimiter), line break, or CRLF\n        //   then enclose it in quotation marks (wrap delimiter)\n        if (fieldValue.includes(options.delimiter.field) ||\n            fieldValue.includes(options.delimiter.wrap) ||\n            fieldValue.match(crlfSearchRegex) ||\n            options.wrapBooleans && (fieldValue === 'true' || fieldValue === 'false')) {\n            // wrap the field's value in a wrap delimiter (quotation marks by default)\n            fieldValue = wrapDelimiter + fieldValue + wrapDelimiter;\n        }\n        return fieldValue;\n    }\n    /**\n     * Generates the CSV record string by joining the field values together by the field delimiter\n     */\n    function generateCsvRowFromRecord(recordFieldValues) {\n        return recordFieldValues.join(options.delimiter.field);\n    }\n    /** CSV COMPONENT COMBINER/FINAL PROCESSOR **/\n    /**\n     * Performs the final CSV construction by combining the fields in the appropriate\n     * order depending on the provided options values and sends the generated CSV\n     * back to the user\n     */\n    function generateCsvFromComponents(params) {\n        const header = params.header, records = params.recordString, \n        // If we are prepending the header, then add an EOL, otherwise just return the records\n        csv = (options.excelBOM ? constants_1.excelBOM : '') +\n            (options.prependHeader ? header + options.delimiter.eol : '') +\n            records;\n        return csv;\n    }\n    /** MAIN CONVERTER FUNCTION **/\n    /**\n     * Internally exported json2csv function\n     */\n    function convert(data) {\n        // Single document, not an array\n        if (!Array.isArray(data)) {\n            data = [data]; // Convert to an array of the given document\n        }\n        // Retrieve the heading and then generate the CSV with the keys that are identified\n        const headerFields = {\n            headerFields: retrieveHeaderFields(data),\n            records: data,\n            header: '',\n            recordString: '',\n        };\n        const unwinded = unwindRecordsIfNecessary(headerFields);\n        const processed = processRecords(unwinded);\n        const wrapped = wrapHeaderFields(processed);\n        const trimmed = trimHeaderFields(wrapped);\n        const generated = generateCsvHeader(trimmed);\n        return generateCsvFromComponents(generated);\n    }\n    return {\n        convert,\n    };\n};\nexports.Json2Csv = Json2Csv;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvanNvbjJjc3YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixtQkFBbUIsbUJBQU8sQ0FBQywyREFBVTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzREFBTztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN6QywyQkFBMkIsbUJBQU8sQ0FBQyw2REFBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLFlBQVk7QUFDM0c7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyIvVXNlcnMvam9oYW4vZGV2L3BlcnNvbmFsL21leGl3ZWIvbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL2pzb24yY3N2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Kc29uMkNzdiA9IHZvaWQgMDtcbmNvbnN0IGRvY19wYXRoXzEgPSByZXF1aXJlKFwiZG9jLXBhdGhcIik7XG5jb25zdCBkZWVrc18xID0gcmVxdWlyZShcImRlZWtzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCBKc29uMkNzdiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgY29uc3Qgd3JhcERlbGltaXRlckNoZWNrUmVnZXggPSBuZXcgUmVnRXhwKG9wdGlvbnMuZGVsaW1pdGVyLndyYXAsICdnJyksIGNybGZTZWFyY2hSZWdleCA9IC9cXHI/XFxufFxcci8sIGN1c3RvbVZhbHVlUGFyc2VyID0gb3B0aW9ucy5wYXJzZVZhbHVlICYmIHR5cGVvZiBvcHRpb25zLnBhcnNlVmFsdWUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnBhcnNlVmFsdWUgOiBudWxsLCBleHBhbmRpbmdXaXRob3V0VW53aW5kaW5nID0gb3B0aW9ucy5leHBhbmRBcnJheU9iamVjdHMgJiYgIW9wdGlvbnMudW53aW5kQXJyYXlzLCBkZWVrc09wdGlvbnMgPSB7XG4gICAgICAgIGFycmF5SW5kZXhlc0FzS2V5czogb3B0aW9ucy5hcnJheUluZGV4ZXNBc0tleXMsXG4gICAgICAgIGV4cGFuZE5lc3RlZE9iamVjdHM6IG9wdGlvbnMuZXhwYW5kTmVzdGVkT2JqZWN0cyxcbiAgICAgICAgZXhwYW5kQXJyYXlPYmplY3RzOiBleHBhbmRpbmdXaXRob3V0VW53aW5kaW5nLFxuICAgICAgICBpZ25vcmVFbXB0eUFycmF5c1doZW5FeHBhbmRpbmc6IGV4cGFuZGluZ1dpdGhvdXRVbndpbmRpbmcsXG4gICAgICAgIGVzY2FwZU5lc3RlZERvdHM6IHRydWUsXG4gICAgfTtcbiAgICAvKiogSEVBREVSIEZJRUxEIEZVTkNUSU9OUyAqKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGRhdGEgZmllbGQgbmFtZXMgb2YgYWxsIGRvY3VtZW50cyBpbiB0aGUgcHJvdmlkZWQgbGlzdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZpZWxkTmFtZUxpc3QoZGF0YSkge1xuICAgICAgICAvLyBJZiBrZXlzIHdlcmVuJ3Qgc3BlY2lmaWVkLCB0aGVuIHdlJ2xsIHVzZSB0aGUgbGlzdCBvZiBrZXlzIGdlbmVyYXRlZCBieSB0aGUgZGVla3MgbW9kdWxlXG4gICAgICAgIHJldHVybiAoMCwgZGVla3NfMS5kZWVwS2V5c0Zyb21MaXN0KShkYXRhLCBkZWVrc09wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIHNjaGVtYXMgYnkgY2hlY2tpbmcgZm9yIHNjaGVtYSBkaWZmZXJlbmNlcywgaWYgc28gZGVzaXJlZC5cbiAgICAgKiBJZiBzY2hlbWEgZGlmZmVyZW5jZXMgYXJlIG5vdCB0byBiZSBjaGVja2VkLCB0aGVuIGl0IHJlc29sdmVzIHRoZSB1bmlxdWVcbiAgICAgKiBsaXN0IG9mIGZpZWxkIG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NTY2hlbWFzKGRvY3VtZW50U2NoZW1hcykge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZG9jdW1lbnQgc2NoZW1hcyB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZGlmZiBhbmQgbm8gdW5pcXVlIGZpZWxkcyB0byBnZXRcbiAgICAgICAgaWYgKGRvY3VtZW50U2NoZW1hcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdXNlciB3YW50cyB0byBjaGVjayBmb3IgdGhlIHNhbWUgc2NoZW1hIChyZWdhcmRsZXNzIG9mIHNjaGVtYSBvcmRlcmluZylcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hlY2tTY2hlbWFEaWZmZXJlbmNlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrU2NoZW1hRGlmZmVyZW5jZXMoZG9jdW1lbnRTY2hlbWFzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgZG8gbm90IGNhcmUgaWYgdGhlIHNjaGVtYXMgYXJlIGRpZmZlcmVudCwgc28gd2Ugc2hvdWxkIGdldCB0aGUgdW5pcXVlIGxpc3Qgb2Yga2V5c1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlRmllbGROYW1lcyA9IHV0aWxzLnVuaXF1ZSh1dGlscy5mbGF0dGVuKGRvY3VtZW50U2NoZW1hcykpO1xuICAgICAgICAgICAgcmV0dXJuIHVuaXF1ZUZpZWxkTmFtZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBwZXJmb3JtcyB0aGUgc2NoZW1hIGRpZmZlcmVuY2UgY2hlY2ssIGlmIHRoZSB1c2VyIHNwZWNpZmllcyB0aGF0IGl0IHNob3VsZCBiZSBjaGVja2VkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBmaWVsZCBuYW1lcywgdGhlbiB0aGVyZSBhcmUgbm8gZGlmZmVyZW5jZXMuXG4gICAgICogT3RoZXJ3aXNlLCB3ZSBnZXQgdGhlIGZpcnN0IHNjaGVtYSBhbmQgdGhlIHJlbWFpbmluZyBsaXN0IG9mIHNjaGVtYXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja1NjaGVtYURpZmZlcmVuY2VzKGRvY3VtZW50U2NoZW1hcykge1xuICAgICAgICAvLyBoYXZlIG11bHRpcGxlIGRvY3VtZW50cyAtIGVuc3VyZSBvbmx5IG9uZSBzY2hlbWEgKHJlZ2FyZGxlc3Mgb2YgZmllbGQgb3JkZXJpbmcpXG4gICAgICAgIGNvbnN0IGZpcnN0RG9jU2NoZW1hID0gZG9jdW1lbnRTY2hlbWFzWzBdLCByZXN0T2ZEb2N1bWVudFNjaGVtYXMgPSBkb2N1bWVudFNjaGVtYXMuc2xpY2UoMSksIHNjaGVtYURpZmZlcmVuY2VzID0gY29tcHV0ZU51bWJlck9mU2NoZW1hRGlmZmVyZW5jZXMoZmlyc3REb2NTY2hlbWEsIHJlc3RPZkRvY3VtZW50U2NoZW1hcyk7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBzY2hlbWEgaW5jb25zaXN0ZW5jaWVzLCB0aHJvdyBhIHNjaGVtYSBub3QgdGhlIHNhbWUgZXJyb3JcbiAgICAgICAgaWYgKHNjaGVtYURpZmZlcmVuY2VzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29uc3RhbnRzXzEuZXJyb3JzLmpzb24yY3N2Lm5vdFNhbWVTY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXJzdERvY1NjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG51bWJlciBvZiBzY2hlbWEgZGlmZmVyZW5jZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wdXRlTnVtYmVyT2ZTY2hlbWFEaWZmZXJlbmNlcyhmaXJzdERvY1NjaGVtYSwgcmVzdE9mRG9jdW1lbnRTY2hlbWFzKSB7XG4gICAgICAgIHJldHVybiByZXN0T2ZEb2N1bWVudFNjaGVtYXMucmVkdWNlKChzY2hlbWFEaWZmZXJlbmNlcywgZG9jdW1lbnRTY2hlbWEpID0+IHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzY2hlbWFzLCBpbmNyZW1lbnQgdGhlIGNvdW50ZXIgb2Ygc2NoZW1hIGluY29uc2lzdGVuY2llc1xuICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZEaWZmZXJlbmNlcyA9IHV0aWxzLmNvbXB1dGVTY2hlbWFEaWZmZXJlbmNlcyhmaXJzdERvY1NjaGVtYSwgZG9jdW1lbnRTY2hlbWEpLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJPZkRpZmZlcmVuY2VzID4gMFxuICAgICAgICAgICAgICAgID8gc2NoZW1hRGlmZmVyZW5jZXMgKyAxXG4gICAgICAgICAgICAgICAgOiBzY2hlbWFEaWZmZXJlbmNlcztcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHNvIHNwZWNpZmllZCwgdGhpcyBmaWx0ZXJzIHRoZSBkZXRlY3RlZCBrZXkgcGF0aHMgdG8gZXhjbHVkZSBhbnkga2V5cyB0aGF0IGhhdmUgYmVlbiBzcGVjaWZpZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXJFeGNsdWRlZEtleXMoa2V5UGF0aHMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXhjbHVkZUtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlQYXRocy5maWx0ZXIoKGtleVBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4Y2x1ZGVkS2V5IG9mIG9wdGlvbnMuZXhjbHVkZUtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBtYXRjaCBpZiB0aGUgZXhjbHVkZWRLZXkgYXBwZWFycyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IG1hdGNoIGEga2V5IGZhcnRoZXIgZG93biBpbiBhIGtleSBwYXRoXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZXhjbHVkZWRLZXkgaW5zdGFuY2VvZiBSZWdFeHAgPyBleGNsdWRlZEtleSA6IG5ldyBSZWdFeHAoYF4ke2V4Y2x1ZGVkS2V5fWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZWRLZXkgPT09IGtleVBhdGggfHwga2V5UGF0aC5tYXRjaChyZWdleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRXhjbHVkZSB0aGUga2V5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE90aGVyd2lzZSwgaW5jbHVkZSB0aGUga2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5UGF0aHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHNvIHNwZWNpZmllZCwgdGhpcyBzb3J0cyB0aGUgaGVhZGVyIGZpZWxkIG5hbWVzIGFscGhhYmV0aWNhbGx5XG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEhlYWRlckZpZWxkcyhmaWVsZE5hbWVzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNvcnRIZWFkZXIgJiYgdHlwZW9mIG9wdGlvbnMuc29ydEhlYWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkTmFtZXMuc29ydChvcHRpb25zLnNvcnRIZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc29ydEhlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkTmFtZXMuc29ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZE5hbWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgaGVhZGVyIGZpZWxkcywgaWYgdGhlIHVzZXIgZGVzaXJlcyB0aGVtIHRvIGJlIHRyaW1tZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUhlYWRlckZpZWxkcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudHJpbUhlYWRlckZpZWxkcykge1xuICAgICAgICAgICAgcGFyYW1zLmhlYWRlckZpZWxkcyA9IHBhcmFtcy5oZWFkZXJGaWVsZHMubWFwKChmaWVsZCkgPT4gZmllbGQuc3BsaXQoJy4nKVxuICAgICAgICAgICAgICAgIC5tYXAoKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LnRyaW0oKSlcbiAgICAgICAgICAgICAgICAuam9pbignLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcmFwIHRoZSBoZWFkaW5ncywgaWYgZGVzaXJlZCBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwSGVhZGVyRmllbGRzKHBhcmFtcykge1xuICAgICAgICAvLyBvbmx5IHBlcmZvcm0gdGhpcyBpZiB3ZSBhcmUgYWN0dWFsbHkgcHJlcGVuZGluZyB0aGUgaGVhZGVyXG4gICAgICAgIGlmIChvcHRpb25zLnByZXBlbmRIZWFkZXIpIHtcbiAgICAgICAgICAgIHBhcmFtcy5oZWFkZXJGaWVsZHMgPSBwYXJhbXMuaGVhZGVyRmllbGRzLm1hcChmdW5jdGlvbiAoaGVhZGluZ0tleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwRmllbGRWYWx1ZUlmTmVjZXNzYXJ5KGhlYWRpbmdLZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBDU1YgaGVhZGVyIHN0cmluZyBieSBqb2luaW5nIHRoZSBoZWFkZXJGaWVsZHMgYnkgdGhlIGZpZWxkIGRlbGltaXRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ3N2SGVhZGVyKHBhcmFtcykge1xuICAgICAgICAvLyAjMTg1IC0gZ2VuZXJhdGUgYSBrZXlzIGxpc3QgdG8gYXZvaWQgZmluZGluZyBuYXRpdmUgTWFwKCkgbWV0aG9kc1xuICAgICAgICBjb25zdCBmaWVsZFRpdGxlTWFwS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMuZmllbGRUaXRsZU1hcCk7XG4gICAgICAgIHBhcmFtcy5oZWFkZXIgPSBwYXJhbXMuaGVhZGVyRmllbGRzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgbGV0IGhlYWRlcktleSA9IGZpZWxkO1xuICAgICAgICAgICAgLy8gSWYgYSBjdXN0b20gZmllbGQgdGl0bGUgd2FzIHByb3ZpZGVkIGZvciB0aGlzIGZpZWxkLCB1c2UgdGhhdFxuICAgICAgICAgICAgaWYgKGZpZWxkVGl0bGVNYXBLZXlzLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcktleSA9IG9wdGlvbnMuZmllbGRUaXRsZU1hcFtmaWVsZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghb3B0aW9ucy5lc2NhcGVIZWFkZXJOZXN0ZWREb3RzKSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgdXNlciBkb2Vzbid0IHdhbnQgbmVzdGVkIGRvdHMgaW4ga2V5cyB0byBiZSBlc2NhcGVkLCB0aGVuIHVuZXNjYXBlIHRoZW1cbiAgICAgICAgICAgICAgICBoZWFkZXJLZXkgPSBoZWFkZXJLZXkucmVwbGFjZSgvXFxcXFxcLi9nLCAnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcktleTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydEtleXNUb0hlYWRlckZpZWxkcygpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmtleXMpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHJldHVybiBvcHRpb25zLmtleXMubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiAnZmllbGQnIGluIGtleSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmllbGRUaXRsZU1hcFtrZXkuZmllbGRdID0ga2V5LnRpdGxlID8/IGtleS5maWVsZDtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5LmZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dHJhY3RXaWxkY2FyZE1hdGNoS2V5cygpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmtleXMpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHJldHVybiBvcHRpb25zLmtleXMuZmxhdE1hcChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIHBsYWluIHN0cmluZ3MgdGhhdCB3ZXJlIHBhc3NlZCBpbiBvcHRpb25zLmtleXNcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtPy53aWxkY2FyZE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIFwiZmllbGRcIiB2YWx1ZSBmb3Igb2JqZWN0cyB3aXRoIHdpbGRjYXJkTWF0Y2g6IHRydWVcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5maWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4Y2x1ZGUgb3RoZXIgb2JqZWN0c1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGhlYWRpbmdzIGZvciBhbGwgZG9jdW1lbnRzIGFuZCByZXR1cm4gaXQuXG4gICAgICogVGhpcyBjaGVja3MgdGhhdCBhbGwgZG9jdW1lbnRzIGhhdmUgdGhlIHNhbWUgc2NoZW1hLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJpZXZlSGVhZGVyRmllbGRzKGRhdGEpIHtcbiAgICAgICAgY29uc3Qgd2lsZGNhcmRNYXRjaEtleXMgPSBleHRyYWN0V2lsZGNhcmRNYXRjaEtleXMoKTtcbiAgICAgICAgY29uc3Qga2V5U3RyaW5ncyA9IGNvbnZlcnRLZXlzVG9IZWFkZXJGaWVsZHMoKTtcbiAgICAgICAgY29uc3QgZmllbGROYW1lcyA9IGdldEZpZWxkTmFtZUxpc3QoZGF0YSk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IHByb2Nlc3NTY2hlbWFzKGZpZWxkTmFtZXMpO1xuICAgICAgICBpZiAob3B0aW9ucy5rZXlzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmtleXMgPSBrZXlTdHJpbmdzO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlZEtleXMgPSBrZXlTdHJpbmdzLmZsYXRNYXAoKHVzZXJQcm92aWRlZEtleSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgd2lsZGNhcmQgbWF0Y2hlZCBrZXksIHRoZW4ganVzdCByZXR1cm4gYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlc3VsdGluZyBrZXkgbGlzdFxuICAgICAgICAgICAgICAgIGlmICghd2lsZGNhcmRNYXRjaEtleXMuaW5jbHVkZXModXNlclByb3ZpZGVkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlclByb3ZpZGVkS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlkZW50aWZ5IGFsbCBkZXRlY3RlZCBrZXlzIHRoYXQgbWF0Y2ggd2l0aCB0aGUgcHJvdmlkZWQgd2lsZGNhcmQga2V5OlxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4ke3VzZXJQcm92aWRlZEtleX1gKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRldGVjdGVkS2V5IG9mIHByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlclByb3ZpZGVkS2V5ID09PSBkZXRlY3RlZEtleSB8fCBkZXRlY3RlZEtleS5tYXRjaChyZWdleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChkZXRlY3RlZEtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy51bndpbmRBcnJheXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IGZpbHRlckV4Y2x1ZGVkS2V5cyhtYXRjaGVkS2V5cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRIZWFkZXJGaWVsZHMoZmlsdGVyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gZmlsdGVyRXhjbHVkZWRLZXlzKHByb2Nlc3NlZCk7XG4gICAgICAgIHJldHVybiBzb3J0SGVhZGVyRmllbGRzKGZpbHRlcmVkKTtcbiAgICB9XG4gICAgLyoqIFJFQ09SRCBGSUVMRCBGVU5DVElPTlMgKiovXG4gICAgZnVuY3Rpb24gc3RpbGxOZWVkc1Vud2luZChwYXJhbXMpIHtcbiAgICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgcGFyYW1zLnJlY29yZHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgcGFyYW1zLmhlYWRlckZpZWxkcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKDAsIGRvY19wYXRoXzEuZXZhbHVhdGVQYXRoKShyZWNvcmQsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW53aW5kcyBvYmplY3RzIGluIGFycmF5cyB3aXRoaW4gcmVjb3JkIG9iamVjdHMgaWYgdGhlIHVzZXIgc3BlY2lmaWVzIHRoZVxuICAgICAqIGV4cGFuZEFycmF5T2JqZWN0cyBvcHRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoaXMgcGFzc2VzIHRoZSBwYXJhbXNcbiAgICAgKiBhcmd1bWVudCB0aHJvdWdoIHRvIHRoZSBuZXh0IGZ1bmN0aW9uIGluIHRoZSBwcm9taXNlIGNoYWluLlxuICAgICAqXG4gICAgICogVGhlIGBmaW5hbFBhc3NgIHBhcmFtZXRlciBpcyB1c2VkIHRvIHRyaWdnZXIgb25lIGxhc3QgcGFzcyB0byBlbnN1cmUgbm8gbW9yZVxuICAgICAqIGFycmF5cyBuZWVkIHRvIGJlIGV4cGFuZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW53aW5kUmVjb3Jkc0lmTmVjZXNzYXJ5KHBhcmFtcywgZmluYWxQYXNzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudW53aW5kQXJyYXlzKSB7XG4gICAgICAgICAgICAvLyBVbndpbmQgZWFjaCBkb2N1bWVudCBhdCBlYWNoIGhlYWRlciBmaWVsZFxuICAgICAgICAgICAgcGFyYW1zLmhlYWRlckZpZWxkcy5mb3JFYWNoKChoZWFkZXJGaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5yZWNvcmRzID0gdXRpbHMudW53aW5kKHBhcmFtcy5yZWNvcmRzLCBoZWFkZXJGaWVsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmFtcy5oZWFkZXJGaWVsZHMgPSByZXRyaWV2ZUhlYWRlckZpZWxkcyhwYXJhbXMucmVjb3Jkcyk7XG4gICAgICAgICAgICAvLyBDb250aW51ZSB1bndpbmRpbmcgaWYgYW55IG5lc3RlZCBhcnJheXMgcmVtYWluXG4gICAgICAgICAgICBpZiAoc3RpbGxOZWVkc1Vud2luZChwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVud2luZFJlY29yZHNJZk5lY2Vzc2FyeShwYXJhbXMsIGZpbmFsUGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSdW4gYSBmaW5hbCB0aW1lIGluIGNhc2UgdGhlIGVhcmxpZXIgdW53aW5kaW5nIGV4cG9zZWQgYWRkaXRpb25hbFxuICAgICAgICAgICAgLy8gYXJyYXlzIHRvIHVud2luZC4uLlxuICAgICAgICAgICAgaWYgKCFmaW5hbFBhc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW53aW5kUmVjb3Jkc0lmTmVjZXNzYXJ5KHBhcmFtcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBrZXlzIHdlcmUgcHJvdmlkZWQsIHNldCB0aGUgaGVhZGVyRmllbGRzIGJhY2sgdG8gdGhlIHByb3ZpZGVkIGtleXMgYWZ0ZXIgdW53aW5kaW5nOlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMua2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJTZWxlY3RlZEZpZWxkcyA9IGNvbnZlcnRLZXlzVG9IZWFkZXJGaWVsZHMoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuaGVhZGVyRmllbGRzID0gZmlsdGVyRXhjbHVkZWRLZXlzKHVzZXJTZWxlY3RlZEZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1haW4gZnVuY3Rpb24gd2hpY2ggaGFuZGxlcyB0aGUgcHJvY2Vzc2luZyBvZiBhIHJlY29yZCwgb3IgZG9jdW1lbnQgdG8gYmUgY29udmVydGVkIHRvIENTViBmb3JtYXRcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNwZWNpZmllcyBhbmQgcGVyZm9ybXMgdGhlIG5lY2Vzc2FyeSBvcGVyYXRpb25zIGluIHRoZSBuZWNlc3Nhcnkgb3JkZXJcbiAgICAgKiBpbiBvcmRlciB0byBvYnRhaW4gdGhlIGRhdGEgYW5kIGNvbnZlcnQgaXQgdG8gQ1NWIGZvcm0gd2hpbGUgbWFpbnRhaW5pbmcgUkZDIDQxODAgY29tcGxpYW5jZS5cbiAgICAgKiAqIE9yZGVyIG9mIG9wZXJhdGlvbnM6XG4gICAgICogLSBHZXQgZmllbGRzIGZyb20gcHJvdmlkZWQga2V5IGxpc3QgKGFzIGFycmF5IG9mIGFjdHVhbCB2YWx1ZXMpXG4gICAgICogLSBDb252ZXJ0IHRoZSB2YWx1ZXMgdG8gY3N2L3N0cmluZyByZXByZXNlbnRhdGlvbiBbcG9zc2libGUgb3B0aW9uIGhlcmUgZm9yIGN1c3RvbSBjb252ZXJ0ZXJzP11cbiAgICAgKiAtIFRyaW0gZmllbGRzXG4gICAgICogLSBEZXRlcm1pbmUgaWYgdGhleSBuZWVkIHRvIGJlIHdyYXBwZWQgKCYgd3JhcCBpZiBuZWNlc3NhcnkpXG4gICAgICogLSBDb21iaW5lIHZhbHVlcyBmb3IgZWFjaCBsaW5lIChieSBqb2luaW5nIGJ5IGZpZWxkIGRlbGltaXRlcilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVjb3JkcyhwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLnJlY29yZFN0cmluZyA9IHBhcmFtcy5yZWNvcmRzLm1hcCgocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBkYXRhIGZvciBlYWNoIG9mIHRoZSBoZWFkZXJGaWVsZHMgZnJvbSB0aGlzIHJlY29yZFxuICAgICAgICAgICAgY29uc3QgcmVjb3JkRmllbGREYXRhID0gcmV0cmlldmVSZWNvcmRGaWVsZERhdGEocmVjb3JkLCBwYXJhbXMuaGVhZGVyRmllbGRzKSwgXG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBkYXRhIGluIHRoaXMgcmVjb3JkIGFuZCByZXR1cm4gdGhlXG4gICAgICAgICAgICBwcm9jZXNzZWRSZWNvcmREYXRhID0gcmVjb3JkRmllbGREYXRhLm1hcCgoZmllbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSB0cmltUmVjb3JkRmllbGRWYWx1ZShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gcHJldmVudENzdkluamVjdGlvbihmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RyaW5naWZpZWQgPSBjdXN0b21WYWx1ZVBhcnNlciA/IGN1c3RvbVZhbHVlUGFyc2VyKGZpZWxkVmFsdWUsIHJlY29yZEZpZWxkVmFsdWVUb1N0cmluZykgOiByZWNvcmRGaWVsZFZhbHVlVG9TdHJpbmcoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZWQgPSB3cmFwRmllbGRWYWx1ZUlmTmVjZXNzYXJ5KHN0cmluZ2lmaWVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZpZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEpvaW4gdGhlIHJlY29yZCBkYXRhIGJ5IHRoZSBmaWVsZCBkZWxpbWl0ZXJcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUNzdlJvd0Zyb21SZWNvcmQocHJvY2Vzc2VkUmVjb3JkRGF0YSk7XG4gICAgICAgIH0pLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIuZW9sKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGludGVuZGVkIHRvIHByb2Nlc3MgKmp1c3QqIGFycmF5IHZhbHVlcyB3aGVuIHRoZSBleHBhbmRBcnJheU9iamVjdHMgc2V0dGluZyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZWNvcmRGaWVsZERhdGFGb3JFeHBhbmRlZEFycmF5T2JqZWN0KHJlY29yZEZpZWxkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRSZWNvcmRGaWVsZFZhbHVlID0gdXRpbHMucmVtb3ZlRW1wdHlGaWVsZHMocmVjb3JkRmllbGRWYWx1ZSk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYXJyYXkgYW5kIGl0J3MgZWl0aGVyIGVtcHR5IG9mIGZ1bGwgb2YgZW1wdHkgdmFsdWVzLCB0aGVuIHVzZSBhbiBlbXB0eSB2YWx1ZSByZXByZXNlbnRhdGlvblxuICAgICAgICBpZiAoIXJlY29yZEZpZWxkVmFsdWUubGVuZ3RoIHx8ICFmaWx0ZXJlZFJlY29yZEZpZWxkVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5lbXB0eUZpZWxkVmFsdWUgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsdGVyZWRSZWNvcmRGaWVsZFZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBoYXZlIGFuIGFycmF5IG9mIGFjdHVhbCB2YWx1ZXMuLi5cbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGFyZSBleHBhbmRpbmcgYXJyYXkgb2JqZWN0cywgd2Ugd2lsbCB3YW50IHRvIGtleSBpbiBvbiB2YWx1ZXMgb2Ygb2JqZWN0cy5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZFJlY29yZEZpZWxkVmFsdWVbMF07IC8vIEV4dHJhY3QgdGhlIHNpbmdsZSB2YWx1ZSBpbiB0aGUgYXJyYXlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkRmllbGRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgZmllbGQgdmFsdWVzIGZyb20gYSBwYXJ0aWN1bGFyIHJlY29yZCBmb3IgdGhlIGdpdmVuIGxpc3Qgb2YgZmllbGRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmVSZWNvcmRGaWVsZERhdGEocmVjb3JkLCBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkVmFsdWVzID0gW107XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlY29yZEZpZWxkVmFsdWUgPSAoMCwgZG9jX3BhdGhfMS5ldmFsdWF0ZVBhdGgpKHJlY29yZCwgZmllbGQpO1xuICAgICAgICAgICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChvcHRpb25zLmVtcHR5RmllbGRWYWx1ZSkgJiYgdXRpbHMuaXNFbXB0eUZpZWxkKHJlY29yZEZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkRmllbGRWYWx1ZSA9IG9wdGlvbnMuZW1wdHlGaWVsZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5leHBhbmRBcnJheU9iamVjdHMgJiYgQXJyYXkuaXNBcnJheShyZWNvcmRGaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlY29yZEZpZWxkVmFsdWUgPSBwcm9jZXNzUmVjb3JkRmllbGREYXRhRm9yRXhwYW5kZWRBcnJheU9iamVjdChyZWNvcmRGaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY29yZFZhbHVlcy5wdXNoKHJlY29yZEZpZWxkVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlY29yZFZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSByZWNvcmQgZmllbGQgdmFsdWUgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY29yZEZpZWxkVmFsdWVUb1N0cmluZyhmaWVsZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGlzRGF0ZSA9IGZpZWxkVmFsdWUgaW5zdGFuY2VvZiBEYXRlOyAvLyBzdG9yZSB0byBhdm9pZCBjaGVja2luZyB0d2ljZVxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGZpZWxkVmFsdWUpIHx8IHR5cGVvZiBmaWVsZFZhbHVlID09PSAnb2JqZWN0JyAmJiAhaXNEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZmllbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZpZWxkVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlICYmIG9wdGlvbnMudXNlRGF0ZUlzbzg2MDFGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gIW9wdGlvbnMudXNlTG9jYWxlRm9ybWF0ID8gZmllbGRWYWx1ZS50b1N0cmluZygpIDogZmllbGRWYWx1ZS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSByZWNvcmQgZmllbGQgdmFsdWUsIGlmIHNwZWNpZmllZCBieSB0aGUgdXNlcidzIHByb3ZpZGVkIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltUmVjb3JkRmllbGRWYWx1ZShmaWVsZFZhbHVlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnRyaW1GaWVsZFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS5tYXAodHJpbVJlY29yZEZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZpZWxkVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXZlbnQgQ1NWIGluamVjdGlvbiBvbiBzdHJpbmdzIGlmIHNwZWNpZmllZCBieSB0aGUgdXNlcidzIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogTWl0aWdhdGlvbiB3aWxsIGJlIGRvbmUgYnkgZW5zdXJpbmcgdGhhdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGRvZXNuJ3QgYmVpbmcgd2l0aDpcbiAgICAgKiBFcXVhbHMgKD0pLCBQbHVzICgrKSwgTWludXMgKC0pLCBBdCAoQCksIFRhYiAoMHgwOSksIENhcnJpYWdlIHJldHVybiAoMHgwRCkuXG4gICAgICogTW9yZSBpbmZvOiBodHRwczovL293YXNwLm9yZy93d3ctY29tbXVuaXR5L2F0dGFja3MvQ1NWX0luamVjdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXZlbnRDc3ZJbmplY3Rpb24oZmllbGRWYWx1ZSkge1xuICAgICAgICBpZiAob3B0aW9ucy5wcmV2ZW50Q3N2SW5qZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLm1hcChwcmV2ZW50Q3N2SW5qZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaWVsZFZhbHVlID09PSAnc3RyaW5nJyAmJiAhdXRpbHMuaXNOdW1iZXIoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS5yZXBsYWNlKC9eWz0rXFwtQFxcdFxccl0rL2csICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHF1b3RhdGlvbiBtYXJrcyBpbiB0aGUgZmllbGQgdmFsdWUsIGlmIG5lY2Vzc2FyeSwgYW5kIGFwcHJvcHJpYXRlbHlcbiAgICAgKiB3cmFwcyB0aGUgcmVjb3JkIGZpZWxkIHZhbHVlIGlmIGl0IGNvbnRhaW5zIGEgY29tbWEgKGZpZWxkIGRlbGltaXRlciksXG4gICAgICogcXVvdGF0aW9uIG1hcmsgKHdyYXAgZGVsaW1pdGVyKSwgb3IgYSBsaW5lIGJyZWFrIChDUkxGKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBGaWVsZFZhbHVlSWZOZWNlc3NhcnkoZmllbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCB3cmFwRGVsaW1pdGVyID0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcDtcbiAgICAgICAgLy8gZWcuIGluY2x1ZGVzIHF1b3RhdGlvbiBtYXJrcyAoZGVmYXVsdCBkZWxpbWl0ZXIpXG4gICAgICAgIGlmIChmaWVsZFZhbHVlLmluY2x1ZGVzKG9wdGlvbnMuZGVsaW1pdGVyLndyYXApKSB7XG4gICAgICAgICAgICAvLyBhZGQgYW4gYWRkaXRpb25hbCBxdW90YXRpb24gbWFyayBiZWZvcmUgZWFjaCBxdW90YXRpb24gbWFyayBhcHBlYXJpbmcgaW4gdGhlIGZpZWxkIHZhbHVlXG4gICAgICAgICAgICBmaWVsZFZhbHVlID0gZmllbGRWYWx1ZS5yZXBsYWNlKHdyYXBEZWxpbWl0ZXJDaGVja1JlZ2V4LCB3cmFwRGVsaW1pdGVyICsgd3JhcERlbGltaXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGZpZWxkIGNvbnRhaW5zIGEgY29tbWEgKGZpZWxkIGRlbGltaXRlciksIHF1b3RhdGlvbiBtYXJrICh3cmFwIGRlbGltaXRlciksIGxpbmUgYnJlYWssIG9yIENSTEZcbiAgICAgICAgLy8gICB0aGVuIGVuY2xvc2UgaXQgaW4gcXVvdGF0aW9uIG1hcmtzICh3cmFwIGRlbGltaXRlcilcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUuaW5jbHVkZXMob3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpIHx8XG4gICAgICAgICAgICBmaWVsZFZhbHVlLmluY2x1ZGVzKG9wdGlvbnMuZGVsaW1pdGVyLndyYXApIHx8XG4gICAgICAgICAgICBmaWVsZFZhbHVlLm1hdGNoKGNybGZTZWFyY2hSZWdleCkgfHxcbiAgICAgICAgICAgIG9wdGlvbnMud3JhcEJvb2xlYW5zICYmIChmaWVsZFZhbHVlID09PSAndHJ1ZScgfHwgZmllbGRWYWx1ZSA9PT0gJ2ZhbHNlJykpIHtcbiAgICAgICAgICAgIC8vIHdyYXAgdGhlIGZpZWxkJ3MgdmFsdWUgaW4gYSB3cmFwIGRlbGltaXRlciAocXVvdGF0aW9uIG1hcmtzIGJ5IGRlZmF1bHQpXG4gICAgICAgICAgICBmaWVsZFZhbHVlID0gd3JhcERlbGltaXRlciArIGZpZWxkVmFsdWUgKyB3cmFwRGVsaW1pdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIENTViByZWNvcmQgc3RyaW5nIGJ5IGpvaW5pbmcgdGhlIGZpZWxkIHZhbHVlcyB0b2dldGhlciBieSB0aGUgZmllbGQgZGVsaW1pdGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDc3ZSb3dGcm9tUmVjb3JkKHJlY29yZEZpZWxkVmFsdWVzKSB7XG4gICAgICAgIHJldHVybiByZWNvcmRGaWVsZFZhbHVlcy5qb2luKG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKTtcbiAgICB9XG4gICAgLyoqIENTViBDT01QT05FTlQgQ09NQklORVIvRklOQUwgUFJPQ0VTU09SICoqL1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBmaW5hbCBDU1YgY29uc3RydWN0aW9uIGJ5IGNvbWJpbmluZyB0aGUgZmllbGRzIGluIHRoZSBhcHByb3ByaWF0ZVxuICAgICAqIG9yZGVyIGRlcGVuZGluZyBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucyB2YWx1ZXMgYW5kIHNlbmRzIHRoZSBnZW5lcmF0ZWQgQ1NWXG4gICAgICogYmFjayB0byB0aGUgdXNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ3N2RnJvbUNvbXBvbmVudHMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHBhcmFtcy5oZWFkZXIsIHJlY29yZHMgPSBwYXJhbXMucmVjb3JkU3RyaW5nLCBcbiAgICAgICAgLy8gSWYgd2UgYXJlIHByZXBlbmRpbmcgdGhlIGhlYWRlciwgdGhlbiBhZGQgYW4gRU9MLCBvdGhlcndpc2UganVzdCByZXR1cm4gdGhlIHJlY29yZHNcbiAgICAgICAgY3N2ID0gKG9wdGlvbnMuZXhjZWxCT00gPyBjb25zdGFudHNfMS5leGNlbEJPTSA6ICcnKSArXG4gICAgICAgICAgICAob3B0aW9ucy5wcmVwZW5kSGVhZGVyID8gaGVhZGVyICsgb3B0aW9ucy5kZWxpbWl0ZXIuZW9sIDogJycpICtcbiAgICAgICAgICAgIHJlY29yZHM7XG4gICAgICAgIHJldHVybiBjc3Y7XG4gICAgfVxuICAgIC8qKiBNQUlOIENPTlZFUlRFUiBGVU5DVElPTiAqKi9cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IGV4cG9ydGVkIGpzb24yY3N2IGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydChkYXRhKSB7XG4gICAgICAgIC8vIFNpbmdsZSBkb2N1bWVudCwgbm90IGFuIGFycmF5XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTsgLy8gQ29udmVydCB0byBhbiBhcnJheSBvZiB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgaGVhZGluZyBhbmQgdGhlbiBnZW5lcmF0ZSB0aGUgQ1NWIHdpdGggdGhlIGtleXMgdGhhdCBhcmUgaWRlbnRpZmllZFxuICAgICAgICBjb25zdCBoZWFkZXJGaWVsZHMgPSB7XG4gICAgICAgICAgICBoZWFkZXJGaWVsZHM6IHJldHJpZXZlSGVhZGVyRmllbGRzKGRhdGEpLFxuICAgICAgICAgICAgcmVjb3JkczogZGF0YSxcbiAgICAgICAgICAgIGhlYWRlcjogJycsXG4gICAgICAgICAgICByZWNvcmRTdHJpbmc6ICcnLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1bndpbmRlZCA9IHVud2luZFJlY29yZHNJZk5lY2Vzc2FyeShoZWFkZXJGaWVsZHMpO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBwcm9jZXNzUmVjb3Jkcyh1bndpbmRlZCk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWQgPSB3cmFwSGVhZGVyRmllbGRzKHByb2Nlc3NlZCk7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSB0cmltSGVhZGVyRmllbGRzKHdyYXBwZWQpO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWQgPSBnZW5lcmF0ZUNzdkhlYWRlcih0cmltbWVkKTtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ3N2RnJvbUNvbXBvbmVudHMoZ2VuZXJhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udmVydCxcbiAgICB9O1xufTtcbmV4cG9ydHMuSnNvbjJDc3YgPSBKc29uMkNzdjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/json2csv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/json-2-csv/lib/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInvalid = exports.flatten = exports.unique = exports.arrayDifference = exports.isError = exports.isUndefined = exports.isNull = exports.isObject = exports.isString = exports.isNumber = exports.unwind = exports.getNCharacters = exports.removeEmptyFields = exports.isEmptyField = exports.computeSchemaDifferences = exports.isDateRepresentation = exports.isStringRepresentation = exports.deepCopy = exports.validate = exports.buildC2JOptions = exports.buildJ2COptions = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst dateStringRegex = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/, MAX_ARRAY_LENGTH = 100000;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildJ2COptions(opts) {\n    return {\n        ...constants_1.defaultJson2CsvOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultJson2CsvOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultJson2CsvOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultJson2CsvOptions.delimiter.eol,\n        },\n        fieldTitleMap: Object.create({}),\n    };\n}\nexports.buildJ2COptions = buildJ2COptions;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildC2JOptions(opts) {\n    return {\n        ...constants_1.defaultCsv2JsonOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultCsv2JsonOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultCsv2JsonOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultCsv2JsonOptions.delimiter.eol,\n        },\n    };\n}\nexports.buildC2JOptions = buildC2JOptions;\nfunction validate(data, validationFn, errorMessages) {\n    if (!data)\n        throw new Error(`${errorMessages.cannotCallOn} ${data}.`);\n    if (!validationFn(data))\n        throw new Error(errorMessages.dataCheckFailure);\n    return true;\n}\nexports.validate = validate;\n/**\n * Utility function to deep copy an object, used by the module tests\n */\nfunction deepCopy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.deepCopy = deepCopy;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a string. Given the RFC4180 requirements, that means that the value is\n *   wrapped in value wrap delimiters (usually a quotation mark on each side).\n */\nfunction isStringRepresentation(fieldValue, options) {\n    const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n    // If the field starts and ends with a wrap delimiter\n    return firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap;\n}\nexports.isStringRepresentation = isStringRepresentation;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a date.\n */\nfunction isDateRepresentation(fieldValue) {\n    return dateStringRegex.test(fieldValue);\n}\nexports.isDateRepresentation = isDateRepresentation;\n/**\n * Helper function that determines the schema differences between two objects.\n */\nfunction computeSchemaDifferences(schemaA, schemaB) {\n    return arrayDifference(schemaA, schemaB)\n        .concat(arrayDifference(schemaB, schemaA));\n}\nexports.computeSchemaDifferences = computeSchemaDifferences;\n/**\n * Utility function to check if a field is considered empty so that the emptyFieldValue can be used instead\n */\nfunction isEmptyField(fieldValue) {\n    return isUndefined(fieldValue) || isNull(fieldValue) || fieldValue === '';\n}\nexports.isEmptyField = isEmptyField;\n/**\n * Helper function that removes empty field values from an array.\n */\nfunction removeEmptyFields(fields) {\n    return fields.filter((field) => !isEmptyField(field));\n}\nexports.removeEmptyFields = removeEmptyFields;\n/**\n * Helper function that retrieves the next n characters from the start index in\n *   the string including the character at the start index. This is used to\n *   check if are currently at an EOL value, since it could be multiple\n *   characters in length (eg. '\\r\\n')\n */\nfunction getNCharacters(str, start, n) {\n    return str.substring(start, start + n);\n}\nexports.getNCharacters = getNCharacters;\n/**\n * The following unwind functionality is a heavily modified version of @edwincen's\n * unwind extension for lodash. Since lodash is a large package to require in,\n * and all of the required functionality was already being imported, either\n * natively or with doc-path, I decided to rewrite the majority of the logic\n * so that an additional dependency would not be required. The original code\n * with the lodash dependency can be found here:\n *\n * https://github.com/edwincen/unwind/blob/master/index.js\n */\n/**\n * Core function that unwinds an item at the provided path\n */\nfunction unwindItem(accumulator, item, fieldPath) {\n    const valueToUnwind = (0, doc_path_1.evaluatePath)(item, fieldPath);\n    let cloned = deepCopy(item);\n    if (Array.isArray(valueToUnwind) && valueToUnwind.length) {\n        valueToUnwind.forEach((val) => {\n            cloned = deepCopy(item);\n            accumulator.push((0, doc_path_1.setPath)(cloned, fieldPath, val));\n        });\n    }\n    else if (Array.isArray(valueToUnwind) && valueToUnwind.length === 0) {\n        // Push an empty string so the value is empty since there are no values\n        (0, doc_path_1.setPath)(cloned, fieldPath, '');\n        accumulator.push(cloned);\n    }\n    else {\n        accumulator.push(cloned);\n    }\n}\n/**\n * Main unwind function which takes an array and a field to unwind.\n */\nfunction unwind(array, field) {\n    const result = [];\n    array.forEach((item) => {\n        unwindItem(result, item, field);\n    });\n    return result;\n}\nexports.unwind = unwind;\n/**\n * Checks whether value can be converted to a number\n */\nfunction isNumber(value) {\n    return !isNaN(Number(value));\n}\nexports.isNumber = isNumber;\n/*\n * Helper functions which were created to remove underscorejs from this package.\n */\nfunction isString(value) {\n    return typeof value === 'string';\n}\nexports.isString = isString;\nfunction isObject(value) {\n    return typeof value === 'object';\n}\nexports.isObject = isObject;\nfunction isNull(value) {\n    return value === null;\n}\nexports.isNull = isNull;\nfunction isUndefined(value) {\n    return typeof value === 'undefined';\n}\nexports.isUndefined = isUndefined;\nfunction isError(value) {\n    // TODO(mrodrig): test this possible change\n    // return value instanceof Error;\n    return Object.prototype.toString.call(value) === '[object Error]';\n}\nexports.isError = isError;\nfunction arrayDifference(a, b) {\n    return a.filter((x) => !b.includes(x));\n}\nexports.arrayDifference = arrayDifference;\nfunction unique(array) {\n    return [...new Set(array)];\n}\nexports.unique = unique;\nfunction flatten(array) {\n    // Node 11+ - use the native array flattening function\n    if (array.flat) {\n        return array.flat();\n    }\n    // #167 - allow browsers to flatten very long 200k+ element arrays\n    if (array.length > MAX_ARRAY_LENGTH) {\n        let safeArray = [];\n        for (let a = 0; a < array.length; a += MAX_ARRAY_LENGTH) {\n            safeArray = safeArray.concat(...array.slice(a, a + MAX_ARRAY_LENGTH));\n        }\n        return safeArray;\n    }\n    return array.reduce((accumulator, value) => accumulator.concat(value), []);\n}\nexports.flatten = flatten;\n/**\n * Used to help avoid incorrect values returned by JSON.parse when converting\n * CSV back to JSON, such as '39e1804' which JSON.parse converts to Infinity\n */\nfunction isInvalid(parsedJson) {\n    return parsedJson === Infinity ||\n        parsedJson === -Infinity;\n}\nexports.isInvalid = isInvalid;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyx1QkFBdUIsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxzQkFBc0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxnQ0FBZ0MsR0FBRyw0QkFBNEIsR0FBRyw4QkFBOEIsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDMWQsbUJBQW1CLG1CQUFPLENBQUMsMkRBQVU7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMscUVBQWE7QUFDekMsNEJBQTRCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QixFQUFFLEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvam9oYW4vZGV2L3BlcnNvbmFsL21leGl3ZWIvbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNJbnZhbGlkID0gZXhwb3J0cy5mbGF0dGVuID0gZXhwb3J0cy51bmlxdWUgPSBleHBvcnRzLmFycmF5RGlmZmVyZW5jZSA9IGV4cG9ydHMuaXNFcnJvciA9IGV4cG9ydHMuaXNVbmRlZmluZWQgPSBleHBvcnRzLmlzTnVsbCA9IGV4cG9ydHMuaXNPYmplY3QgPSBleHBvcnRzLmlzU3RyaW5nID0gZXhwb3J0cy5pc051bWJlciA9IGV4cG9ydHMudW53aW5kID0gZXhwb3J0cy5nZXROQ2hhcmFjdGVycyA9IGV4cG9ydHMucmVtb3ZlRW1wdHlGaWVsZHMgPSBleHBvcnRzLmlzRW1wdHlGaWVsZCA9IGV4cG9ydHMuY29tcHV0ZVNjaGVtYURpZmZlcmVuY2VzID0gZXhwb3J0cy5pc0RhdGVSZXByZXNlbnRhdGlvbiA9IGV4cG9ydHMuaXNTdHJpbmdSZXByZXNlbnRhdGlvbiA9IGV4cG9ydHMuZGVlcENvcHkgPSBleHBvcnRzLnZhbGlkYXRlID0gZXhwb3J0cy5idWlsZEMySk9wdGlvbnMgPSBleHBvcnRzLmJ1aWxkSjJDT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGRvY19wYXRoXzEgPSByZXF1aXJlKFwiZG9jLXBhdGhcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGRhdGVTdHJpbmdSZWdleCA9IC9cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfS5cXGR7M31aLywgTUFYX0FSUkFZX0xFTkdUSCA9IDEwMDAwMDtcbi8qKlxuICogQnVpbGQgdGhlIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvblxuICogSWYgYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgY3VzdG9tIG9wdGlvbnMsIHRoZW4gd2UgdXNlIG91ciBkZWZhdWx0XG4gKiBJZiBvcHRpb25zIGFyZSBwcm92aWRlZCwgdGhlbiB3ZSBzZXQgZWFjaCB2YWxpZCBrZXkgdGhhdCB3YXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkSjJDT3B0aW9ucyhvcHRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uc3RhbnRzXzEuZGVmYXVsdEpzb24yQ3N2T3B0aW9ucyxcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZGVsaW1pdGVyOiB7XG4gICAgICAgICAgICBmaWVsZDogb3B0cz8uZGVsaW1pdGVyPy5maWVsZCA/PyBjb25zdGFudHNfMS5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zLmRlbGltaXRlci5maWVsZCxcbiAgICAgICAgICAgIHdyYXA6IG9wdHM/LmRlbGltaXRlcj8ud3JhcCB8fCBjb25zdGFudHNfMS5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zLmRlbGltaXRlci53cmFwLFxuICAgICAgICAgICAgZW9sOiBvcHRzPy5kZWxpbWl0ZXI/LmVvbCB8fCBjb25zdGFudHNfMS5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zLmRlbGltaXRlci5lb2wsXG4gICAgICAgIH0sXG4gICAgICAgIGZpZWxkVGl0bGVNYXA6IE9iamVjdC5jcmVhdGUoe30pLFxuICAgIH07XG59XG5leHBvcnRzLmJ1aWxkSjJDT3B0aW9ucyA9IGJ1aWxkSjJDT3B0aW9ucztcbi8qKlxuICogQnVpbGQgdGhlIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvblxuICogSWYgYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgY3VzdG9tIG9wdGlvbnMsIHRoZW4gd2UgdXNlIG91ciBkZWZhdWx0XG4gKiBJZiBvcHRpb25zIGFyZSBwcm92aWRlZCwgdGhlbiB3ZSBzZXQgZWFjaCB2YWxpZCBrZXkgdGhhdCB3YXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQzJKT3B0aW9ucyhvcHRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uc3RhbnRzXzEuZGVmYXVsdENzdjJKc29uT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZGVsaW1pdGVyOiB7XG4gICAgICAgICAgICBmaWVsZDogb3B0cz8uZGVsaW1pdGVyPy5maWVsZCA/PyBjb25zdGFudHNfMS5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zLmRlbGltaXRlci5maWVsZCxcbiAgICAgICAgICAgIHdyYXA6IG9wdHM/LmRlbGltaXRlcj8ud3JhcCB8fCBjb25zdGFudHNfMS5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zLmRlbGltaXRlci53cmFwLFxuICAgICAgICAgICAgZW9sOiBvcHRzPy5kZWxpbWl0ZXI/LmVvbCB8fCBjb25zdGFudHNfMS5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zLmRlbGltaXRlci5lb2wsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuYnVpbGRDMkpPcHRpb25zID0gYnVpbGRDMkpPcHRpb25zO1xuZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSwgdmFsaWRhdGlvbkZuLCBlcnJvck1lc3NhZ2VzKSB7XG4gICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JNZXNzYWdlcy5jYW5ub3RDYWxsT259ICR7ZGF0YX0uYCk7XG4gICAgaWYgKCF2YWxpZGF0aW9uRm4oZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2VzLmRhdGFDaGVja0ZhaWx1cmUpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGRlZXAgY29weSBhbiBvYmplY3QsIHVzZWQgYnkgdGhlIG1vZHVsZSB0ZXN0c1xuICovXG5mdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbmV4cG9ydHMuZGVlcENvcHkgPSBkZWVwQ29weTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIHJlcHJlc2VudGF0aW9uXG4gKiAgIG9mIGEgc3RyaW5nLiBHaXZlbiB0aGUgUkZDNDE4MCByZXF1aXJlbWVudHMsIHRoYXQgbWVhbnMgdGhhdCB0aGUgdmFsdWUgaXNcbiAqICAgd3JhcHBlZCBpbiB2YWx1ZSB3cmFwIGRlbGltaXRlcnMgKHVzdWFsbHkgYSBxdW90YXRpb24gbWFyayBvbiBlYWNoIHNpZGUpLlxuICovXG5mdW5jdGlvbiBpc1N0cmluZ1JlcHJlc2VudGF0aW9uKGZpZWxkVmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaXJzdENoYXIgPSBmaWVsZFZhbHVlWzBdLCBsYXN0SW5kZXggPSBmaWVsZFZhbHVlLmxlbmd0aCAtIDEsIGxhc3RDaGFyID0gZmllbGRWYWx1ZVtsYXN0SW5kZXhdO1xuICAgIC8vIElmIHRoZSBmaWVsZCBzdGFydHMgYW5kIGVuZHMgd2l0aCBhIHdyYXAgZGVsaW1pdGVyXG4gICAgcmV0dXJuIGZpcnN0Q2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBsYXN0Q2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcDtcbn1cbmV4cG9ydHMuaXNTdHJpbmdSZXByZXNlbnRhdGlvbiA9IGlzU3RyaW5nUmVwcmVzZW50YXRpb247XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSByZXByZXNlbnRhdGlvblxuICogICBvZiBhIGRhdGUuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZVJlcHJlc2VudGF0aW9uKGZpZWxkVmFsdWUpIHtcbiAgICByZXR1cm4gZGF0ZVN0cmluZ1JlZ2V4LnRlc3QoZmllbGRWYWx1ZSk7XG59XG5leHBvcnRzLmlzRGF0ZVJlcHJlc2VudGF0aW9uID0gaXNEYXRlUmVwcmVzZW50YXRpb247XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgdGhlIHNjaGVtYSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBjb21wdXRlU2NoZW1hRGlmZmVyZW5jZXMoc2NoZW1hQSwgc2NoZW1hQikge1xuICAgIHJldHVybiBhcnJheURpZmZlcmVuY2Uoc2NoZW1hQSwgc2NoZW1hQilcbiAgICAgICAgLmNvbmNhdChhcnJheURpZmZlcmVuY2Uoc2NoZW1hQiwgc2NoZW1hQSkpO1xufVxuZXhwb3J0cy5jb21wdXRlU2NoZW1hRGlmZmVyZW5jZXMgPSBjb21wdXRlU2NoZW1hRGlmZmVyZW5jZXM7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBmaWVsZCBpcyBjb25zaWRlcmVkIGVtcHR5IHNvIHRoYXQgdGhlIGVtcHR5RmllbGRWYWx1ZSBjYW4gYmUgdXNlZCBpbnN0ZWFkXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHlGaWVsZChmaWVsZFZhbHVlKSB7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKGZpZWxkVmFsdWUpIHx8IGlzTnVsbChmaWVsZFZhbHVlKSB8fCBmaWVsZFZhbHVlID09PSAnJztcbn1cbmV4cG9ydHMuaXNFbXB0eUZpZWxkID0gaXNFbXB0eUZpZWxkO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZW1vdmVzIGVtcHR5IGZpZWxkIHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmVFbXB0eUZpZWxkcyhmaWVsZHMpIHtcbiAgICByZXR1cm4gZmllbGRzLmZpbHRlcigoZmllbGQpID0+ICFpc0VtcHR5RmllbGQoZmllbGQpKTtcbn1cbmV4cG9ydHMucmVtb3ZlRW1wdHlGaWVsZHMgPSByZW1vdmVFbXB0eUZpZWxkcztcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0cmlldmVzIHRoZSBuZXh0IG4gY2hhcmFjdGVycyBmcm9tIHRoZSBzdGFydCBpbmRleCBpblxuICogICB0aGUgc3RyaW5nIGluY2x1ZGluZyB0aGUgY2hhcmFjdGVyIGF0IHRoZSBzdGFydCBpbmRleC4gVGhpcyBpcyB1c2VkIHRvXG4gKiAgIGNoZWNrIGlmIGFyZSBjdXJyZW50bHkgYXQgYW4gRU9MIHZhbHVlLCBzaW5jZSBpdCBjb3VsZCBiZSBtdWx0aXBsZVxuICogICBjaGFyYWN0ZXJzIGluIGxlbmd0aCAoZWcuICdcXHJcXG4nKVxuICovXG5mdW5jdGlvbiBnZXROQ2hhcmFjdGVycyhzdHIsIHN0YXJ0LCBuKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQsIHN0YXJ0ICsgbik7XG59XG5leHBvcnRzLmdldE5DaGFyYWN0ZXJzID0gZ2V0TkNoYXJhY3RlcnM7XG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgdW53aW5kIGZ1bmN0aW9uYWxpdHkgaXMgYSBoZWF2aWx5IG1vZGlmaWVkIHZlcnNpb24gb2YgQGVkd2luY2VuJ3NcbiAqIHVud2luZCBleHRlbnNpb24gZm9yIGxvZGFzaC4gU2luY2UgbG9kYXNoIGlzIGEgbGFyZ2UgcGFja2FnZSB0byByZXF1aXJlIGluLFxuICogYW5kIGFsbCBvZiB0aGUgcmVxdWlyZWQgZnVuY3Rpb25hbGl0eSB3YXMgYWxyZWFkeSBiZWluZyBpbXBvcnRlZCwgZWl0aGVyXG4gKiBuYXRpdmVseSBvciB3aXRoIGRvYy1wYXRoLCBJIGRlY2lkZWQgdG8gcmV3cml0ZSB0aGUgbWFqb3JpdHkgb2YgdGhlIGxvZ2ljXG4gKiBzbyB0aGF0IGFuIGFkZGl0aW9uYWwgZGVwZW5kZW5jeSB3b3VsZCBub3QgYmUgcmVxdWlyZWQuIFRoZSBvcmlnaW5hbCBjb2RlXG4gKiB3aXRoIHRoZSBsb2Rhc2ggZGVwZW5kZW5jeSBjYW4gYmUgZm91bmQgaGVyZTpcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZWR3aW5jZW4vdW53aW5kL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gKi9cbi8qKlxuICogQ29yZSBmdW5jdGlvbiB0aGF0IHVud2luZHMgYW4gaXRlbSBhdCB0aGUgcHJvdmlkZWQgcGF0aFxuICovXG5mdW5jdGlvbiB1bndpbmRJdGVtKGFjY3VtdWxhdG9yLCBpdGVtLCBmaWVsZFBhdGgpIHtcbiAgICBjb25zdCB2YWx1ZVRvVW53aW5kID0gKDAsIGRvY19wYXRoXzEuZXZhbHVhdGVQYXRoKShpdGVtLCBmaWVsZFBhdGgpO1xuICAgIGxldCBjbG9uZWQgPSBkZWVwQ29weShpdGVtKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVRvVW53aW5kKSAmJiB2YWx1ZVRvVW53aW5kLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZVRvVW53aW5kLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgY2xvbmVkID0gZGVlcENvcHkoaXRlbSk7XG4gICAgICAgICAgICBhY2N1bXVsYXRvci5wdXNoKCgwLCBkb2NfcGF0aF8xLnNldFBhdGgpKGNsb25lZCwgZmllbGRQYXRoLCB2YWwpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVUb1Vud2luZCkgJiYgdmFsdWVUb1Vud2luZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gUHVzaCBhbiBlbXB0eSBzdHJpbmcgc28gdGhlIHZhbHVlIGlzIGVtcHR5IHNpbmNlIHRoZXJlIGFyZSBubyB2YWx1ZXNcbiAgICAgICAgKDAsIGRvY19wYXRoXzEuc2V0UGF0aCkoY2xvbmVkLCBmaWVsZFBhdGgsICcnKTtcbiAgICAgICAgYWNjdW11bGF0b3IucHVzaChjbG9uZWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjdW11bGF0b3IucHVzaChjbG9uZWQpO1xuICAgIH1cbn1cbi8qKlxuICogTWFpbiB1bndpbmQgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW4gYXJyYXkgYW5kIGEgZmllbGQgdG8gdW53aW5kLlxuICovXG5mdW5jdGlvbiB1bndpbmQoYXJyYXksIGZpZWxkKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgYXJyYXkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICB1bndpbmRJdGVtKHJlc3VsdCwgaXRlbSwgZmllbGQpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVud2luZCA9IHVud2luZDtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdmFsdWUgY2FuIGJlIGNvbnZlcnRlZCB0byBhIG51bWJlclxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiAhaXNOYU4oTnVtYmVyKHZhbHVlKSk7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyB3aGljaCB3ZXJlIGNyZWF0ZWQgdG8gcmVtb3ZlIHVuZGVyc2NvcmVqcyBmcm9tIHRoaXMgcGFja2FnZS5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5mdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgLy8gVE9ETyhtcm9kcmlnKTogdGVzdCB0aGlzIHBvc3NpYmxlIGNoYW5nZVxuICAgIC8vIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBFcnJvcl0nO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmZ1bmN0aW9uIGFycmF5RGlmZmVyZW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKCh4KSA9PiAhYi5pbmNsdWRlcyh4KSk7XG59XG5leHBvcnRzLmFycmF5RGlmZmVyZW5jZSA9IGFycmF5RGlmZmVyZW5jZTtcbmZ1bmN0aW9uIHVuaXF1ZShhcnJheSkge1xuICAgIHJldHVybiBbLi4ubmV3IFNldChhcnJheSldO1xufVxuZXhwb3J0cy51bmlxdWUgPSB1bmlxdWU7XG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gICAgLy8gTm9kZSAxMSsgLSB1c2UgdGhlIG5hdGl2ZSBhcnJheSBmbGF0dGVuaW5nIGZ1bmN0aW9uXG4gICAgaWYgKGFycmF5LmZsYXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmZsYXQoKTtcbiAgICB9XG4gICAgLy8gIzE2NyAtIGFsbG93IGJyb3dzZXJzIHRvIGZsYXR0ZW4gdmVyeSBsb25nIDIwMGsrIGVsZW1lbnQgYXJyYXlzXG4gICAgaWYgKGFycmF5Lmxlbmd0aCA+IE1BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgbGV0IHNhZmVBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGFycmF5Lmxlbmd0aDsgYSArPSBNQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgICAgICBzYWZlQXJyYXkgPSBzYWZlQXJyYXkuY29uY2F0KC4uLmFycmF5LnNsaWNlKGEsIGEgKyBNQVhfQVJSQVlfTEVOR1RIKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhZmVBcnJheTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgoYWNjdW11bGF0b3IsIHZhbHVlKSA9PiBhY2N1bXVsYXRvci5jb25jYXQodmFsdWUpLCBbXSk7XG59XG5leHBvcnRzLmZsYXR0ZW4gPSBmbGF0dGVuO1xuLyoqXG4gKiBVc2VkIHRvIGhlbHAgYXZvaWQgaW5jb3JyZWN0IHZhbHVlcyByZXR1cm5lZCBieSBKU09OLnBhcnNlIHdoZW4gY29udmVydGluZ1xuICogQ1NWIGJhY2sgdG8gSlNPTiwgc3VjaCBhcyAnMzllMTgwNCcgd2hpY2ggSlNPTi5wYXJzZSBjb252ZXJ0cyB0byBJbmZpbml0eVxuICovXG5mdW5jdGlvbiBpc0ludmFsaWQocGFyc2VkSnNvbikge1xuICAgIHJldHVybiBwYXJzZWRKc29uID09PSBJbmZpbml0eSB8fFxuICAgICAgICBwYXJzZWRKc29uID09PSAtSW5maW5pdHk7XG59XG5leHBvcnRzLmlzSW52YWxpZCA9IGlzSW52YWxpZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/utils.js\n");

/***/ })

};
;