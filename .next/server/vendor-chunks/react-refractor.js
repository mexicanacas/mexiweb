"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-refractor";
exports.ids = ["vendor-chunks/react-refractor"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-refractor/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/react-refractor/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Refractor: () => (/* binding */ Refractor),\n/* harmony export */   hasLanguage: () => (/* binding */ hasLanguage),\n/* harmony export */   registerLanguage: () => (/* binding */ registerLanguage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var refractor_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! refractor/core */ \"(ssr)/./node_modules/refractor/lib/core.js\");\n/* harmony import */ var unist_util_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-filter */ \"(ssr)/./node_modules/unist-util-filter/lib/index.js\");\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-visit-parents */ \"(ssr)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n\n\nvar __defProp$2 = Object.defineProperty, __defProps$2 = Object.defineProperties, __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b))\n      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  return a;\n}, __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nfunction addMarkers(ast, options) {\n  const markers = options.markers.map((marker) => typeof marker == \"number\" ? { line: marker } : marker).sort((nodeA, nodeB) => nodeA.line - nodeB.line), numbered = lineNumberify(ast.children).nodes;\n  return markers.length === 0 || numbered.length === 0 ? __spreadProps$2(__spreadValues$2({}, ast), { children: numbered }) : wrapLines(numbered, markers, options);\n}\nfunction lineNumberify(ast, context = { lineNumber: 1 }) {\n  const resultNodes = [];\n  return ast.reduce(\n    (result, node) => {\n      if (node.type === \"doctype\")\n        return result;\n      const lineStart = context.lineNumber;\n      if (node.type === \"text\") {\n        if (node.value.indexOf(`\n`) === -1)\n          return setLineInfo(node, lineStart, lineStart), result.nodes.push(node), result;\n        const lines = node.value.split(`\n`);\n        for (let i = 0; i < lines.length; i++) {\n          const lineNum = i === 0 ? context.lineNumber : ++context.lineNumber, text = {\n            type: \"text\",\n            value: i === lines.length - 1 ? lines[i] : `${lines[i]}\n`\n          }, withLineInfo = setLineInfo(text, lineNum, lineNum);\n          result.nodes.push(withLineInfo);\n        }\n        return result.lineNumber = context.lineNumber, result;\n      }\n      if (node.type === \"element\" && node.children) {\n        const processed = lineNumberify(node.children, context), firstChild = processed.nodes.find(isElementOrText), lastChild = processed.nodes.findLast(isElementOrText);\n        return setLineInfo(\n          node,\n          firstChild ? getLineStart(firstChild, lineStart) : lineStart,\n          lastChild ? getLineEnd(lastChild, lineStart) : lineStart\n        ), node.children = processed.nodes, result.lineNumber = processed.lineNumber, result.nodes.push(node), result;\n      }\n      return result.nodes.push(node), result;\n    },\n    { nodes: resultNodes, lineNumber: context.lineNumber }\n  );\n}\nfunction isElementOrText(node) {\n  return node.type === \"element\" || node.type === \"text\";\n}\nfunction getLineStart(node, fallbackLineStart = 1) {\n  return node.data && typeof node.data.lineStart == \"number\" ? node.data.lineStart : fallbackLineStart;\n}\nfunction getLineEnd(node, fallbackLineEnd = 1) {\n  return node.data && typeof node.data.lineEnd == \"number\" ? node.data.lineEnd : fallbackLineEnd;\n}\nfunction setLineInfo(node, lineStart, lineEnd) {\n  return node.data || (node.data = {}), node.data.lineStart = lineStart, node.data.lineEnd = lineEnd, node;\n}\nfunction unwrapLine(markerLine, nodes) {\n  const tree = { type: \"root\", children: nodes }, headMap = /* @__PURE__ */ new WeakMap(), lineMap = /* @__PURE__ */ new WeakMap(), tailMap = /* @__PURE__ */ new WeakMap(), cloned = [];\n  function addCopy(map, node, ancestors) {\n    cloned.push(node), ancestors.forEach((ancestor) => {\n      map.has(ancestor) || (map.set(ancestor, Object.assign({}, ancestor, { children: [] })), ancestor !== tree && cloned.push(ancestor));\n    });\n    let i = ancestors.length;\n    for (; i--; ) {\n      const ancestor = map.get(ancestors[i]);\n      if (!ancestor || !(\"children\" in ancestor))\n        continue;\n      const child = ancestors[i + 1], leaf = map.get(child) || node;\n      ancestor.children.indexOf(leaf) === -1 && ancestor.children.push(leaf);\n    }\n  }\n  (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__.visitParents)(tree, (node, ancestors) => {\n    if (!(\"children\" in node || !isElementOrText(node))) {\n      if (getLineStart(node) < markerLine) {\n        addCopy(headMap, node, ancestors);\n        return;\n      }\n      if (getLineStart(node) === markerLine) {\n        addCopy(lineMap, node, ancestors);\n        return;\n      }\n      getLineEnd(node) > markerLine && cloned.some((clone) => ancestors.includes(clone)) && addCopy(tailMap, node, ancestors);\n    }\n  });\n  const filtered = (0,unist_util_filter__WEBPACK_IMPORTED_MODULE_3__.filter)(tree, (node) => cloned.indexOf(node) === -1), getChildren = (map) => {\n    const rootNode = map.get(tree);\n    return rootNode ? ((0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__.visitParents)(rootNode, (leaf, ancestors) => {\n      if (isElementOrText(leaf) && \"children\" in leaf) {\n        setLineInfo(leaf, 0, 0);\n        return;\n      }\n      ancestors.forEach((ancestor) => {\n        setLineInfo(\n          ancestor,\n          Math.max(getLineStart(ancestor), getLineStart(leaf)),\n          Math.max(getLineEnd(ancestor), getLineEnd(leaf))\n        );\n      });\n    }), rootNode.children) : [];\n  };\n  return [\n    ...getChildren(headMap),\n    ...getChildren(lineMap),\n    ...getChildren(tailMap),\n    ...filtered ? filtered.children : []\n  ];\n}\nfunction wrapBatch(children, marker, options) {\n  const className = marker.className || \"refractor-marker\", baseData = {\n    lineStart: marker.line,\n    lineEnd: getLineEnd(children[children.length - 1]),\n    isMarker: !0\n  };\n  return {\n    type: \"element\",\n    tagName: \"div\",\n    data: marker.component ? __spreadProps$2(__spreadValues$2({}, baseData), { component: marker.component, markerProperties: options }) : baseData,\n    properties: { className },\n    children\n  };\n}\nfunction wrapLines(treeNodes, markers, options) {\n  const ast = markers.reduce(\n    (acc, marker) => unwrapLine(marker.line, acc),\n    treeNodes\n  ), wrapped = [];\n  let astIndex = 0;\n  for (let m = 0; m < markers.length; m++) {\n    const marker = markers[m];\n    for (let node = ast[astIndex]; node && getLineEnd(node) < marker.line; node = ast[++astIndex])\n      wrapped.push(node);\n    const batch = [];\n    for (let node = ast[astIndex]; node && getLineEnd(node) === marker.line; node = ast[++astIndex])\n      node.type !== \"doctype\" && batch.push(node);\n    batch.length > 0 && wrapped.push(wrapBatch(batch, marker, options));\n  }\n  for (; astIndex < ast.length; )\n    wrapped.push(ast[astIndex++]);\n  return { type: \"root\", children: wrapped };\n}\nvar __defProp$1 = Object.defineProperty, __defProps$1 = Object.defineProperties, __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b))\n      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n}, __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nfunction mapWithDepth(depth) {\n  return function(child, i) {\n    return mapChild(child, i, depth);\n  };\n}\nfunction mapChild(child, i, depth) {\n  if (child.type === \"doctype\")\n    return null;\n  if (!(\"tagName\" in child))\n    return child.value;\n  let className = \"\";\n  typeof child.properties < \"u\" && (className = Array.isArray(child.properties.className) ? child.properties.className.join(\" \") : `${child.properties.className}`);\n  const key = `fract-${depth}-${i}`, children = child.children && child.children.map(mapWithDepth(depth + 1));\n  return isReactRefractorMarkerDataWithComponent(child.data) ? (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n    child.data.component,\n    __spreadProps$1(__spreadValues$1(__spreadValues$1({ key }, child.properties), child.data.markerProperties), { className }),\n    children\n  ) : (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(child.tagName, { key, className }, children);\n}\nfunction isReactRefractorMarkerDataWithComponent(data) {\n  return typeof data == \"object\" && data !== null && \"component\" in data && \"markerProperties\" in data;\n}\nvar __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b))\n      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  return a;\n}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst DEFAULT_CLASSNAME = \"refractor\";\nfunction Refractor(props) {\n  const className = props.className || DEFAULT_CLASSNAME, langClassName = `language-${props.language}`, codeProps = { className: langClassName }, preClass = [className, langClassName].filter(Boolean).join(\" \");\n  if (props.inline && (codeProps.style = { display: \"inline\" }, codeProps.className = className), props.plainText) {\n    const code2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", __spreadProps(__spreadValues({}, codeProps), { children: props.value }));\n    return props.inline ? code2 : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pre\", { className: preClass, children: code2 });\n  }\n  let ast = refractor_core__WEBPACK_IMPORTED_MODULE_4__.refractor.highlight(props.value, props.language);\n  props.markers && props.markers.length > 0 && (ast = addMarkers(ast, { markers: props.markers }));\n  const value = ast.children.length === 0 ? props.value : ast.children.map(mapWithDepth(0)), code = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", __spreadProps(__spreadValues({}, codeProps), { children: value }));\n  return props.inline ? code : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pre\", { className: preClass, children: code });\n}\nconst registerLanguage = (lang) => refractor_core__WEBPACK_IMPORTED_MODULE_4__.refractor.register(lang), hasLanguage = (lang) => refractor_core__WEBPACK_IMPORTED_MODULE_4__.refractor.registered(lang);\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVmcmFjdG9yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBd0M7QUFDRztBQUNBO0FBQ2E7QUFDbEI7QUFDdEMsdVhBQXVYLHVEQUF1RDtBQUM5YSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdGQUFnRixlQUFlO0FBQy9GLDRGQUE0RixVQUFVLG9CQUFvQjtBQUMxSDtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQSw4REFBOEQsY0FBYyxjQUFjO0FBQzFGLEtBQUs7QUFDTDtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0VBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQix5REFBTTtBQUN6QjtBQUNBLHVCQUF1QixzRUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxlQUFlLHdEQUF3RDtBQUN2SSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0EsbUNBQW1DLHdDQUF3QztBQUMzRTtBQUNBO0FBQ0EsbUNBQW1DLDBDQUEwQztBQUM3RTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVCQUF1QjtBQUNoQztBQUNBLFdBQVc7QUFDWDtBQUNBLHVYQUF1WCx1REFBdUQ7QUFDOWEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSSwyQkFBMkI7QUFDakssdUJBQXVCLE1BQU0sR0FBRyxFQUFFO0FBQ2xDLCtEQUErRCxvREFBYTtBQUM1RTtBQUNBLHdEQUF3RCxLQUFLLHFEQUFxRCxXQUFXO0FBQzdIO0FBQ0EsTUFBTSxvREFBYSxrQkFBa0IsZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdVdBQXVXLHVEQUF1RDtBQUM5WiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esc0ZBQXNGLGVBQWUsaUJBQWlCLDBCQUEwQjtBQUNoSiwyQ0FBMkMsbUJBQW1CO0FBQzlELGtDQUFrQyxzREFBRyx3Q0FBd0MsZ0JBQWdCLHVCQUF1QjtBQUNwSCxrREFBa0Qsc0RBQUcsVUFBVSxzQ0FBc0M7QUFDckc7QUFDQSxZQUFZLHFEQUFTO0FBQ3JCLHdFQUF3RSx3QkFBd0I7QUFDaEcsb0hBQW9ILHNEQUFHLHdDQUF3QyxnQkFBZ0IsaUJBQWlCO0FBQ2hNLCtDQUErQyxzREFBRyxVQUFVLHFDQUFxQztBQUNqRztBQUNBLG1DQUFtQyxxREFBUyx5Q0FBeUMscURBQVM7QUFLNUY7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2pvaGFuL2Rldi9wZXJzb25hbC9tZXhpd2ViL25vZGVfbW9kdWxlcy9yZWFjdC1yZWZyYWN0b3IvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IHJlZnJhY3RvciB9IGZyb20gXCJyZWZyYWN0b3IvY29yZVwiO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSBcInVuaXN0LXV0aWwtZmlsdGVyXCI7XG5pbXBvcnQgeyB2aXNpdFBhcmVudHMgfSBmcm9tIFwidW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzXCI7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgX19kZWZQcm9wJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmUHJvcHMkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBfX2dldE93blByb3BEZXNjcyQyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMsIF9fZ2V0T3duUHJvcFN5bWJvbHMkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIF9faGFzT3duUHJvcCQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgX19wcm9wSXNFbnVtJDIgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBfX2RlZk5vcm1hbFByb3AkMiA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMihvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzJDIgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgX19oYXNPd25Qcm9wJDIuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMihhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMilcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkMihiKSlcbiAgICAgIF9fcHJvcElzRW51bSQyLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDIoYSwgcHJvcCwgYltwcm9wXSk7XG4gIHJldHVybiBhO1xufSwgX19zcHJlYWRQcm9wcyQyID0gKGEsIGIpID0+IF9fZGVmUHJvcHMkMihhLCBfX2dldE93blByb3BEZXNjcyQyKGIpKTtcbmZ1bmN0aW9uIGFkZE1hcmtlcnMoYXN0LCBvcHRpb25zKSB7XG4gIGNvbnN0IG1hcmtlcnMgPSBvcHRpb25zLm1hcmtlcnMubWFwKChtYXJrZXIpID0+IHR5cGVvZiBtYXJrZXIgPT0gXCJudW1iZXJcIiA/IHsgbGluZTogbWFya2VyIH0gOiBtYXJrZXIpLnNvcnQoKG5vZGVBLCBub2RlQikgPT4gbm9kZUEubGluZSAtIG5vZGVCLmxpbmUpLCBudW1iZXJlZCA9IGxpbmVOdW1iZXJpZnkoYXN0LmNoaWxkcmVuKS5ub2RlcztcbiAgcmV0dXJuIG1hcmtlcnMubGVuZ3RoID09PSAwIHx8IG51bWJlcmVkLmxlbmd0aCA9PT0gMCA/IF9fc3ByZWFkUHJvcHMkMihfX3NwcmVhZFZhbHVlcyQyKHt9LCBhc3QpLCB7IGNoaWxkcmVuOiBudW1iZXJlZCB9KSA6IHdyYXBMaW5lcyhudW1iZXJlZCwgbWFya2Vycywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBsaW5lTnVtYmVyaWZ5KGFzdCwgY29udGV4dCA9IHsgbGluZU51bWJlcjogMSB9KSB7XG4gIGNvbnN0IHJlc3VsdE5vZGVzID0gW107XG4gIHJldHVybiBhc3QucmVkdWNlKFxuICAgIChyZXN1bHQsIG5vZGUpID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiZG9jdHlwZVwiKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgY29uc3QgbGluZVN0YXJ0ID0gY29udGV4dC5saW5lTnVtYmVyO1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgaWYgKG5vZGUudmFsdWUuaW5kZXhPZihgXG5gKSA9PT0gLTEpXG4gICAgICAgICAgcmV0dXJuIHNldExpbmVJbmZvKG5vZGUsIGxpbmVTdGFydCwgbGluZVN0YXJ0KSwgcmVzdWx0Lm5vZGVzLnB1c2gobm9kZSksIHJlc3VsdDtcbiAgICAgICAgY29uc3QgbGluZXMgPSBub2RlLnZhbHVlLnNwbGl0KGBcbmApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGluZU51bSA9IGkgPT09IDAgPyBjb250ZXh0LmxpbmVOdW1iZXIgOiArK2NvbnRleHQubGluZU51bWJlciwgdGV4dCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdmFsdWU6IGkgPT09IGxpbmVzLmxlbmd0aCAtIDEgPyBsaW5lc1tpXSA6IGAke2xpbmVzW2ldfVxuYFxuICAgICAgICAgIH0sIHdpdGhMaW5lSW5mbyA9IHNldExpbmVJbmZvKHRleHQsIGxpbmVOdW0sIGxpbmVOdW0pO1xuICAgICAgICAgIHJlc3VsdC5ub2Rlcy5wdXNoKHdpdGhMaW5lSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5saW5lTnVtYmVyID0gY29udGV4dC5saW5lTnVtYmVyLCByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGxpbmVOdW1iZXJpZnkobm9kZS5jaGlsZHJlbiwgY29udGV4dCksIGZpcnN0Q2hpbGQgPSBwcm9jZXNzZWQubm9kZXMuZmluZChpc0VsZW1lbnRPclRleHQpLCBsYXN0Q2hpbGQgPSBwcm9jZXNzZWQubm9kZXMuZmluZExhc3QoaXNFbGVtZW50T3JUZXh0KTtcbiAgICAgICAgcmV0dXJuIHNldExpbmVJbmZvKFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgZmlyc3RDaGlsZCA/IGdldExpbmVTdGFydChmaXJzdENoaWxkLCBsaW5lU3RhcnQpIDogbGluZVN0YXJ0LFxuICAgICAgICAgIGxhc3RDaGlsZCA/IGdldExpbmVFbmQobGFzdENoaWxkLCBsaW5lU3RhcnQpIDogbGluZVN0YXJ0XG4gICAgICAgICksIG5vZGUuY2hpbGRyZW4gPSBwcm9jZXNzZWQubm9kZXMsIHJlc3VsdC5saW5lTnVtYmVyID0gcHJvY2Vzc2VkLmxpbmVOdW1iZXIsIHJlc3VsdC5ub2Rlcy5wdXNoKG5vZGUpLCByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0Lm5vZGVzLnB1c2gobm9kZSksIHJlc3VsdDtcbiAgICB9LFxuICAgIHsgbm9kZXM6IHJlc3VsdE5vZGVzLCBsaW5lTnVtYmVyOiBjb250ZXh0LmxpbmVOdW1iZXIgfVxuICApO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50T3JUZXh0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcInRleHRcIjtcbn1cbmZ1bmN0aW9uIGdldExpbmVTdGFydChub2RlLCBmYWxsYmFja0xpbmVTdGFydCA9IDEpIHtcbiAgcmV0dXJuIG5vZGUuZGF0YSAmJiB0eXBlb2Ygbm9kZS5kYXRhLmxpbmVTdGFydCA9PSBcIm51bWJlclwiID8gbm9kZS5kYXRhLmxpbmVTdGFydCA6IGZhbGxiYWNrTGluZVN0YXJ0O1xufVxuZnVuY3Rpb24gZ2V0TGluZUVuZChub2RlLCBmYWxsYmFja0xpbmVFbmQgPSAxKSB7XG4gIHJldHVybiBub2RlLmRhdGEgJiYgdHlwZW9mIG5vZGUuZGF0YS5saW5lRW5kID09IFwibnVtYmVyXCIgPyBub2RlLmRhdGEubGluZUVuZCA6IGZhbGxiYWNrTGluZUVuZDtcbn1cbmZ1bmN0aW9uIHNldExpbmVJbmZvKG5vZGUsIGxpbmVTdGFydCwgbGluZUVuZCkge1xuICByZXR1cm4gbm9kZS5kYXRhIHx8IChub2RlLmRhdGEgPSB7fSksIG5vZGUuZGF0YS5saW5lU3RhcnQgPSBsaW5lU3RhcnQsIG5vZGUuZGF0YS5saW5lRW5kID0gbGluZUVuZCwgbm9kZTtcbn1cbmZ1bmN0aW9uIHVud3JhcExpbmUobWFya2VyTGluZSwgbm9kZXMpIHtcbiAgY29uc3QgdHJlZSA9IHsgdHlwZTogXCJyb290XCIsIGNoaWxkcmVuOiBub2RlcyB9LCBoZWFkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGxpbmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgdGFpbE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBjbG9uZWQgPSBbXTtcbiAgZnVuY3Rpb24gYWRkQ29weShtYXAsIG5vZGUsIGFuY2VzdG9ycykge1xuICAgIGNsb25lZC5wdXNoKG5vZGUpLCBhbmNlc3RvcnMuZm9yRWFjaCgoYW5jZXN0b3IpID0+IHtcbiAgICAgIG1hcC5oYXMoYW5jZXN0b3IpIHx8IChtYXAuc2V0KGFuY2VzdG9yLCBPYmplY3QuYXNzaWduKHt9LCBhbmNlc3RvciwgeyBjaGlsZHJlbjogW10gfSkpLCBhbmNlc3RvciAhPT0gdHJlZSAmJiBjbG9uZWQucHVzaChhbmNlc3RvcikpO1xuICAgIH0pO1xuICAgIGxldCBpID0gYW5jZXN0b3JzLmxlbmd0aDtcbiAgICBmb3IgKDsgaS0tOyApIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9yID0gbWFwLmdldChhbmNlc3RvcnNbaV0pO1xuICAgICAgaWYgKCFhbmNlc3RvciB8fCAhKFwiY2hpbGRyZW5cIiBpbiBhbmNlc3RvcikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgY2hpbGQgPSBhbmNlc3RvcnNbaSArIDFdLCBsZWFmID0gbWFwLmdldChjaGlsZCkgfHwgbm9kZTtcbiAgICAgIGFuY2VzdG9yLmNoaWxkcmVuLmluZGV4T2YobGVhZikgPT09IC0xICYmIGFuY2VzdG9yLmNoaWxkcmVuLnB1c2gobGVhZik7XG4gICAgfVxuICB9XG4gIHZpc2l0UGFyZW50cyh0cmVlLCAobm9kZSwgYW5jZXN0b3JzKSA9PiB7XG4gICAgaWYgKCEoXCJjaGlsZHJlblwiIGluIG5vZGUgfHwgIWlzRWxlbWVudE9yVGV4dChub2RlKSkpIHtcbiAgICAgIGlmIChnZXRMaW5lU3RhcnQobm9kZSkgPCBtYXJrZXJMaW5lKSB7XG4gICAgICAgIGFkZENvcHkoaGVhZE1hcCwgbm9kZSwgYW5jZXN0b3JzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGdldExpbmVTdGFydChub2RlKSA9PT0gbWFya2VyTGluZSkge1xuICAgICAgICBhZGRDb3B5KGxpbmVNYXAsIG5vZGUsIGFuY2VzdG9ycyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGdldExpbmVFbmQobm9kZSkgPiBtYXJrZXJMaW5lICYmIGNsb25lZC5zb21lKChjbG9uZSkgPT4gYW5jZXN0b3JzLmluY2x1ZGVzKGNsb25lKSkgJiYgYWRkQ29weSh0YWlsTWFwLCBub2RlLCBhbmNlc3RvcnMpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGZpbHRlcmVkID0gZmlsdGVyKHRyZWUsIChub2RlKSA9PiBjbG9uZWQuaW5kZXhPZihub2RlKSA9PT0gLTEpLCBnZXRDaGlsZHJlbiA9IChtYXApID0+IHtcbiAgICBjb25zdCByb290Tm9kZSA9IG1hcC5nZXQodHJlZSk7XG4gICAgcmV0dXJuIHJvb3ROb2RlID8gKHZpc2l0UGFyZW50cyhyb290Tm9kZSwgKGxlYWYsIGFuY2VzdG9ycykgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudE9yVGV4dChsZWFmKSAmJiBcImNoaWxkcmVuXCIgaW4gbGVhZikge1xuICAgICAgICBzZXRMaW5lSW5mbyhsZWFmLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3JzLmZvckVhY2goKGFuY2VzdG9yKSA9PiB7XG4gICAgICAgIHNldExpbmVJbmZvKFxuICAgICAgICAgIGFuY2VzdG9yLFxuICAgICAgICAgIE1hdGgubWF4KGdldExpbmVTdGFydChhbmNlc3RvciksIGdldExpbmVTdGFydChsZWFmKSksXG4gICAgICAgICAgTWF0aC5tYXgoZ2V0TGluZUVuZChhbmNlc3RvciksIGdldExpbmVFbmQobGVhZikpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KSwgcm9vdE5vZGUuY2hpbGRyZW4pIDogW107XG4gIH07XG4gIHJldHVybiBbXG4gICAgLi4uZ2V0Q2hpbGRyZW4oaGVhZE1hcCksXG4gICAgLi4uZ2V0Q2hpbGRyZW4obGluZU1hcCksXG4gICAgLi4uZ2V0Q2hpbGRyZW4odGFpbE1hcCksXG4gICAgLi4uZmlsdGVyZWQgPyBmaWx0ZXJlZC5jaGlsZHJlbiA6IFtdXG4gIF07XG59XG5mdW5jdGlvbiB3cmFwQmF0Y2goY2hpbGRyZW4sIG1hcmtlciwgb3B0aW9ucykge1xuICBjb25zdCBjbGFzc05hbWUgPSBtYXJrZXIuY2xhc3NOYW1lIHx8IFwicmVmcmFjdG9yLW1hcmtlclwiLCBiYXNlRGF0YSA9IHtcbiAgICBsaW5lU3RhcnQ6IG1hcmtlci5saW5lLFxuICAgIGxpbmVFbmQ6IGdldExpbmVFbmQoY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pLFxuICAgIGlzTWFya2VyOiAhMFxuICB9O1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwiZGl2XCIsXG4gICAgZGF0YTogbWFya2VyLmNvbXBvbmVudCA/IF9fc3ByZWFkUHJvcHMkMihfX3NwcmVhZFZhbHVlcyQyKHt9LCBiYXNlRGF0YSksIHsgY29tcG9uZW50OiBtYXJrZXIuY29tcG9uZW50LCBtYXJrZXJQcm9wZXJ0aWVzOiBvcHRpb25zIH0pIDogYmFzZURhdGEsXG4gICAgcHJvcGVydGllczogeyBjbGFzc05hbWUgfSxcbiAgICBjaGlsZHJlblxuICB9O1xufVxuZnVuY3Rpb24gd3JhcExpbmVzKHRyZWVOb2RlcywgbWFya2Vycywgb3B0aW9ucykge1xuICBjb25zdCBhc3QgPSBtYXJrZXJzLnJlZHVjZShcbiAgICAoYWNjLCBtYXJrZXIpID0+IHVud3JhcExpbmUobWFya2VyLmxpbmUsIGFjYyksXG4gICAgdHJlZU5vZGVzXG4gICksIHdyYXBwZWQgPSBbXTtcbiAgbGV0IGFzdEluZGV4ID0gMDtcbiAgZm9yIChsZXQgbSA9IDA7IG0gPCBtYXJrZXJzLmxlbmd0aDsgbSsrKSB7XG4gICAgY29uc3QgbWFya2VyID0gbWFya2Vyc1ttXTtcbiAgICBmb3IgKGxldCBub2RlID0gYXN0W2FzdEluZGV4XTsgbm9kZSAmJiBnZXRMaW5lRW5kKG5vZGUpIDwgbWFya2VyLmxpbmU7IG5vZGUgPSBhc3RbKythc3RJbmRleF0pXG4gICAgICB3cmFwcGVkLnB1c2gobm9kZSk7XG4gICAgY29uc3QgYmF0Y2ggPSBbXTtcbiAgICBmb3IgKGxldCBub2RlID0gYXN0W2FzdEluZGV4XTsgbm9kZSAmJiBnZXRMaW5lRW5kKG5vZGUpID09PSBtYXJrZXIubGluZTsgbm9kZSA9IGFzdFsrK2FzdEluZGV4XSlcbiAgICAgIG5vZGUudHlwZSAhPT0gXCJkb2N0eXBlXCIgJiYgYmF0Y2gucHVzaChub2RlKTtcbiAgICBiYXRjaC5sZW5ndGggPiAwICYmIHdyYXBwZWQucHVzaCh3cmFwQmF0Y2goYmF0Y2gsIG1hcmtlciwgb3B0aW9ucykpO1xuICB9XG4gIGZvciAoOyBhc3RJbmRleCA8IGFzdC5sZW5ndGg7IClcbiAgICB3cmFwcGVkLnB1c2goYXN0W2FzdEluZGV4KytdKTtcbiAgcmV0dXJuIHsgdHlwZTogXCJyb290XCIsIGNoaWxkcmVuOiB3cmFwcGVkIH07XG59XG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmUHJvcHMkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBfX2dldE93blByb3BEZXNjcyQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMsIF9fZ2V0T3duUHJvcFN5bWJvbHMkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIF9faGFzT3duUHJvcCQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgX19wcm9wSXNFbnVtJDEgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzJDEgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgX19oYXNPd25Qcm9wJDEuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMShhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMSlcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkMShiKSlcbiAgICAgIF9fcHJvcElzRW51bSQxLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDEoYSwgcHJvcCwgYltwcm9wXSk7XG4gIHJldHVybiBhO1xufSwgX19zcHJlYWRQcm9wcyQxID0gKGEsIGIpID0+IF9fZGVmUHJvcHMkMShhLCBfX2dldE93blByb3BEZXNjcyQxKGIpKTtcbmZ1bmN0aW9uIG1hcFdpdGhEZXB0aChkZXB0aCkge1xuICByZXR1cm4gZnVuY3Rpb24oY2hpbGQsIGkpIHtcbiAgICByZXR1cm4gbWFwQ2hpbGQoY2hpbGQsIGksIGRlcHRoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1hcENoaWxkKGNoaWxkLCBpLCBkZXB0aCkge1xuICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkb2N0eXBlXCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICghKFwidGFnTmFtZVwiIGluIGNoaWxkKSlcbiAgICByZXR1cm4gY2hpbGQudmFsdWU7XG4gIGxldCBjbGFzc05hbWUgPSBcIlwiO1xuICB0eXBlb2YgY2hpbGQucHJvcGVydGllcyA8IFwidVwiICYmIChjbGFzc05hbWUgPSBBcnJheS5pc0FycmF5KGNoaWxkLnByb3BlcnRpZXMuY2xhc3NOYW1lKSA/IGNoaWxkLnByb3BlcnRpZXMuY2xhc3NOYW1lLmpvaW4oXCIgXCIpIDogYCR7Y2hpbGQucHJvcGVydGllcy5jbGFzc05hbWV9YCk7XG4gIGNvbnN0IGtleSA9IGBmcmFjdC0ke2RlcHRofS0ke2l9YCwgY2hpbGRyZW4gPSBjaGlsZC5jaGlsZHJlbiAmJiBjaGlsZC5jaGlsZHJlbi5tYXAobWFwV2l0aERlcHRoKGRlcHRoICsgMSkpO1xuICByZXR1cm4gaXNSZWFjdFJlZnJhY3Rvck1hcmtlckRhdGFXaXRoQ29tcG9uZW50KGNoaWxkLmRhdGEpID8gY3JlYXRlRWxlbWVudChcbiAgICBjaGlsZC5kYXRhLmNvbXBvbmVudCxcbiAgICBfX3NwcmVhZFByb3BzJDEoX19zcHJlYWRWYWx1ZXMkMShfX3NwcmVhZFZhbHVlcyQxKHsga2V5IH0sIGNoaWxkLnByb3BlcnRpZXMpLCBjaGlsZC5kYXRhLm1hcmtlclByb3BlcnRpZXMpLCB7IGNsYXNzTmFtZSB9KSxcbiAgICBjaGlsZHJlblxuICApIDogY3JlYXRlRWxlbWVudChjaGlsZC50YWdOYW1lLCB7IGtleSwgY2xhc3NOYW1lIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RSZWZyYWN0b3JNYXJrZXJEYXRhV2l0aENvbXBvbmVudChkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PSBcIm9iamVjdFwiICYmIGRhdGEgIT09IG51bGwgJiYgXCJjb21wb25lbnRcIiBpbiBkYXRhICYmIFwibWFya2VyUHJvcGVydGllc1wiIGluIGRhdGE7XG59XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMsIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpXG4gICAgICBfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIHJldHVybiBhO1xufSwgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IERFRkFVTFRfQ0xBU1NOQU1FID0gXCJyZWZyYWN0b3JcIjtcbmZ1bmN0aW9uIFJlZnJhY3Rvcihwcm9wcykge1xuICBjb25zdCBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUgfHwgREVGQVVMVF9DTEFTU05BTUUsIGxhbmdDbGFzc05hbWUgPSBgbGFuZ3VhZ2UtJHtwcm9wcy5sYW5ndWFnZX1gLCBjb2RlUHJvcHMgPSB7IGNsYXNzTmFtZTogbGFuZ0NsYXNzTmFtZSB9LCBwcmVDbGFzcyA9IFtjbGFzc05hbWUsIGxhbmdDbGFzc05hbWVdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgaWYgKHByb3BzLmlubGluZSAmJiAoY29kZVByb3BzLnN0eWxlID0geyBkaXNwbGF5OiBcImlubGluZVwiIH0sIGNvZGVQcm9wcy5jbGFzc05hbWUgPSBjbGFzc05hbWUpLCBwcm9wcy5wbGFpblRleHQpIHtcbiAgICBjb25zdCBjb2RlMiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJjb2RlXCIsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGNvZGVQcm9wcyksIHsgY2hpbGRyZW46IHByb3BzLnZhbHVlIH0pKTtcbiAgICByZXR1cm4gcHJvcHMuaW5saW5lID8gY29kZTIgOiAvKiBAX19QVVJFX18gKi8ganN4KFwicHJlXCIsIHsgY2xhc3NOYW1lOiBwcmVDbGFzcywgY2hpbGRyZW46IGNvZGUyIH0pO1xuICB9XG4gIGxldCBhc3QgPSByZWZyYWN0b3IuaGlnaGxpZ2h0KHByb3BzLnZhbHVlLCBwcm9wcy5sYW5ndWFnZSk7XG4gIHByb3BzLm1hcmtlcnMgJiYgcHJvcHMubWFya2Vycy5sZW5ndGggPiAwICYmIChhc3QgPSBhZGRNYXJrZXJzKGFzdCwgeyBtYXJrZXJzOiBwcm9wcy5tYXJrZXJzIH0pKTtcbiAgY29uc3QgdmFsdWUgPSBhc3QuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gcHJvcHMudmFsdWUgOiBhc3QuY2hpbGRyZW4ubWFwKG1hcFdpdGhEZXB0aCgwKSksIGNvZGUgPSAvKiBAX19QVVJFX18gKi8ganN4KFwiY29kZVwiLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBjb2RlUHJvcHMpLCB7IGNoaWxkcmVuOiB2YWx1ZSB9KSk7XG4gIHJldHVybiBwcm9wcy5pbmxpbmUgPyBjb2RlIDogLyogQF9fUFVSRV9fICovIGpzeChcInByZVwiLCB7IGNsYXNzTmFtZTogcHJlQ2xhc3MsIGNoaWxkcmVuOiBjb2RlIH0pO1xufVxuY29uc3QgcmVnaXN0ZXJMYW5ndWFnZSA9IChsYW5nKSA9PiByZWZyYWN0b3IucmVnaXN0ZXIobGFuZyksIGhhc0xhbmd1YWdlID0gKGxhbmcpID0+IHJlZnJhY3Rvci5yZWdpc3RlcmVkKGxhbmcpO1xuZXhwb3J0IHtcbiAgUmVmcmFjdG9yLFxuICBoYXNMYW5ndWFnZSxcbiAgcmVnaXN0ZXJMYW5ndWFnZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-refractor/dist/index.js\n");

/***/ })

};
;