"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.mjs":
/*!*****************************************!*\
  !*** ./node_modules/groq-js/dist/1.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   createReferenceTypeNode: () => (/* binding */ createReferenceTypeNode),\n/* harmony export */   evaluate: () => (/* binding */ evaluateQuery),\n/* harmony export */   evaluateSync: () => (/* binding */ evaluateQuerySync),\n/* harmony export */   isSelectorNested: () => (/* binding */ isSelectorNested),\n/* harmony export */   isSelectorNode: () => (/* binding */ isSelectorNode),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   toJS: () => (/* binding */ toJS),\n/* harmony export */   typeEvaluate: () => (/* binding */ typeEvaluate)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n\nfunction escapeRegExp(string2) {\n  return string2.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n  const re = [];\n  for (const part of pattern.split(\".\"))\n    part === \"*\" ? re.push(\"[^.]+\") : part === \"**\" ? re.push(\".*\") : re.push(escapeRegExp(part));\n  return new RegExp(`^${re.join(\".\")}$`);\n}\nclass Path {\n  pattern;\n  patternRe;\n  constructor(pattern) {\n    this.pattern = pattern, this.patternRe = pathRegExp(pattern);\n  }\n  matches(str) {\n    return this.patternRe.test(str);\n  }\n  toJSON() {\n    return this.pattern;\n  }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n  return RFC3339_REGEX.test(str) ? new Date(str) : null;\n}\nfunction formatRFC3339(d) {\n  const year = addLeadingZero(d.getUTCFullYear(), 4), month = addLeadingZero(d.getUTCMonth() + 1, 2), day = addLeadingZero(d.getUTCDate(), 2), hour = addLeadingZero(d.getUTCHours(), 2), minute = addLeadingZero(d.getUTCMinutes(), 2), second = addLeadingZero(d.getUTCSeconds(), 2);\n  let fractionalSecond = \"\";\n  const millis = d.getMilliseconds();\n  return millis != 0 && (fractionalSecond = `.${addLeadingZero(millis, 3)}`), `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;\n}\nfunction addLeadingZero(num, targetLength) {\n  let str = num.toString();\n  for (; str.length < targetLength; )\n    str = `0${str}`;\n  return str;\n}\nclass StaticValue {\n  data;\n  type;\n  constructor(data, type) {\n    this.data = data, this.type = type;\n  }\n  isArray() {\n    return this.type === \"array\";\n  }\n  // eslint-disable-next-line require-await\n  async get() {\n    return this.data;\n  }\n  asStatic() {\n    return this;\n  }\n  [Symbol.asyncIterator]() {\n    if (Array.isArray(this.data))\n      return function* (data) {\n        for (const element of data)\n          yield fromJS(element);\n      }(this.data);\n    throw new Error(`Cannot iterate over: ${this.type}`);\n  }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\"), TRUE_VALUE = new StaticValue(!0, \"boolean\"), FALSE_VALUE = new StaticValue(!1, \"boolean\");\nclass DateTime {\n  date;\n  constructor(date) {\n    this.date = date;\n  }\n  static parseToValue(str) {\n    const date = parseRFC3339(str);\n    return date ? new StaticValue(new DateTime(date), \"datetime\") : NULL_VALUE;\n  }\n  equals(other) {\n    return this.date.getTime() == other.date.getTime();\n  }\n  add(secs) {\n    const copy = new Date(this.date.getTime());\n    return copy.setTime(copy.getTime() + secs * 1e3), new DateTime(copy);\n  }\n  difference(other) {\n    return (this.date.getTime() - other.date.getTime()) / 1e3;\n  }\n  compareTo(other) {\n    return this.date.getTime() - other.date.getTime();\n  }\n  toString() {\n    return formatRFC3339(this.date);\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction fromNumber(num) {\n  return Number.isFinite(num) ? new StaticValue(num, \"number\") : NULL_VALUE;\n}\nfunction fromString(str) {\n  return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n  return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n  return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n  return obj && typeof obj.next == \"function\";\n}\nfunction fromArray(val) {\n  return new StaticValue(val, \"array\");\n}\nfunction fromJS(val) {\n  return isIterator(val) ? new StreamValue(async function* () {\n    for await (const value of val)\n      yield fromJS(value);\n  }) : val == null ? NULL_VALUE : new StaticValue(val, getType(val));\n}\nfunction toJS(val) {\n  const normalized = maybeNormalize(val.data);\n  return normalized === void 0 ? val.data : normalized;\n}\nfunction maybeNormalize(data) {\n  if (!(data === null || typeof data > \"u\")) {\n    if (Array.isArray(data)) {\n      let result;\n      for (let i = 0; i < data.length; i++) {\n        let normalized = maybeNormalize(data[i]);\n        normalized !== void 0 && result === void 0 && (result = data.slice(0, i)), result !== void 0 && (normalized === void 0 && (normalized = data[i]), result.push(normalized));\n      }\n      return result;\n    }\n    if (typeof data == \"object\") {\n      if (\"toJSON\" in data && typeof data.toJSON == \"function\")\n        return data.toJSON();\n      const entries = Object.entries(data);\n      let result;\n      for (let i = 0; i < entries.length; i++) {\n        const [key, value] = entries[i];\n        let normalized = maybeNormalize(value);\n        normalized !== void 0 && result === void 0 && (result = Object.fromEntries(entries.slice(0, i))), result !== void 0 && (normalized === void 0 && (normalized = value), result[key] = normalized);\n      }\n      return result;\n    }\n  }\n}\nfunction getType(data) {\n  return data === null || typeof data > \"u\" ? \"null\" : Array.isArray(data) ? \"array\" : data instanceof Path ? \"path\" : data instanceof DateTime ? \"datetime\" : typeof data;\n}\nclass StreamValue {\n  type = \"stream\";\n  generator;\n  ticker;\n  isDone;\n  data;\n  constructor(generator) {\n    this.generator = generator, this.ticker = null, this.isDone = !1, this.data = [];\n  }\n  // eslint-disable-next-line class-methods-use-this\n  isArray() {\n    return !0;\n  }\n  async get() {\n    const result = [];\n    for await (const value of this)\n      result.push(await value.get());\n    return result;\n  }\n  async asStatic() {\n    return new StaticValue(await this.get(), \"array\");\n  }\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    for (; ; ) {\n      for (; i < this.data.length; i++)\n        yield this.data[i];\n      if (this.isDone)\n        return;\n      await this._nextTick();\n    }\n  }\n  _nextTick() {\n    if (this.ticker)\n      return this.ticker;\n    let currentResolver, currentRejector;\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve, reject) => {\n        currentResolver = resolve, currentRejector = reject;\n      });\n    }, tick = () => {\n      currentResolver(), setupTicker();\n    }, fetch = async () => {\n      try {\n        for await (const value of this.generator())\n          this.data.push(value), tick();\n        this.isDone = !0, tick();\n      } catch (error) {\n        currentRejector(error);\n      }\n    };\n    return setupTicker(), fetch(), this.ticker;\n  }\n}\nfunction isEqual(a, b) {\n  return a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\" ? a.data === b.data : a.type === \"datetime\" && b.type === \"datetime\" ? a.data.equals(b.data) : !1;\n}\nfunction deepEqual(a, b) {\n  if (a === null || b === null) return a === b;\n  const typeOfA = typeof a, typeOfB = typeof b;\n  if (typeOfA === \"undefined\" && typeOfB === \"undefined\") return !0;\n  if (typeOfA === \"function\" && typeOfB === \"function\") return a === b;\n  if (typeOfA === \"object\" && typeOfB === \"object\") {\n    const keysOfA = Object.keys(a), keysOfB = Object.keys(b);\n    if (keysOfA.length !== keysOfB.length) return !1;\n    for (const key of keysOfA)\n      if (!deepEqual(a[key], b[key])) return !1;\n    return !0;\n  }\n  return a === b;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nfunction matchText(tokens, patterns) {\n  return tokens.length === 0 || patterns.length === 0 ? !1 : patterns.every((pattern) => pattern(tokens));\n}\nfunction matchTokenize(text2) {\n  return text2.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text2) {\n  return matchPatternRegex(text2).map((re) => (tokens) => tokens.some((token) => re.test(token)));\n}\nfunction matchPatternRegex(text2) {\n  return (text2.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || []).map(\n    (term) => new RegExp(`^${term.slice(0, 1024).replace(/\\*/g, \".*\")}$`, \"i\")\n  );\n}\nfunction gatherText(value, flatMap2) {\n  if (value.type === \"string\")\n    return { parts: flatMap2(value.data), success: !0 };\n  if (value.type === \"array\") {\n    let success = !0;\n    const parts = [];\n    for (const part of value.data)\n      typeof part == \"string\" ? parts.push(...flatMap2(part)) : success = !1;\n    return { parts, success };\n  }\n  return value.type === \"stream\" ? (async () => {\n    let success = !0;\n    const parts = [];\n    for await (const part of value)\n      part.type === \"string\" ? parts.push(...flatMap2(part.data)) : success = !1;\n    return { parts, success };\n  })() : { parts: [], success: !1 };\n}\nconst TYPE_ORDER = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4\n};\nfunction partialCompare(a, b) {\n  const aType = getType(a), bType = getType(b);\n  if (aType !== bType)\n    return null;\n  switch (aType) {\n    case \"number\":\n    case \"boolean\":\n      return a - b;\n    case \"string\":\n      return a < b ? -1 : a > b ? 1 : 0;\n    case \"datetime\":\n      return a.compareTo(b);\n    default:\n      return null;\n  }\n}\nfunction totalCompare(a, b) {\n  const aType = getType(a), bType = getType(b), aTypeOrder = TYPE_ORDER[aType] || 100, bTypeOrder = TYPE_ORDER[bType] || 100;\n  if (aTypeOrder !== bTypeOrder)\n    return aTypeOrder - bTypeOrder;\n  let result = partialCompare(a, b);\n  return result === null && (result = 0), result;\n}\nconst operators = {\n  \"==\": function(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"!=\": function(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n  },\n  \">\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result > 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \">=\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<=\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  // eslint-disable-next-line func-name-matching\n  in: function(left, right) {\n    if (right.type === \"path\")\n      return left.type !== \"string\" ? NULL_VALUE : right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n    if (right.type === \"array\") {\n      for (const b of right.data)\n        if (isEqual(left, fromJS(b)))\n          return TRUE_VALUE;\n      return FALSE_VALUE;\n    }\n    return right.type === \"stream\" ? (async () => {\n      for await (const b of right)\n        if (isEqual(left, b))\n          return TRUE_VALUE;\n      return FALSE_VALUE;\n    })() : NULL_VALUE;\n  },\n  match: function(left, right) {\n    const tokens = gatherText(left, (part) => matchTokenize(part)), patterns = gatherText(right, (part) => matchAnalyzePattern(part)), process = (tokens2, patterns2) => patterns2.success && matchText(tokens2.parts, patterns2.parts) ? TRUE_VALUE : FALSE_VALUE;\n    return \"then\" in tokens || \"then\" in patterns ? (async () => process(await tokens, await patterns))() : process(tokens, patterns);\n  },\n  \"+\": function(left, right) {\n    return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data + right.data) : left.type === \"string\" && right.type === \"string\" ? fromString(left.data + right.data) : left.type === \"object\" && right.type === \"object\" ? fromJS({ ...left.data, ...right.data }) : left.type === \"array\" && right.type === \"array\" ? fromJS(left.data.concat(right.data)) : left.isArray() && right.isArray() ? new StreamValue(async function* () {\n      for await (const val of left)\n        yield val;\n      for await (const val of right)\n        yield val;\n    }) : NULL_VALUE;\n  },\n  \"-\": function(left, right) {\n    return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(-right.data)) : left.type === \"datetime\" && right.type === \"datetime\" ? fromNumber(left.data.difference(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data - right.data) : NULL_VALUE;\n  },\n  \"*\": numericOperator((a, b) => a * b),\n  \"/\": numericOperator((a, b) => a / b),\n  \"%\": numericOperator((a, b) => a % b),\n  \"**\": numericOperator((a, b) => Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n  return function(left, right) {\n    if (left.type === \"number\" && right.type === \"number\") {\n      const result = impl(left.data, right.data);\n      return fromNumber(result);\n    }\n    return NULL_VALUE;\n  };\n}\nlet Scope$1 = class Scope {\n  params;\n  source;\n  value;\n  parent;\n  context;\n  isHidden = !1;\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(params, source, value, context, parent) {\n    this.params = params, this.source = source, this.value = value, this.context = context, this.parent = parent;\n  }\n  createNested(value) {\n    return this.isHidden ? new Scope(this.params, this.source, value, this.context, this.parent) : new Scope(this.params, this.source, value, this.context, this);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    return result.isHidden = !0, result;\n  }\n};\nfunction evaluate(node, scope) {\n  return executeAsync(node, scope);\n}\nfunction executeSync(node, scope) {\n  return EXECUTORS[node.type].executeSync(node, scope);\n}\nfunction executeAsync(node, scope) {\n  return EXECUTORS[node.type].executeAsync(node, scope);\n}\nfunction asyncOnlyExecutor(executeAsync2) {\n  return {\n    executeSync() {\n      throw new Error(\"executeSync not supported\");\n    },\n    executeAsync: executeAsync2\n  };\n}\nfunction constantExecutor(fn) {\n  return {\n    executeSync(node, scope) {\n      const value = fn(node, scope);\n      if (value.type === \"stream\") throw new Error(\"Stream encountered in evaluateSync\");\n      return value;\n    },\n    async executeAsync(node, scope) {\n      return fn(node, scope);\n    }\n  };\n}\nfunction mappedExecutor(map2, reduce) {\n  return {\n    executeSync(node, scope) {\n      const values = map2(node).map((node2) => executeSync(node2, scope)), value = reduce(node, ...values);\n      if (value.type === \"stream\")\n        throw new Error(\"Stream/iterator not supported in synchronous mode\");\n      return value;\n    },\n    async executeAsync(node, scope) {\n      const nodes = map2(node), values = await Promise.all(\n        nodes.map((node2) => executeAsync(node2, scope).then((value) => value.asStatic()))\n      );\n      return reduce(node, ...values);\n    }\n  };\n}\nconst STOP_ITERATOR = Symbol();\nfunction arrayReducerExecutor(map2, init, reduce, wrap) {\n  return {\n    executeSync(node, scope) {\n      const { array: arrayNode, args: argNodes = [] } = map2(node), arr = executeSync(arrayNode, scope);\n      if (arr.type !== \"array\") return NULL_VALUE;\n      const args = argNodes.map((node2) => executeSync(node2, scope));\n      let state = init(node, ...args);\n      for (const item of arr.data) {\n        const result = reduce(node, state, item, ...args);\n        if (result === STOP_ITERATOR) return NULL_VALUE;\n        state = result;\n      }\n      return wrap(state);\n    },\n    async executeAsync(node, scope) {\n      const { array: arrayNode, args: argNodes = [] } = map2(node), arr = await executeAsync(arrayNode, scope);\n      if (arr.type !== \"array\" && arr.type !== \"stream\") return NULL_VALUE;\n      const args = await Promise.all(\n        argNodes.map((node2) => executeAsync(node2, scope).then((v) => v.asStatic()))\n      );\n      let state = init(node, ...args);\n      if (arr.type === \"stream\")\n        for await (const item of arr) {\n          const result = reduce(node, state, await item.get(), ...args);\n          if (result === STOP_ITERATOR) return NULL_VALUE;\n          state = result;\n        }\n      else\n        for (const item of arr.data) {\n          const result = reduce(node, state, item, ...args);\n          if (result === STOP_ITERATOR) return NULL_VALUE;\n          state = result;\n        }\n      return wrap(state);\n    }\n  };\n}\nfunction arrayExecutor(map2, reduce, { hidden = !1 } = {}) {\n  return {\n    executeSync(node, scope) {\n      const mapping = map2(node), arr = executeSync(mapping.array, scope);\n      if (arr.type !== \"array\") return NULL_VALUE;\n      const result = [];\n      for (const item of arr.data) {\n        let inner;\n        if (mapping.inner) {\n          const newScope = hidden ? scope.createHidden(fromJS(item)) : scope.createNested(fromJS(item));\n          inner = executeSync(mapping.inner, newScope).data;\n        }\n        for (const entry of reduce(node, item, inner, mapping.state))\n          result.push(entry);\n      }\n      return fromArray(result);\n    },\n    async executeAsync(node, scope) {\n      const mapping = map2(node), arr = await executeAsync(mapping.array, scope);\n      return arr.isArray() ? new StreamValue(async function* () {\n        for await (const item of arr) {\n          let inner;\n          if (mapping.inner) {\n            const newScope = hidden ? scope.createHidden(item) : scope.createNested(item);\n            inner = await (await executeAsync(mapping.inner, newScope)).get();\n          }\n          for (const entry of reduce(node, await item.get(), inner, mapping.state))\n            yield fromJS(entry);\n        }\n      }) : NULL_VALUE;\n    }\n  };\n}\nconst EXECUTORS = {\n  This: constantExecutor((_, scope) => scope.value),\n  SelectorNested: constantExecutor(() => {\n    throw new Error(\"Unexpected node type: SelectorNested\");\n  }),\n  SelectorFuncCall: constantExecutor(() => {\n    throw new Error(\"Unexpected node type: SelectorFuncCall\");\n  }),\n  Everything: constantExecutor((_, scope) => scope.source),\n  Parameter: constantExecutor(({ name }, scope) => fromJS(scope.params[name])),\n  Context: constantExecutor(({ key }, scope) => {\n    if (key === \"before\" || key === \"after\")\n      return scope.context[key] || NULL_VALUE;\n    throw new Error(`unknown context key: ${key}`);\n  }),\n  Parent: constantExecutor(({ n }, scope) => {\n    let current = scope;\n    for (let i = 0; i < n; i++) {\n      if (!current.parent)\n        return NULL_VALUE;\n      current = current.parent;\n    }\n    return current.value;\n  }),\n  OpCall: {\n    async executeAsync({ op, left, right }, scope) {\n      const func = operators[op];\n      if (!func)\n        throw new Error(`Unknown operator: ${op}`);\n      const leftValue = await executeAsync(left, scope), rightValue = await executeAsync(right, scope);\n      return func(leftValue, rightValue);\n    },\n    executeSync({ op, left, right }, scope) {\n      const func = operators[op];\n      if (!func)\n        throw new Error(`Unknown operator: ${op}`);\n      const leftValue = executeSync(left, scope), rightValue = executeSync(right, scope), result = func(leftValue, rightValue);\n      if (\"then\" in result || result.type === \"stream\")\n        throw new Error(`Operator ${op} not possible in evaluteSync`);\n      return result;\n    }\n  },\n  Select: {\n    executeSync({ alternatives, fallback }, scope) {\n      for (const alt of alternatives) {\n        const altCond = executeSync(alt.condition, scope);\n        if (altCond.type === \"boolean\" && altCond.data === !0)\n          return executeSync(alt.value, scope);\n      }\n      return fallback ? executeSync(fallback, scope) : NULL_VALUE;\n    },\n    async executeAsync({ alternatives, fallback }, scope) {\n      for (const alt of alternatives) {\n        const altCond = await executeAsync(alt.condition, scope);\n        if (altCond.type === \"boolean\" && altCond.data === !0)\n          return executeAsync(alt.value, scope);\n      }\n      return fallback ? executeAsync(fallback, scope) : NULL_VALUE;\n    }\n  },\n  InRange: mappedExecutor(\n    ({ base, left, right }) => [base, left, right],\n    ({ isInclusive }, value, leftValue, rightValue) => {\n      const leftCmp = partialCompare(value.data, leftValue.data);\n      if (leftCmp === null)\n        return NULL_VALUE;\n      const rightCmp = partialCompare(value.data, rightValue.data);\n      return rightCmp === null ? NULL_VALUE : isInclusive ? leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE : leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n    }\n  ),\n  Filter: arrayExecutor(\n    ({ base, expr }) => ({ array: base, inner: expr }),\n    function* (_, elem, inner) {\n      inner === !0 && (yield elem);\n    }\n  ),\n  Projection: {\n    executeSync({ base, expr }, scope) {\n      const baseValue = executeSync(base, scope);\n      if (baseValue.type !== \"object\")\n        return NULL_VALUE;\n      const newScope = scope.createNested(baseValue);\n      return executeSync(expr, newScope);\n    },\n    async executeAsync({ base, expr }, scope) {\n      const baseValue = await executeAsync(base, scope);\n      if (baseValue.type !== \"object\")\n        return NULL_VALUE;\n      const newScope = scope.createNested(baseValue);\n      return executeAsync(expr, newScope);\n    }\n  },\n  FuncCall: {\n    executeAsync({ func, args }, scope) {\n      return func.executeAsync(args, scope);\n    },\n    executeSync({ func, args }, scope) {\n      return func.executeSync(args, scope);\n    }\n  },\n  PipeFuncCall: {\n    async executeAsync({ func, base, args }, scope) {\n      const baseValue = await executeAsync(base, scope);\n      return baseValue.type !== \"stream\" && baseValue.type !== \"array\" ? NULL_VALUE : func.executeAsync({ base: baseValue, args }, scope);\n    },\n    executeSync({ func, base, args }, scope) {\n      const baseValue = executeSync(base, scope);\n      return baseValue.type !== \"array\" ? NULL_VALUE : func.executeSync({ base: baseValue, args }, scope);\n    }\n  },\n  AccessAttribute: mappedExecutor(\n    ({ base }) => [base || { type: \"This\" }],\n    ({ name }, value) => value.type === \"object\" && value.data.hasOwnProperty(name) ? fromJS(value.data[name]) : NULL_VALUE\n  ),\n  AccessElement: mappedExecutor(\n    ({ base }) => [base],\n    ({ index }, baseValue) => {\n      if (baseValue.type !== \"array\") return NULL_VALUE;\n      const data = baseValue.data, finalIndex = index < 0 ? index + data.length : index;\n      return fromJS(data[finalIndex]);\n    }\n  ),\n  Slice: mappedExecutor(\n    ({ base }) => [base],\n    ({ left, right, isInclusive }, baseValue) => {\n      if (baseValue.type !== \"array\")\n        return NULL_VALUE;\n      const array2 = baseValue.data;\n      let leftIdx = left, rightIdx = right;\n      return leftIdx < 0 && (leftIdx = array2.length + leftIdx), rightIdx < 0 && (rightIdx = array2.length + rightIdx), isInclusive && rightIdx++, leftIdx < 0 && (leftIdx = 0), rightIdx < 0 && (rightIdx = 0), fromArray(array2.slice(leftIdx, rightIdx));\n    }\n  ),\n  Deref: {\n    executeSync({ base }, scope) {\n      const value = executeSync(base, scope);\n      if (value.type !== \"object\")\n        return NULL_VALUE;\n      const id = value.data._ref;\n      if (typeof id != \"string\")\n        return NULL_VALUE;\n      if (scope.context.dereference) {\n        const value2 = scope.context.dereference({ _ref: id });\n        if (value2 && typeof value2 == \"object\" && \"then\" in value2)\n          throw new Error(\"Dereference returned promise in synchronous mode\");\n        return fromJS(value2);\n      }\n      if (scope.source.type !== \"array\")\n        return NULL_VALUE;\n      for (const doc of scope.source.data)\n        if (doc && typeof doc == \"object\" && \"_id\" in doc && id === doc._id)\n          return fromJS(doc);\n      return NULL_VALUE;\n    },\n    async executeAsync({ base }, scope) {\n      const value = await executeAsync(base, scope);\n      if (!scope.source.isArray() || value.type !== \"object\")\n        return NULL_VALUE;\n      const id = value.data._ref;\n      if (typeof id != \"string\")\n        return NULL_VALUE;\n      if (scope.context.dereference)\n        return fromJS(await scope.context.dereference({ _ref: id }));\n      for await (const doc of scope.source)\n        if (doc.type === \"object\" && id === doc.data._id)\n          return doc;\n      return NULL_VALUE;\n    }\n  },\n  Value: constantExecutor(({ value }) => fromJS(value)),\n  Group: {\n    executeSync({ base }, scope) {\n      return executeSync(base, scope);\n    },\n    executeAsync({ base }, scope) {\n      return executeAsync(base, scope);\n    }\n  },\n  Object: {\n    executeSync({ attributes }, scope) {\n      const result = {};\n      for (const attr of attributes) {\n        const attrType = attr.type;\n        switch (attr.type) {\n          case \"ObjectAttributeValue\": {\n            const value = executeSync(attr.value, scope);\n            result[attr.name] = value.data;\n            break;\n          }\n          case \"ObjectConditionalSplat\": {\n            const cond = executeSync(attr.condition, scope);\n            if (cond.type !== \"boolean\" || cond.data === !1)\n              continue;\n            const value = executeSync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          case \"ObjectSplat\": {\n            const value = executeSync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          default:\n            throw new Error(`Unknown node type: ${attrType}`);\n        }\n      }\n      return fromJS(result);\n    },\n    async executeAsync({ attributes }, scope) {\n      const result = {};\n      for (const attr of attributes) {\n        const attrType = attr.type;\n        switch (attr.type) {\n          case \"ObjectAttributeValue\": {\n            const value = await executeAsync(attr.value, scope);\n            result[attr.name] = await value.get();\n            break;\n          }\n          case \"ObjectConditionalSplat\": {\n            const cond = await executeAsync(attr.condition, scope);\n            if (cond.type !== \"boolean\" || cond.data === !1)\n              continue;\n            const value = await executeAsync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          case \"ObjectSplat\": {\n            const value = await executeAsync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          default:\n            throw new Error(`Unknown node type: ${attrType}`);\n        }\n      }\n      return fromJS(result);\n    }\n  },\n  Array: {\n    executeSync({ elements }, scope) {\n      const result = [];\n      for (const element of elements) {\n        const value = executeSync(element.value, scope);\n        if (element.isSplat) {\n          if (value.type === \"array\")\n            for (const v of value.data)\n              result.push(v);\n        } else\n          result.push(value.data);\n      }\n      return fromArray(result);\n    },\n    async executeAsync({ elements }, scope) {\n      return new StreamValue(async function* () {\n        for (const element of elements) {\n          const value = await executeAsync(element.value, scope);\n          if (element.isSplat) {\n            if (value.isArray())\n              for await (const v of value)\n                yield v;\n          } else\n            yield value;\n        }\n      });\n    }\n  },\n  Tuple: constantExecutor(() => {\n    throw new Error(\"tuples can not be evaluated\");\n  }),\n  Or: mappedExecutor(\n    ({ left, right }) => [left, right],\n    (_, leftValue, rightValue) => leftValue.type === \"boolean\" && leftValue.data === !0 || rightValue.type === \"boolean\" && rightValue.data === !0 ? TRUE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : FALSE_VALUE\n  ),\n  And: mappedExecutor(\n    ({ left, right }) => [left, right],\n    (_, leftValue, rightValue) => leftValue.type === \"boolean\" && leftValue.data === !1 || rightValue.type === \"boolean\" && rightValue.data === !1 ? FALSE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : TRUE_VALUE\n  ),\n  Not: mappedExecutor(\n    ({ base }) => [base],\n    (_, value) => value.type !== \"boolean\" ? NULL_VALUE : value.data ? FALSE_VALUE : TRUE_VALUE\n  ),\n  Neg: mappedExecutor(\n    ({ base }) => [base],\n    (_, value) => value.type !== \"number\" ? NULL_VALUE : fromNumber(-value.data)\n  ),\n  Pos: mappedExecutor(\n    ({ base }) => [base],\n    (_, value) => value.type !== \"number\" ? NULL_VALUE : fromNumber(value.data)\n  ),\n  Asc: constantExecutor(() => NULL_VALUE),\n  Desc: constantExecutor(() => NULL_VALUE),\n  ArrayCoerce: {\n    executeSync({ base }, scope) {\n      const value = executeSync(base, scope);\n      return value.isArray() ? value : NULL_VALUE;\n    },\n    async executeAsync({ base }, scope) {\n      const value = await executeAsync(base, scope);\n      return value.isArray() ? value : NULL_VALUE;\n    }\n  },\n  Map: arrayExecutor(\n    ({ base, expr }) => ({ array: base, inner: expr }),\n    function* (_, _item, inner) {\n      yield inner;\n    },\n    { hidden: !0 }\n  ),\n  FlatMap: arrayExecutor(\n    ({ base, expr }) => ({ array: base, inner: expr }),\n    function* (_, _item, inner) {\n      if (Array.isArray(inner))\n        for (const innerInner of inner)\n          yield innerInner;\n      else\n        yield inner;\n    },\n    { hidden: !0 }\n  )\n};\nfunction evaluateQuery(tree, options = {}) {\n  return executeAsync(tree, scopeFromOptions(options));\n}\nfunction evaluateQuerySync(tree, options = {}) {\n  return executeSync(tree, scopeFromOptions(options));\n}\nfunction scopeFromOptions(options) {\n  const root = fromJS(options.root), dataset = fromJS(options.dataset), params = { ...options.params };\n  return new Scope$1(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n      identity: options.identity === void 0 ? \"me\" : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n      dereference: options.dereference\n    },\n    null\n  );\n}\nfunction canConstantEvaluate(node) {\n  switch (node.type) {\n    case \"Group\":\n      return canConstantEvaluate(node.base);\n    case \"Value\":\n    case \"Parameter\":\n      return !0;\n    case \"Pos\":\n    case \"Neg\":\n      return canConstantEvaluate(node.base);\n    case \"OpCall\":\n      switch (node.op) {\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"**\":\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n        default:\n          return !1;\n      }\n    default:\n      return !1;\n  }\n}\nconst DUMMY_SCOPE = new Scope$1(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  { timestamp: /* @__PURE__ */ new Date(0), identity: \"me\", before: null, after: null },\n  null\n);\nfunction tryConstantEvaluate(node) {\n  return canConstantEvaluate(node) ? constantEvaluate(node) : null;\n}\nfunction constantEvaluate(node) {\n  return executeSync(node, DUMMY_SCOPE);\n}\nfunction isSelectorNode(node) {\n  return [\n    \"AccessAttribute\",\n    \"SelectorFuncCall\",\n    \"Group\",\n    \"Tuple\",\n    \"ArrayCoerce\",\n    \"Filter\",\n    \"SelectorNested\"\n  ].includes(node.type);\n}\nfunction isSelectorNested(node) {\n  return [\"AccessAttribute\", \"ArrayCoerce\", \"Filter\", \"Group\", \"Tuple\", \"SelectorNested\"].includes(\n    node.type\n  );\n}\nconst array = {};\narray.join = mappedExecutor(\n  (args) => args,\n  (_, arr, sep) => {\n    if (arr.type !== \"array\" || sep.type !== \"string\")\n      return NULL_VALUE;\n    let buf = \"\", needSep = !1;\n    for (const elem of arr.data) {\n      switch (needSep && (buf += sep.data), getType(elem)) {\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n          buf += `${elem}`;\n          break;\n        default:\n          return NULL_VALUE;\n      }\n      needSep = !0;\n    }\n    return fromString(buf);\n  }\n);\narray.join.arity = 2;\narray.compact = arrayExecutor(\n  ([array2]) => ({ array: array2 }),\n  function* (_, item) {\n    item !== null && (yield item);\n  }\n);\narray.compact.arity = 1;\narray.unique = arrayExecutor(\n  (args) => ({ array: args[0], state: /* @__PURE__ */ new Set() }),\n  function* (_node, iter, _inner, added) {\n    switch (getType(iter)) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n      case \"datetime\":\n        added.has(iter) || (added.add(iter), yield iter);\n        break;\n      default:\n        yield iter;\n    }\n  }\n);\narray.unique.arity = 1;\narray.intersects = mappedExecutor(\n  (args) => args,\n  (_, arr1, arr2) => {\n    if (arr1.type !== \"array\" || arr2.type !== \"array\")\n      return NULL_VALUE;\n    for (const v1 of arr1.data)\n      for (const v2 of arr2.data)\n        if (isEqual(fromJS(v1), fromJS(v2)))\n          return TRUE_VALUE;\n    return FALSE_VALUE;\n  }\n);\narray.intersects.arity = 2;\nconst dateTime = {};\ndateTime.now = constantExecutor(\n  (_, scope) => fromDateTime(new DateTime(scope.context.timestamp))\n);\ndateTime.now.arity = 0;\nasync function valueAtPath(arg, keyPath) {\n  function tryAccessor(arg2, accessor) {\n    try {\n      return arg2[accessor];\n    } catch {\n      return;\n    }\n  }\n  let current = await arg.get();\n  for (const part of keyPath)\n    if (current = tryAccessor(current, part), !current) break;\n  return current;\n}\nfunction startsWith(keyPath, prefix) {\n  return prefix.every((item, index) => keyPath[index] === item);\n}\nasync function* diffKeyPaths(before, after) {\n  const currPaths = [[]];\n  for (; currPaths.length > 0; ) {\n    const currPath = currPaths.shift() || [], b = fromJS(await valueAtPath(before, currPath)), a = fromJS(await valueAtPath(after, currPath));\n    if (a.type !== b.type)\n      yield currPath;\n    else if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\")\n      a.data !== b.data && (yield currPath);\n    else if (a.type === \"datetime\" && b.type === \"datetime\")\n      a.data.equals(b.data) || (yield currPath);\n    else if (a.type === \"object\" && b.type === \"object\") {\n      if (!deepEqual(a.data, b.data)) {\n        const aKeys = Object.keys(a.data), bKeys = Object.keys(b.data);\n        new Set(aKeys.concat(bKeys)).forEach((key) => {\n          currPaths.push([...currPath, key]);\n        });\n      }\n    } else if (a.type === \"array\" && b.type === \"array\") {\n      if (a.data.length !== b.data.length)\n        yield currPath;\n      else if (!deepEqual(a.data, b.data))\n        for (let i = 0; i < b.data.length; i++)\n          currPaths.push([...currPath, i]);\n    } else if (a.type === \"stream\" && b.type === \"stream\") {\n      const arrayA = await a.get(), arrayB = await b.get();\n      if (arrayA.length !== arrayB.length)\n        yield currPath;\n      else if (!deepEqual(arrayA, arrayB))\n        for (let i = 0; i < arrayB.length; i++)\n          currPaths.push([...currPath, i]);\n    }\n  }\n}\nasync function evaluateSelector(node, value, scope) {\n  switch (node.type) {\n    case \"Group\":\n      return await evaluateSelector(node.base, value, scope);\n    case \"Tuple\":\n      const tuplePaths = [];\n      for (const member of node.members) {\n        const memberPaths = await evaluateSelector(member, value, scope);\n        tuplePaths.push(...memberPaths);\n      }\n      return tuplePaths;\n    case \"AccessAttribute\":\n      return node.base ? (await evaluateSelector(node.base, value, scope)).map((path) => [...path, node.name]) : [[node.name]];\n    case \"ArrayCoerce\": {\n      const paths = await evaluateSelector(node.base, value, scope), arrayPaths = [];\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath);\n        if (Array.isArray(innerValue))\n          for (let i = 0; i < innerValue.length; i++)\n            arrayPaths.push([...keyPath, i]);\n      }\n      return arrayPaths;\n    }\n    case \"Filter\": {\n      const paths = await evaluateSelector(node.base, value, scope), filter = {\n        ...node,\n        base: { type: \"This\" }\n      }, arrayPaths = [];\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath);\n        if (Array.isArray(innerValue))\n          for (let i = 0; i < innerValue.length; i++) {\n            const item = innerValue[i], nestedScope = scope.createNested(fromJS([item]));\n            (await (await evaluate(filter, nestedScope)).get()).length > 0 && arrayPaths.push([...keyPath, i]);\n          }\n      }\n      return arrayPaths;\n    }\n    case \"SelectorFuncCall\":\n      return anywhere(node.arg, scope.createHidden(value));\n    case \"SelectorNested\": {\n      const { base, nested: expr } = node, paths = await evaluateSelector(base, value, scope), nestedPaths = [];\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath);\n        switch (expr.type) {\n          case \"AccessAttribute\":\n          case \"ArrayCoerce\":\n          case \"Filter\":\n            const accessPaths = await evaluateSelector(expr, fromJS(innerValue), scope);\n            for (let i = 0; i < accessPaths.length; i++)\n              nestedPaths.push([...keyPath, ...accessPaths[i]]);\n            break;\n          case \"Group\":\n            const innerResult = await evaluateSelector(expr.base, fromJS(innerValue), scope);\n            for (const innerKeyPath of innerResult)\n              nestedPaths.push([...keyPath, ...innerKeyPath]);\n            break;\n          case \"Tuple\":\n            for (const inner of expr.members) {\n              const innerResult2 = await evaluateSelector(inner, fromJS(innerValue), scope);\n              for (const innerKeyPath of innerResult2)\n                nestedPaths.push([...keyPath, ...innerKeyPath]);\n            }\n        }\n      }\n      return nestedPaths;\n    }\n  }\n}\nasync function anywhere(expr, scope, base = []) {\n  const value = scope.value, pathList = [];\n  if (value.isArray()) {\n    const arr = await value.get();\n    for (let i = 0; i < arr.length; i++) {\n      const subPaths = await anywhere(expr, scope.createHidden(fromJS(arr[i])), [...base, i]);\n      pathList.push(...subPaths);\n    }\n  } else if (value.type === \"object\") {\n    const result = await evaluate(expr, scope);\n    result.type === \"boolean\" && result.data === !0 && pathList.push(base);\n    for (const key of Object.keys(value.data)) {\n      const subPaths = await anywhere(expr, scope.createHidden(fromJS(value.data[key])), [\n        ...base,\n        key\n      ]);\n      pathList.push(...subPaths);\n    }\n  }\n  return pathList;\n}\nasync function changedAny(before, after, selector, scope) {\n  const beforeSelectorScope = scope.createHidden(before), beforePaths = await evaluateSelector(\n    selector,\n    beforeSelectorScope.value,\n    beforeSelectorScope\n  ), afterSelectorScope = scope.createHidden(after), afterPaths = await evaluateSelector(selector, afterSelectorScope.value, afterSelectorScope);\n  if (beforePaths.length !== afterPaths.length)\n    return TRUE_VALUE;\n  for (const path of beforePaths) {\n    for (let i = 0; i < path.length; i++)\n      if (typeof path[i] == \"number\") {\n        const slice = path.slice(0, i), beforeArr = await valueAtPath(before, slice), afterArr = await valueAtPath(after, slice);\n        if (!Array.isArray(beforeArr) || !Array.isArray(afterArr) || beforeArr.length !== afterArr.length)\n          return TRUE_VALUE;\n      }\n    const beforeValue = await valueAtPath(before, path), afterValue = await valueAtPath(after, path);\n    if (!deepEqual(beforeValue, afterValue))\n      return TRUE_VALUE;\n  }\n  return FALSE_VALUE;\n}\nasync function changedOnly(before, after, selector, scope) {\n  const beforeSelectorScope = scope.createHidden(before), selectedPaths = await evaluateSelector(\n    selector,\n    beforeSelectorScope.value,\n    beforeSelectorScope\n  );\n  for await (const diffPath of diffKeyPaths(before, after)) {\n    let found = !1;\n    for (const selectedPath of selectedPaths)\n      if (startsWith(diffPath, selectedPath)) {\n        found = !0;\n        break;\n      }\n    if (!found)\n      return FALSE_VALUE;\n  }\n  return TRUE_VALUE;\n}\nconst diff = {};\ndiff.changedAny = asyncOnlyExecutor(async (args, scope) => {\n  const lhs = args[0], rhs = args[1], selector = args[2];\n  if (!isSelectorNode(selector)) throw new Error(\"changedAny third argument must be a selector\");\n  const before = await executeAsync(lhs, scope), after = await executeAsync(rhs, scope);\n  return changedAny(before, after, selector, scope);\n});\ndiff.changedAny.arity = 3;\ndiff.changedOnly = asyncOnlyExecutor(async (args, scope) => {\n  const lhs = args[0], rhs = args[1], selector = args[2];\n  if (!isSelectorNode(selector)) throw new Error(\"changedOnly third argument must be a selector\");\n  const before = await executeAsync(lhs, scope), after = await executeAsync(rhs, scope);\n  return changedOnly(before, after, selector, scope);\n});\ndiff.changedOnly.arity = 3;\nconst delta = {};\ndelta.operation = constantExecutor((_, scope) => {\n  const hasBefore = scope.context.before !== null, hasAfter = scope.context.after !== null;\n  return hasBefore && hasAfter ? fromString(\"update\") : hasAfter ? fromString(\"create\") : hasBefore ? fromString(\"delete\") : NULL_VALUE;\n});\ndelta.changedAny = asyncOnlyExecutor(async (args, scope) => {\n  const before = scope.context.before || NULL_VALUE, after = scope.context.after || NULL_VALUE, selector = args[0];\n  if (!isSelectorNode(selector)) throw new Error(\"changedAny first argument must be a selector\");\n  return changedAny(before, after, selector, scope);\n});\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = asyncOnlyExecutor(async (args, scope) => {\n  const before = scope.context.before || NULL_VALUE, after = scope.context.after || NULL_VALUE, selector = args[0];\n  if (!isSelectorNode(selector)) throw new Error(\"changedOnly first argument must be a selector\");\n  return changedOnly(before, after, selector, scope);\n});\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst documents = {};\ndocuments.get = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\nconst geo = {};\ngeo.latLng = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ngeo.contains = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ngeo.intersects = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ngeo.distance = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\nconst string = {};\nstring.lower = mappedExecutor(\n  (args) => args,\n  (_, value) => value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toLowerCase())\n);\nstring.lower.arity = 1;\nstring.upper = mappedExecutor(\n  (args) => args,\n  (_, value) => value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toUpperCase())\n);\nstring.upper.arity = 1;\nstring.split = mappedExecutor(\n  (args) => args,\n  (_, str, sep) => str.type !== \"string\" || sep.type !== \"string\" ? NULL_VALUE : str.data.length === 0 ? fromArray([]) : sep.data.length === 0 ? fromArray(Array.from(str.data)) : fromArray(str.data.split(sep.data))\n);\nstring.split.arity = 2;\nstring.startsWith = mappedExecutor(\n  (args) => args,\n  (_, str, prefix) => str.type !== \"string\" || prefix.type !== \"string\" ? NULL_VALUE : str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n);\nstring.startsWith.arity = 2;\nconst _global = {};\n_global.anywhere = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\n_global.anywhere.arity = 1;\n_global.coalesce = {\n  async executeAsync(args, scope) {\n    for (const arg of args) {\n      const value = await executeAsync(arg, scope);\n      if (value.type !== \"null\")\n        return value;\n    }\n    return NULL_VALUE;\n  },\n  executeSync(args, scope) {\n    for (const arg of args) {\n      const value = executeSync(arg, scope);\n      if (value.type !== \"null\")\n        return value;\n    }\n    return NULL_VALUE;\n  }\n};\n_global.count = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => 0,\n  (_, count) => count + 1,\n  fromNumber\n);\n_global.count.arity = 1;\n_global.dateTime = mappedExecutor(\n  (args) => args,\n  (_, val) => val.type === \"datetime\" ? val : val.type !== \"string\" ? NULL_VALUE : DateTime.parseToValue(val.data)\n);\n_global.dateTime.arity = 1;\n_global.defined = mappedExecutor(\n  (args) => args,\n  (_, inner) => inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE\n);\n_global.defined.arity = 1;\n_global.identity = constantExecutor((_args, scope) => fromString(scope.context.identity));\n_global.identity.arity = 0;\n_global.length = mappedExecutor(\n  (args) => args,\n  (_, inner) => inner.type === \"string\" ? fromNumber(countUTF8(inner.data)) : inner.type === \"array\" ? fromNumber(inner.data.length) : NULL_VALUE\n);\n_global.length.arity = 1;\n_global.path = mappedExecutor(\n  (args) => args,\n  (_, inner) => inner.type !== \"string\" ? NULL_VALUE : fromPath(new Path(inner.data))\n);\n_global.path.arity = 1;\n_global.string = mappedExecutor(\n  (args) => args,\n  (_, value) => {\n    switch (value.type) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n      case \"datetime\":\n        return fromString(`${value.data}`);\n      default:\n        return NULL_VALUE;\n    }\n  }\n);\n_global.string.arity = 1;\n_global.references = mappedExecutor(\n  (args) => [{ type: \"This\" }, ...args],\n  (_, scopeValue, ...args) => {\n    const pathSet = /* @__PURE__ */ new Set();\n    for (const path of args)\n      if (path.type === \"string\")\n        pathSet.add(path.data);\n      else if (path.type === \"array\")\n        for (const elem of path.data)\n          typeof elem == \"string\" && pathSet.add(elem);\n    return pathSet.size === 0 ? FALSE_VALUE : hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n  }\n);\n_global.references.arity = (c) => c >= 1;\n_global.round = mappedExecutor(\n  (args) => args,\n  (_, value, precValue) => {\n    if (value.type !== \"number\")\n      return NULL_VALUE;\n    const num = value.data;\n    let prec = 0;\n    if (precValue) {\n      if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data))\n        return NULL_VALUE;\n      prec = precValue.data;\n    }\n    return prec === 0 ? num < 0 ? fromNumber(-Math.round(-num)) : fromNumber(Math.round(num)) : fromNumber(Number(num.toFixed(prec)));\n  }\n);\n_global.round.arity = (count) => count >= 1 && count <= 2;\n_global.now = constantExecutor((_args, scope) => fromString(scope.context.timestamp.toISOString()));\n_global.now.arity = 0;\n_global.boost = constantExecutor(() => {\n  throw new Error(\"unexpected boost call\");\n});\n_global.boost.arity = 2;\n_global.lower = string.lower;\n_global.upper = string.upper;\nfunction countUTF8(str) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    code >= 55296 && code <= 56319 || count++;\n  }\n  return count;\n}\nfunction hasReference(value, pathSet) {\n  switch (getType(value)) {\n    case \"array\":\n      for (const v of value)\n        if (hasReference(v, pathSet))\n          return !0;\n      break;\n    case \"object\":\n      if (value._ref)\n        return pathSet.has(value._ref);\n      for (const v of Object.values(value))\n        if (hasReference(v, pathSet))\n          return !0;\n      break;\n  }\n  return !1;\n}\nconst math = {};\nmath.min = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => {\n  },\n  (_, n, item) => item === null ? n : typeof item != \"number\" ? STOP_ITERATOR : n === void 0 || item < n ? item : n,\n  (n) => n === void 0 ? NULL_VALUE : fromNumber(n)\n);\nmath.min.arity = 1;\nmath.max = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => {\n  },\n  (_, n, item) => item === null ? n : typeof item != \"number\" ? STOP_ITERATOR : n === void 0 || item > n ? item : n,\n  (n) => n === void 0 ? NULL_VALUE : fromNumber(n)\n);\nmath.max.arity = 1;\nmath.sum = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => 0,\n  (_, n, item) => item === null ? n : typeof item != \"number\" ? STOP_ITERATOR : n + item,\n  fromNumber\n);\nmath.sum.arity = 1;\nmath.avg = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => ({ count: 0, sum: 0 }),\n  (_, { count, sum }, item) => item === null ? { count, sum } : typeof item != \"number\" ? STOP_ITERATOR : { count: count + 1, sum: sum + item },\n  ({ count, sum }) => count === 0 ? NULL_VALUE : fromNumber(sum / count)\n);\nmath.avg.arity = 1;\nfunction portableTextContent(value) {\n  if (value.type === \"object\")\n    return blockText(value.data);\n  if (value.type === \"array\") {\n    const texts = arrayText(value.data);\n    if (texts.length > 0)\n      return texts.join(`\n\n`);\n  }\n  return null;\n}\nfunction arrayText(value, result = []) {\n  for (const block of value)\n    if (Array.isArray(block))\n      arrayText(block, result);\n    else if (typeof block == \"object\" && block) {\n      const text2 = blockText(block);\n      text2 !== null && result.push(text2);\n    }\n  return result;\n}\nfunction blockText(obj) {\n  if (typeof obj._type != \"string\") return null;\n  const children = obj.children;\n  if (!Array.isArray(children)) return null;\n  let result = \"\";\n  for (const child of children)\n    child && typeof child == \"object\" && typeof child._type == \"string\" && child._type === \"span\" && typeof child.text == \"string\" && (result += child.text);\n  return result;\n}\nconst pt = {};\npt.text = mappedExecutor(\n  (args) => args,\n  function(_, value) {\n    const text2 = portableTextContent(value);\n    return text2 === null ? NULL_VALUE : fromString(text2);\n  }\n);\npt.text.arity = 1;\nconst releases = {};\nreleases.all = arrayExecutor(\n  () => ({ array: { type: \"Everything\" } }),\n  function* (_, value) {\n    typeof value == \"object\" && value && \"_type\" in value && value._type === \"system.release\" && (yield value);\n  }\n);\nreleases.all.arity = 0;\nconst sanity = {};\nsanity.projectId = constantExecutor((_, scope) => scope.context.sanity ? fromString(scope.context.sanity.projectId) : NULL_VALUE);\nsanity.dataset = constantExecutor((_, scope) => scope.context.sanity ? fromString(scope.context.sanity.dataset) : NULL_VALUE);\nsanity.versionOf = mappedExecutor(\n  ([value]) => [value, { type: \"This\" }],\n  (_, value, val) => {\n    if (value.type !== \"string\") return NULL_VALUE;\n    const baseId = value.data;\n    if (val.type !== \"object\" || typeof val.data._id != \"string\") return NULL_VALUE;\n    if (val.data._id === baseId) return TRUE_VALUE;\n    const components = val.data._id.split(\".\");\n    return components.length >= 2 && components[0] === \"drafts\" && components.slice(1).join(\".\") === baseId || components.length >= 3 && components[0] === \"versions\" && components.slice(2).join(\".\") === baseId ? TRUE_VALUE : FALSE_VALUE;\n  }\n);\nsanity.versionOf.arity = 1;\nsanity.partOfRelease = mappedExecutor(\n  (args) => [args[0], { type: \"This\" }],\n  (_, value, val) => {\n    if (value.type !== \"string\") return NULL_VALUE;\n    const baseId = value.data;\n    if (val.type !== \"object\" || typeof val.data._id != \"string\") return NULL_VALUE;\n    const components = val.data._id.split(\".\");\n    return components.length >= 3 && components[0] === \"versions\" && components[1] === baseId ? TRUE_VALUE : FALSE_VALUE;\n  }\n);\nsanity.partOfRelease.arity = 1;\nconst text = {};\ntext.query = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ntext.query.arity = 1;\nconst BM25k = 1.2;\nasync function evaluateScoreAsync(node, scope) {\n  if (node.type === \"OpCall\" && node.op === \"match\")\n    return evaluateMatchScoreAsync(node.left, node.right, scope);\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = await evaluateScoreAsync(node.args[0], scope), boost = await executeAsync(node.args[1], scope);\n    return boost.type === \"number\" && innerScore > 0 ? innerScore + boost.data : 0;\n  }\n  switch (node.type) {\n    case \"Or\": {\n      const leftScore = await evaluateScoreAsync(node.left, scope), rightScore = await evaluateScoreAsync(node.right, scope);\n      return leftScore + rightScore;\n    }\n    case \"And\": {\n      const leftScore = await evaluateScoreAsync(node.left, scope), rightScore = await evaluateScoreAsync(node.right, scope);\n      return leftScore === 0 || rightScore === 0 ? 0 : leftScore + rightScore;\n    }\n    default: {\n      const res = await executeAsync(node, scope);\n      return res.type === \"boolean\" && res.data === !0 ? 1 : 0;\n    }\n  }\n}\nfunction evaluateScoreSync(node, scope) {\n  if (node.type === \"OpCall\" && node.op === \"match\")\n    return evaluateMatchScoreSync(node.left, node.right, scope);\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = evaluateScoreSync(node.args[0], scope), boost = executeSync(node.args[1], scope);\n    return boost.type === \"number\" && innerScore > 0 ? innerScore + boost.data : 0;\n  }\n  switch (node.type) {\n    case \"Or\": {\n      const leftScore = evaluateScoreSync(node.left, scope), rightScore = evaluateScoreSync(node.right, scope);\n      return leftScore + rightScore;\n    }\n    case \"And\": {\n      const leftScore = evaluateScoreSync(node.left, scope), rightScore = evaluateScoreSync(node.right, scope);\n      return leftScore === 0 || rightScore === 0 ? 0 : leftScore + rightScore;\n    }\n    default: {\n      const res = executeSync(node, scope);\n      return res.type === \"boolean\" && res.data === !0 ? 1 : 0;\n    }\n  }\n}\nfunction evaluateMatchScoreSync(left, right, scope) {\n  const text2 = executeSync(left, scope), pattern = executeSync(right, scope), result = processMatchScore(text2, pattern);\n  if (typeof result == \"number\") return result;\n  throw new Error(\"Found synchronous value in match()\");\n}\nasync function evaluateMatchScoreAsync(left, right, scope) {\n  const text2 = await executeAsync(left, scope), pattern = await executeAsync(right, scope);\n  return processMatchScore(text2, pattern);\n}\nfunction processMatchScore(text2, pattern) {\n  const tokens = gatherText(text2, (part) => matchTokenize(part)), terms = gatherText(pattern, (part) => matchPatternRegex(part)), process = (tokens2, terms2) => {\n    if (!terms2.success || tokens2.parts.length === 0 || terms2.parts.length === 0)\n      return 0;\n    let score = 0;\n    for (const re of terms2.parts) {\n      const freq = tokens2.parts.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);\n      score += freq * (BM25k + 1) / (freq + BM25k);\n    }\n    return score;\n  };\n  return \"then\" in tokens || \"then\" in terms ? (async () => process(await tokens, await terms))() : process(tokens, terms);\n}\nfunction extractOrderArgs(args) {\n  const mappers = [], directions = [];\n  for (let mapper of args) {\n    let direction = \"asc\";\n    mapper.type === \"Desc\" ? (direction = \"desc\", mapper = mapper.base) : mapper.type === \"Asc\" && (mapper = mapper.base), mappers.push(mapper), directions.push(direction);\n  }\n  return { mappers, directions };\n}\nfunction sortArray(aux, directions) {\n  return aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < directions.length; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n      if (directions[i] === \"desc\" && (c = -c), c !== 0)\n        return c;\n    }\n    return aTuple[1] - bTuple[1];\n  }), aux.map((v) => v[0]);\n}\nconst pipeFunctions = {};\npipeFunctions.order = {\n  executeSync({ base, args }, scope) {\n    const { mappers, directions } = extractOrderArgs(args), aux = [];\n    let idx = 0;\n    const n = directions.length;\n    for (const value of base.data) {\n      const newScope = scope.createNested(fromJS(value)), tuple = [value, idx];\n      for (let i = 0; i < n; i++) {\n        const result = executeSync(mappers[i], newScope);\n        tuple.push(result.data);\n      }\n      aux.push(tuple), idx++;\n    }\n    return fromArray(sortArray(aux, directions));\n  },\n  async executeAsync({ base, args }, scope) {\n    const { mappers, directions } = extractOrderArgs(args), aux = [];\n    let idx = 0;\n    const n = directions.length;\n    for await (const value of base) {\n      const newScope = scope.createNested(value), tuple = [await value.get(), idx];\n      for (let i = 0; i < n; i++) {\n        const result = await executeAsync(mappers[i], newScope);\n        tuple.push(await result.get());\n      }\n      aux.push(tuple), idx++;\n    }\n    return fromArray(sortArray(aux, directions));\n  }\n};\npipeFunctions.order.arity = (count) => count >= 1;\npipeFunctions.score = {\n  async executeAsync({ base, args }, scope) {\n    const unknown = [], scored = [];\n    for await (const value of base) {\n      if (value.type !== \"object\") {\n        unknown.push(await value.get());\n        continue;\n      }\n      const newScope = scope.createNested(value);\n      let valueScore = typeof value.data._score == \"number\" ? value.data._score : 0;\n      for (const arg of args)\n        valueScore += await evaluateScoreAsync(arg, newScope);\n      const newObject = Object.assign({}, value.data, { _score: valueScore });\n      scored.push(newObject);\n    }\n    return scored.sort((a, b) => b._score - a._score), fromJS(scored);\n  },\n  executeSync({ base, args }, scope) {\n    const scored = [];\n    for (const value of base.data) {\n      if (getType(value) !== \"object\")\n        continue;\n      const valueObj = value, newScope = scope.createNested(fromJS(value));\n      let valueScore = typeof valueObj._score == \"number\" ? valueObj._score : 0;\n      for (const arg of args)\n        valueScore += evaluateScoreSync(arg, newScope);\n      const newObject = Object.assign({}, valueObj, { _score: valueScore });\n      scored.push(newObject);\n    }\n    return scored.sort((a, b) => b._score - a._score), fromArray(scored);\n  }\n};\npipeFunctions.score.arity = (count) => count >= 1;\nconst namespaces = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n  dateTime,\n  releases,\n  text,\n  geo,\n  documents\n};\nclass MarkProcessor {\n  string;\n  marks;\n  index;\n  parseOptions;\n  allowBoost = !1;\n  constructor(string2, marks, parseOptions) {\n    this.string = string2, this.marks = marks, this.index = 0, this.parseOptions = parseOptions;\n  }\n  hasMark(pos = 0) {\n    return this.index + pos < this.marks.length;\n  }\n  getMark(pos = 0) {\n    return this.marks[this.index + pos];\n  }\n  shift() {\n    this.index += 1;\n  }\n  process(visitor) {\n    const mark = this.marks[this.index];\n    this.shift();\n    const func = visitor[mark.name];\n    if (!func)\n      throw new Error(`Unknown handler: ${mark.name}`);\n    return func.call(visitor, this, mark);\n  }\n  processString() {\n    return this.shift(), this.processStringEnd();\n  }\n  processStringEnd() {\n    const prev = this.marks[this.index - 1], curr = this.marks[this.index];\n    return this.shift(), this.string.slice(prev.position, curr.position);\n  }\n  slice(len) {\n    const pos = this.marks[this.index].position;\n    return this.string.slice(pos, pos + len);\n  }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/, NUM = /^\\d+/, IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  return result.type === \"error\" ? result : (pos = skipWS(str, result.position), pos !== str.length ? (result.failPosition && (pos = result.failPosition - 1), { type: \"error\", message: \"Unexpected end of query\", position: pos }) : (delete result.position, delete result.failPosition, result));\n}\nfunction parseExpr(str, pos, level) {\n  let startPos = pos, token = str[pos], marks;\n  switch (token) {\n    case \"+\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"pos\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"-\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 8);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"neg\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"(\": {\n      let result = parseGroupOrTuple(str, pos);\n      if (result.type === \"error\") return result;\n      pos = result.position, marks = result.marks;\n      break;\n    }\n    case \"!\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"not\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      if (result.type === \"error\") return result;\n      marks = result.marks, pos = result.position;\n      break;\n    }\n    case \"[\":\n      if (marks = [{ name: \"array\", position: pos }], pos = skipWS(str, pos + 1), str[pos] !== \"]\")\n        for (; ; ) {\n          str.slice(pos, pos + 3) === \"...\" && (marks.push({ name: \"array_splat\", position: pos }), pos = skipWS(str, pos + 3));\n          let res = parseExpr(str, pos, 0);\n          if (res.type === \"error\") return res;\n          if (marks = marks.concat(res.marks), pos = res.position, pos = skipWS(str, pos), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \"]\")) break;\n        }\n      if (str[pos] === \"]\")\n        pos++, marks.push({ name: \"array_end\", position: pos });\n      else\n        return { type: \"error\", message: 'Expected \"]\" after array expression', position: pos };\n      break;\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === \"error\") return result;\n      marks = result.marks, pos = result.position;\n      break;\n    }\n    case \"^\": {\n      for (pos++, marks = []; str[pos] === \".\" && str[pos + 1] === \"^\"; )\n        marks.push({ name: \"dblparent\", position: startPos }), pos += 2;\n      marks.push({ name: \"parent\", position: startPos });\n      break;\n    }\n    case \"@\":\n      marks = [{ name: \"this\", position: startPos }], pos++;\n      break;\n    case \"*\":\n      marks = [{ name: \"everything\", position: startPos }], pos++;\n      break;\n    case \"$\": {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      identLen && (pos += 1 + identLen, marks = [\n        { name: \"param\", position: startPos },\n        { name: \"ident\", position: startPos + 1 },\n        { name: \"ident_end\", position: pos }\n      ]);\n      break;\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = \"integer\";\n        if (str[pos] === \".\") {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          fracLen && (name = \"float\", pos += 1 + fracLen);\n        }\n        if (str[pos] === \"e\" || str[pos] === \"E\") {\n          name = \"sci\", pos++, (str[pos] === \"+\" || str[pos] === \"-\") && pos++;\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen) return { type: \"error\", message: \"Exponent must be a number\", position: pos };\n          pos += expLen;\n        }\n        marks = [\n          { name, position: startPos },\n          { name: name + \"_end\", position: pos }\n        ];\n        break;\n      }\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        switch (pos += identLen, str[pos]) {\n          case \":\":\n          case \"(\": {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === \"error\") return result;\n            marks = result.marks, pos = result.position;\n            break;\n          }\n          default:\n            marks = [\n              { name: \"this_attr\", position: startPos },\n              { name: \"ident\", position: startPos },\n              { name: \"ident_end\", position: pos }\n            ];\n        }\n        break;\n      }\n    }\n  }\n  if (!marks)\n    return { type: \"error\", message: \"Expected expression\", position: pos };\n  let lhsLevel = 12, trav;\n  loop: for (; ; ) {\n    let innerPos = skipWS(str, pos);\n    if (innerPos === str.length) {\n      pos = innerPos;\n      break;\n    }\n    if (trav = parseTraversal(str, innerPos), trav.type === \"success\") {\n      for (marks.unshift({ name: \"traverse\", position: startPos }); trav.type === \"success\"; )\n        marks = marks.concat(trav.marks), pos = trav.position, trav = parseTraversal(str, skipWS(str, pos));\n      marks.push({ name: \"traversal_end\", position: pos });\n      continue;\n    }\n    switch (str[innerPos]) {\n      case \"=\": {\n        switch (str[innerPos + 1]) {\n          case \">\": {\n            if (level > 1 || lhsLevel <= 1) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 1);\n            if (rhs.type === \"error\") return rhs;\n            marks = marks.concat(rhs.marks), marks.unshift({ name: \"pair\", position: startPos }), pos = rhs.position, lhsLevel = 1;\n            break;\n          }\n          case \"=\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n            if (rhs.type === \"error\") return rhs;\n            marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n            break;\n          }\n          default:\n            break loop;\n        }\n        break;\n      }\n      case \"+\": {\n        if (level > 6 || lhsLevel < 6) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"add\", position: startPos }), pos = rhs.position, lhsLevel = 6;\n        break;\n      }\n      case \"-\": {\n        if (level > 6 || lhsLevel < 6) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"sub\", position: startPos }), pos = rhs.position, lhsLevel = 6;\n        break;\n      }\n      case \"*\": {\n        if (str[innerPos + 1] === \"*\") {\n          if (level > 8 || lhsLevel <= 8) break loop;\n          let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), 8);\n          if (rhs2.type === \"error\") return rhs2;\n          marks = marks.concat(rhs2.marks), marks.unshift({ name: \"pow\", position: startPos }), pos = rhs2.position, lhsLevel = 8;\n          break;\n        }\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"mul\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"/\": {\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"div\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"%\": {\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"mod\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"<\":\n      case \">\": {\n        if (level > 4 || lhsLevel <= 4) break loop;\n        let nextPos = innerPos + 1;\n        str[nextPos] === \"=\" && nextPos++;\n        let rhs = parseExpr(str, skipWS(str, nextPos), 5);\n        if (rhs.type === \"error\") return rhs;\n        marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: nextPos }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n        break;\n      }\n      case \"|\": {\n        if (str[innerPos + 1] === \"|\") {\n          if (level > 2 || lhsLevel < 2) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), 3);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks), marks.unshift({ name: \"or\", position: startPos }), pos = rhs.position, lhsLevel = 2;\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop;\n          let identPos = skipWS(str, innerPos + 1), identLen = parseRegex(str, identPos, IDENT);\n          if (!identLen) return { type: \"error\", message: \"Expected identifier\", position: identPos };\n          if (pos = identPos + identLen, str[pos] === \"(\" || str[pos] === \":\") {\n            let result = parseFuncCall(str, identPos, pos);\n            if (result.type === \"error\") return result;\n            marks = marks.concat(result.marks), marks.unshift({ name: \"pipecall\", position: startPos }), pos = result.position, lhsLevel = 11;\n          }\n        }\n        break;\n      }\n      case \"&\": {\n        if (str[innerPos + 1] != \"&\" || level > 3 || lhsLevel < 3) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), 4);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"and\", position: startPos }), pos = rhs.position, lhsLevel = 3;\n        break;\n      }\n      case \"!\": {\n        if (str[innerPos + 1] !== \"=\" || level > 4 || lhsLevel <= 4) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n        if (rhs.type === \"error\") return rhs;\n        marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n        break;\n      }\n      case \"d\": {\n        if (str.slice(innerPos, innerPos + 4) !== \"desc\" || level > 4 || lhsLevel < 4) break loop;\n        marks.unshift({ name: \"desc\", position: startPos }), pos = innerPos + 4, lhsLevel = 4;\n        break;\n      }\n      case \"a\": {\n        if (str.slice(innerPos, innerPos + 3) !== \"asc\" || level > 4 || lhsLevel < 4) break loop;\n        marks.unshift({ name: \"asc\", position: startPos }), pos = innerPos + 3, lhsLevel = 4;\n        break;\n      }\n      default:\n        switch (parseRegexStr(str, innerPos, IDENT)) {\n          case \"in\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            pos = skipWS(str, innerPos + 2);\n            let isGroup = !1;\n            str[pos] === \"(\" && (isGroup = !0, pos = skipWS(str, pos + 1));\n            let rangePos = pos, result = parseExpr(str, pos, 5);\n            if (result.type === \"error\") return result;\n            if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n              let type = \"inc_range\";\n              str[pos + 2] === \".\" ? (type = \"exc_range\", pos = skipWS(str, pos + 3)) : pos = skipWS(str, pos + 2);\n              let rhs = parseExpr(str, pos, 5);\n              if (rhs.type === \"error\") return rhs;\n              marks.unshift({ name: \"in_range\", position: startPos }), marks = marks.concat({ name: type, position: rangePos }, result.marks, rhs.marks), pos = rhs.position;\n            } else\n              marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(result.marks);\n            if (isGroup) {\n              if (pos = skipWS(str, pos), str[pos] !== \")\")\n                return { type: \"error\", message: 'Expected \")\" in group', position: pos };\n              pos++;\n            }\n            lhsLevel = 4;\n            break;\n          }\n          case \"match\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), 5);\n            if (rhs.type === \"error\") return rhs;\n            marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 5 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n            break;\n          }\n          default:\n            break loop;\n        }\n    }\n  }\n  let failPosition = trav?.type === \"error\" && trav.position;\n  return { type: \"success\", marks, position: pos, failPosition };\n}\nfunction parseGroupOrTuple(str, pos) {\n  const startPos = pos;\n  let marks, rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n  if (rhs.type === \"error\") return rhs;\n  switch (pos = skipWS(str, rhs.position), str[pos]) {\n    case \",\": {\n      for (marks = [{ name: \"tuple\", position: startPos }].concat(rhs.marks), pos = skipWS(str, pos + 1); ; ) {\n        if (rhs = parseExpr(str, pos, 0), rhs.type === \"error\") return rhs;\n        if (marks.push(...rhs.marks), pos = skipWS(str, rhs.position), str[pos] !== \",\") break;\n        pos = skipWS(str, pos + 1);\n      }\n      if (str[pos] !== \")\")\n        return { type: \"error\", message: 'Expected \")\" after tuple expression', position: pos };\n      pos++, marks.push({ name: \"tuple_end\", position: pos });\n      break;\n    }\n    case \")\": {\n      pos++, marks = [{ name: \"group\", position: startPos }].concat(rhs.marks);\n      break;\n    }\n    default:\n      return { type: \"error\", message: `Unexpected character \"${str[pos]}\"`, position: pos };\n  }\n  return { type: \"success\", marks, position: pos };\n}\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case \".\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"(\")\n        return parseGroupOrTuple(str, pos);\n      let identStart = pos, identLen2 = parseRegex(str, pos, IDENT);\n      return identLen2 ? (pos += identLen2, {\n        type: \"success\",\n        marks: [\n          { name: \"attr_access\", position: startPos },\n          { name: \"ident\", position: identStart },\n          { name: \"ident_end\", position: pos }\n        ],\n        position: pos\n      }) : { type: \"error\", message: 'Expected identifier after \".\"', position: pos };\n    }\n    case \"-\":\n      if (str[pos + 1] !== \">\")\n        return { type: \"error\", message: 'Expected \">\" in reference', position: pos };\n      let marks = [{ name: \"deref\", position: startPos }];\n      pos += 2;\n      let identPos = skipWS(str, pos), identLen = parseRegex(str, identPos, IDENT);\n      return identLen && (pos = identPos + identLen, marks.push(\n        { name: \"deref_attr\", position: identPos },\n        { name: \"ident\", position: identPos },\n        { name: \"ident_end\", position: pos }\n      )), {\n        type: \"success\",\n        marks,\n        position: pos\n      };\n    case \"[\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"]\")\n        return {\n          type: \"success\",\n          marks: [{ name: \"array_postfix\", position: startPos }],\n          position: pos + 1\n        };\n      let rangePos = pos, result = parseExpr(str, pos, 0);\n      if (result.type === \"error\") return result;\n      if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n        let type = \"inc_range\";\n        str[pos + 2] === \".\" ? (type = \"exc_range\", pos += 3) : pos += 2, pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        return rhs.type === \"error\" ? rhs : (pos = skipWS(str, rhs.position), str[pos] !== \"]\" ? { type: \"error\", message: 'Expected \"]\" after array expression', position: pos } : {\n          type: \"success\",\n          marks: [\n            { name: \"slice\", position: startPos },\n            { name: type, position: rangePos }\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1\n        });\n      }\n      return str[pos] !== \"]\" ? { type: \"error\", message: 'Expected \"]\" after array expression', position: pos } : {\n        type: \"success\",\n        marks: [{ name: \"square_bracket\", position: startPos }].concat(result.marks),\n        position: pos + 1\n      };\n    }\n    case \"|\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"{\") {\n        let result = parseObject(str, pos);\n        return result.type === \"error\" || result.marks.unshift({ name: \"projection\", position: startPos }), result;\n      }\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      return result.type === \"error\" || result.marks.unshift({ name: \"projection\", position: startPos }), result;\n    }\n  }\n  return { type: \"error\", message: \"Unexpected character in traversal\", position: pos };\n}\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n  if (marks.push({ name: \"func_call\", position: startPos }), str[pos] === \":\" && str[pos + 1] === \":\") {\n    marks.push({ name: \"namespace\", position: startPos }), marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos }), pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen) return { type: \"error\", message: \"Expected function name\", position: pos };\n    if (marks.push({ name: \"ident\", position: pos }, { name: \"ident_end\", position: pos + nameLen }), pos = skipWS(str, pos + nameLen), str[pos] !== \"(\")\n      return { type: \"error\", message: 'Expected \"(\" after function name', position: pos };\n    pos++, pos = skipWS(str, pos);\n  } else\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos }), pos = skipWS(str, pos + 1);\n  let lastPos = pos;\n  if (str[pos] !== \")\")\n    for (; ; ) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\") return result;\n      if (marks = marks.concat(result.marks), lastPos = result.position, pos = skipWS(str, result.position), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \")\")) break;\n    }\n  return str[pos] !== \")\" ? { type: \"error\", message: 'Expected \")\" after function arguments', position: pos } : (marks.push({ name: \"func_args_end\", position: lastPos }), {\n    type: \"success\",\n    marks,\n    position: pos + 1\n  });\n}\nfunction parseObject(str, pos) {\n  let marks = [{ name: \"object\", position: pos }];\n  for (pos = skipWS(str, pos + 1); str[pos] !== \"}\"; ) {\n    let pairPos = pos;\n    if (str.slice(pos, pos + 3) === \"...\")\n      if (pos = skipWS(str, pos + 3), str[pos] !== \"}\" && str[pos] !== \",\") {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === \"error\") return expr;\n        marks.push({ name: \"object_splat\", position: pairPos }), marks = marks.concat(expr.marks), pos = expr.position;\n      } else\n        marks.push({ name: \"object_splat_this\", position: pairPos });\n    else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === \"error\") return expr;\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === \"error\") return value;\n        marks.push({ name: \"object_pair\", position: pairPos }), marks = marks.concat(expr.marks, value.marks), pos = value.position;\n      } else\n        marks = marks.concat({ name: \"object_expr\", position: pos }, expr.marks), pos = expr.position;\n    }\n    if (pos = skipWS(str, pos), str[pos] !== \",\") break;\n    pos = skipWS(str, pos + 1);\n  }\n  return str[pos] !== \"}\" ? { type: \"error\", message: 'Expected \"}\" after object', position: pos } : (pos++, marks.push({ name: \"object_end\", position: pos }), { type: \"success\", marks, position: pos });\n}\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{ name: \"str\", position: pos }];\n  str: for (; ; pos++) {\n    if (pos > str.length) return { type: \"error\", message: \"Unexpected end of query\", position: pos };\n    switch (str[pos]) {\n      case token: {\n        marks.push({ name: \"str_end\", position: pos }), pos++;\n        break str;\n      }\n      case \"\\\\\":\n        marks.push({ name: \"str_pause\", position: pos }), str[pos + 1] === \"u\" ? str[pos + 2] === \"{\" ? (marks.push({ name: \"unicode_hex\", position: pos + 3 }), pos = str.indexOf(\"}\", pos + 3), marks.push({ name: \"unicode_hex_end\", position: pos })) : (marks.push({ name: \"unicode_hex\", position: pos + 2 }), marks.push({ name: \"unicode_hex_end\", position: pos + 6 }), pos += 5) : (marks.push({ name: \"single_escape\", position: pos + 1 }), pos += 1), marks.push({ name: \"str_start\", position: pos + 1 });\n    }\n  }\n  return { type: \"success\", marks, position: pos };\n}\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null;\n}\nfunction join(a, b) {\n  return (base) => b(a(base));\n}\nfunction map(inner) {\n  return (base) => ({ type: \"Map\", base, expr: inner({ type: \"This\" }) });\n}\nfunction flatMap(inner) {\n  return (base) => ({ type: \"FlatMap\", base, expr: inner({ type: \"This\" }) });\n}\nfunction traverseArray(build, right) {\n  if (!right)\n    return {\n      type: \"a-a\",\n      build\n    };\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(build, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"a-a\",\n        build: join(build, map(right.build))\n      };\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, flatMap(right.build))\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traversePlain(mapper, right) {\n  if (!right)\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseElement(mapper, right) {\n  if (!right)\n    return {\n      type: \"a-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"a-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseProjection(mapper, right) {\n  if (!right)\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(map(mapper), right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(map(mapper), right.build)\n      };\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nconst ESCAPE_SEQUENCE = {\n  \"'\": \"'\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n  b: \"\\b\",\n  f: \"\\f\",\n  n: `\n`,\n  r: \"\\r\",\n  t: \"\t\"\n};\nfunction expandHex(str) {\n  const charCode = parseInt(str, 16);\n  return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n  name = \"GroqQueryError\";\n}\nconst EXPR_BUILDER = {\n  group(p) {\n    return {\n      type: \"Group\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  everything() {\n    return { type: \"Everything\" };\n  },\n  this() {\n    return { type: \"This\" };\n  },\n  parent() {\n    return {\n      type: \"Parent\",\n      n: 1\n    };\n  },\n  dblparent(p) {\n    return {\n      type: \"Parent\",\n      n: p.process(EXPR_BUILDER).n + 1\n    };\n  },\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER), traversalList = [];\n    for (; p.getMark().name !== \"traversal_end\"; )\n      traversalList.push(p.process(TRAVERSE_BUILDER));\n    p.shift();\n    let traversal = null;\n    for (let i = traversalList.length - 1; i >= 0; i--)\n      traversal = traversalList[i](traversal);\n    if ((base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") && (traversal = traverseArray((val) => val, traversal)), traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n    return traversal.build(base);\n  },\n  this_attr(p) {\n    const name = p.processString();\n    return name === \"null\" ? { type: \"Value\", value: null } : name === \"true\" ? { type: \"Value\", value: !0 } : name === \"false\" ? { type: \"Value\", value: !1 } : {\n      type: \"AccessAttribute\",\n      name\n    };\n  },\n  neg(p) {\n    return {\n      type: \"Neg\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  pos(p) {\n    return {\n      type: \"Pos\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  add(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"+\",\n      left,\n      right\n    };\n  },\n  sub(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"-\",\n      left,\n      right\n    };\n  },\n  mul(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"*\",\n      left,\n      right\n    };\n  },\n  div(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"/\",\n      left,\n      right\n    };\n  },\n  mod(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"%\",\n      left,\n      right\n    };\n  },\n  pow(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op: \"**\",\n      left,\n      right\n    };\n  },\n  comp(p) {\n    const left = p.process(EXPR_BUILDER), op = p.processString(), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"OpCall\",\n      op,\n      left,\n      right\n    };\n  },\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER), isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"InRange\",\n      base,\n      left,\n      right,\n      isInclusive\n    };\n  },\n  str(p) {\n    let value = \"\";\n    loop: for (; p.hasMark(); ) {\n      const mark = p.getMark();\n      switch (mark.name) {\n        case \"str_end\":\n          value += p.processStringEnd();\n          break loop;\n        case \"str_pause\":\n          value += p.processStringEnd();\n          break;\n        case \"str_start\":\n          p.shift();\n          break;\n        case \"single_escape\": {\n          const char = p.slice(1);\n          p.shift(), value += ESCAPE_SEQUENCE[char];\n          break;\n        }\n        case \"unicode_hex\":\n          p.shift(), value += expandHex(p.processStringEnd());\n          break;\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`);\n      }\n    }\n    return { type: \"Value\", value };\n  },\n  integer(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  float(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  sci(p) {\n    const strValue = p.processStringEnd();\n    return {\n      type: \"Value\",\n      value: Number(strValue)\n    };\n  },\n  object(p) {\n    const attributes = [];\n    for (; p.getMark().name !== \"object_end\"; )\n      attributes.push(p.process(OBJECT_BUILDER));\n    return p.shift(), {\n      type: \"Object\",\n      attributes\n    };\n  },\n  array(p) {\n    const elements = [];\n    for (; p.getMark().name !== \"array_end\"; ) {\n      let isSplat = !1;\n      p.getMark().name === \"array_splat\" && (isSplat = !0, p.shift());\n      const value = p.process(EXPR_BUILDER);\n      elements.push({\n        type: \"ArrayElement\",\n        value,\n        isSplat\n      });\n    }\n    return p.shift(), {\n      type: \"Array\",\n      elements\n    };\n  },\n  tuple(p) {\n    const members = [];\n    for (; p.getMark().name !== \"tuple_end\"; )\n      members.push(p.process(EXPR_BUILDER));\n    return p.shift(), {\n      type: \"Tuple\",\n      members\n    };\n  },\n  func_call(p) {\n    let namespace = \"global\";\n    p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString());\n    const name = p.processString();\n    if (namespace === \"global\" && name === \"select\") {\n      const result = {\n        type: \"Select\",\n        alternatives: []\n      };\n      for (; p.getMark().name !== \"func_args_end\"; )\n        if (p.getMark().name === \"pair\") {\n          if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n          p.shift();\n          const condition = p.process(EXPR_BUILDER), value = p.process(EXPR_BUILDER);\n          result.alternatives.push({\n            type: \"SelectAlternative\",\n            condition,\n            value\n          });\n        } else {\n          if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n          const value = p.process(EXPR_BUILDER);\n          result.fallback = value;\n        }\n      return p.shift(), result;\n    }\n    const args = [];\n    for (; p.getMark().name !== \"func_args_end\"; )\n      argumentShouldBeSelector(namespace, name, args.length) ? args.push(p.process(SELECTOR_BUILDER)) : args.push(p.process(EXPR_BUILDER));\n    if (p.shift(), namespace === \"global\" && (name === \"before\" || name === \"after\") && p.parseOptions.mode === \"delta\")\n      return {\n        type: \"Context\",\n        key: name\n      };\n    if (namespace === \"global\" && name === \"boost\" && !p.allowBoost)\n      throw new GroqQueryError(\"unexpected boost\");\n    const funcs = namespaces[namespace];\n    if (!funcs)\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    const func = funcs[name];\n    if (!func)\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    if (func.arity !== void 0 && validateArity(name, func.arity, args.length), func.mode !== void 0 && func.mode !== p.parseOptions.mode)\n      throw new GroqQueryError(`Undefined function: ${name}`);\n    return {\n      type: \"FuncCall\",\n      func,\n      namespace,\n      name,\n      args\n    };\n  },\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER);\n    p.shift();\n    let namespace = \"global\";\n    if (p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString()), namespace !== \"global\")\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n    const name = p.processString(), args = [], oldAllowBoost = p.allowBoost;\n    for (name === \"score\" && (p.allowBoost = !0); ; ) {\n      const markName = p.getMark().name;\n      if (markName === \"func_args_end\")\n        break;\n      if (name === \"order\") {\n        if (markName === \"asc\") {\n          p.shift(), args.push({ type: \"Asc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        } else if (markName === \"desc\") {\n          p.shift(), args.push({ type: \"Desc\", base: p.process(EXPR_BUILDER) });\n          continue;\n        }\n      }\n      args.push(p.process(EXPR_BUILDER));\n    }\n    p.shift(), p.allowBoost = oldAllowBoost;\n    const func = pipeFunctions[name];\n    if (!func)\n      throw new GroqQueryError(`Undefined pipe function: ${name}`);\n    return func.arity && validateArity(name, func.arity, args.length), {\n      type: \"PipeFuncCall\",\n      func,\n      base,\n      name,\n      args\n    };\n  },\n  pair() {\n    throw new GroqQueryError(\"unexpected =>\");\n  },\n  and(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"And\",\n      left,\n      right\n    };\n  },\n  or(p) {\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n    return {\n      type: \"Or\",\n      left,\n      right\n    };\n  },\n  not(p) {\n    return {\n      type: \"Not\",\n      base: p.process(EXPR_BUILDER)\n    };\n  },\n  asc() {\n    throw new GroqQueryError(\"unexpected asc\");\n  },\n  desc() {\n    throw new GroqQueryError(\"unexpected desc\");\n  },\n  param(p) {\n    const name = p.processString();\n    return p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name) ? {\n      type: \"Value\",\n      value: p.parseOptions.params[name]\n    } : {\n      type: \"Parameter\",\n      name\n    };\n  }\n}, OBJECT_BUILDER = {\n  object_expr(p) {\n    if (p.getMark().name === \"pair\") {\n      p.shift();\n      const condition = p.process(EXPR_BUILDER), value2 = p.process(EXPR_BUILDER);\n      return {\n        type: \"ObjectConditionalSplat\",\n        condition,\n        value: value2\n      };\n    }\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: extractPropertyKey(value),\n      value\n    };\n  },\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER);\n    if (name.type !== \"Value\") throw new Error(\"name must be string\");\n    const value = p.process(EXPR_BUILDER);\n    return {\n      type: \"ObjectAttributeValue\",\n      name: name.value,\n      value\n    };\n  },\n  object_splat(p) {\n    return {\n      type: \"ObjectSplat\",\n      value: p.process(EXPR_BUILDER)\n    };\n  },\n  object_splat_this() {\n    return {\n      type: \"ObjectSplat\",\n      value: { type: \"This\" }\n    };\n  }\n}, TRAVERSE_BUILDER = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER), value = tryConstantEvaluate(expr);\n    return value && value.type === \"number\" ? (right) => traverseElement((base) => ({ type: \"AccessElement\", base, index: value.data }), right) : value && value.type === \"string\" ? (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name: value.data }), right) : (right) => traverseArray(\n      (base) => ({\n        type: \"Filter\",\n        base,\n        expr\n      }),\n      right\n    );\n  },\n  slice(p) {\n    const isInclusive = p.getMark().name === \"inc_range\";\n    p.shift();\n    const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER), leftValue = tryConstantEvaluate(left), rightValue = tryConstantEvaluate(right);\n    if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\")\n      throw new GroqQueryError(\"slicing must use constant numbers\");\n    return (rhs) => traverseArray(\n      (base) => ({\n        type: \"Slice\",\n        base,\n        left: leftValue.data,\n        right: rightValue.data,\n        isInclusive\n      }),\n      rhs\n    );\n  },\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER);\n    return (right) => traverseProjection((base) => ({ type: \"Projection\", base, expr: obj }), right);\n  },\n  attr_access(p) {\n    const name = p.processString();\n    return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name }), right);\n  },\n  deref(p) {\n    let attr = null;\n    p.getMark().name === \"deref_attr\" && (p.shift(), attr = p.processString());\n    const wrap = (base) => attr ? { type: \"AccessAttribute\", base, name: attr } : base;\n    return (right) => traversePlain(\n      (base) => wrap({\n        type: \"Deref\",\n        base\n      }),\n      right\n    );\n  },\n  array_postfix() {\n    return (right) => traverseArray((base) => ({ type: \"ArrayCoerce\", base }), right);\n  }\n}, SELECTOR_BUILDER = {\n  group(p) {\n    return p.process(SELECTOR_BUILDER);\n  },\n  everything() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  this() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  parent() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  dblparent() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  traverse(p) {\n    let node = p.process(SELECTOR_BUILDER);\n    for (; p.getMark().name !== \"traversal_end\"; )\n      if (p.getMark().name === \"array_postfix\")\n        p.shift(), node = { type: \"ArrayCoerce\", base: node };\n      else if (p.getMark().name === \"square_bracket\") {\n        p.shift();\n        const expr = p.process(EXPR_BUILDER), value = tryConstantEvaluate(expr);\n        if (value && value.type === \"number\")\n          throw new Error(\"Invalid array access expression\");\n        value && value.type === \"string\" ? node = { type: \"AccessAttribute\", base: node, name: value.data } : node = { type: \"Filter\", base: node, expr };\n      } else if (p.getMark().name === \"attr_access\") {\n        p.shift();\n        const name = p.processString();\n        node = { type: \"AccessAttribute\", base: node, name };\n      } else if (p.getMark().name === \"tuple\" || p.getMark().name === \"group\") {\n        const selector = p.process(SELECTOR_BUILDER);\n        if (!isSelectorNested(selector))\n          throw new Error(`Unexpected result parsing nested selector: ${selector.type}`);\n        node = { type: \"SelectorNested\", base: node, nested: selector };\n      } else\n        throw new Error(\"Invalid selector syntax\");\n    return p.shift(), node;\n  },\n  this_attr(p) {\n    return { type: \"AccessAttribute\", name: p.processString() };\n  },\n  attr_access() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  neg() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pos() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  add() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sub() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mul() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  div() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  mod() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pow() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  comp() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  in_range() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  str() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  integer() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  float() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  sci() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  object() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  array() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  tuple(p) {\n    const selectors = [];\n    for (; p.getMark().name !== \"tuple_end\"; )\n      selectors.push(p.process(SELECTOR_BUILDER));\n    return p.shift(), { type: \"Tuple\", members: selectors };\n  },\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark);\n    if (func.name === \"anywhere\" && func.args.length === 1)\n      return {\n        type: \"SelectorFuncCall\",\n        name: \"anywhere\",\n        arg: func.args[0]\n      };\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pipecall() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  pair() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  and() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  or() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  not() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  asc() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  desc() {\n    throw new Error(\"Invalid selector syntax\");\n  },\n  param() {\n    throw new Error(\"Invalid selector syntax\");\n  }\n};\nfunction extractPropertyKey(node) {\n  if (node.type === \"AccessAttribute\" && !node.base)\n    return node.name;\n  if (node.type === \"PipeFuncCall\" || node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\" || node.type === \"Group\")\n    return extractPropertyKey(node.base);\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);\n}\nfunction validateArity(name, arity, count) {\n  if (typeof arity == \"number\") {\n    if (count !== arity)\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`\n      );\n  } else if (arity && !arity(count))\n    throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n  const functionsRequiringSelectors = [\"changedAny\", \"changedOnly\"];\n  return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n  position;\n  name = \"GroqSyntaxError\";\n  constructor(position, detail) {\n    super(`Syntax error in GROQ query at position ${position}${detail ? \": \" + detail : \"\"}`), this.position = position;\n  }\n}\nfunction parse(input, options = {}) {\n  const result = parse$1(input);\n  if (result.type === \"error\")\n    throw new GroqSyntaxError(result.position, result.message);\n  return new MarkProcessor(input, result.marks, options).process(EXPR_BUILDER);\n}\nconst { compare } = new Intl.Collator(\"en\");\nfunction typeNodesSorter(a, b) {\n  return a.type === \"null\" ? 1 : compare(hashField(a), hashField(b));\n}\nconst hashCache = /* @__PURE__ */ new WeakMap();\nfunction hashField(field) {\n  if (hashCache.has(field))\n    return hashCache.get(field);\n  const hash = calculateFieldHash(field);\n  return hashCache.set(field, hash), hash;\n}\nfunction calculateFieldHash(field) {\n  switch (field.type) {\n    case \"string\":\n    case \"number\":\n    case \"boolean\":\n      return field.value !== void 0 ? `${field.type}(${field.value})` : `${field.type}`;\n    case \"null\":\n    case \"unknown\":\n      return field.type;\n    case \"array\":\n      return `${field.type}(${hashField(field.of)})`;\n    case \"object\": {\n      const attributes = Object.entries(field.attributes);\n      return attributes.sort(([a], [b]) => compare(a, b)), `${field.type}:(${attributes.map(\n        ([key, value]) => `${key}:${hashField(value.value)}(${value.optional ? \"optional\" : \"non-optional\"})`\n      ).join(\",\")}):ref-${field.dereferencesTo}:${field.rest ? hashField(field.rest) : \"no-rest\"}`;\n    }\n    case \"union\": {\n      const sorted = [...field.of];\n      return sorted.sort(typeNodesSorter), `${field.type}(${sorted.map(hashField).join(\",\")})`;\n    }\n    case \"inline\":\n      return `${field.type}(${field.name})`;\n    default:\n      return field.type;\n  }\n}\nfunction removeDuplicateTypeNodes(typeNodes) {\n  const seenTypes = /* @__PURE__ */ new Set(), newTypeNodes = [], sortedTypeNodes = [...typeNodes];\n  sortedTypeNodes.sort(typeNodesSorter);\n  for (const typeNode of sortedTypeNodes) {\n    const hash = hashField(typeNode);\n    if (hash === null) {\n      newTypeNodes.push(typeNode);\n      continue;\n    }\n    seenTypes.has(hash) || (seenTypes.add(hash), newTypeNodes.push(typeNode));\n  }\n  return newTypeNodes;\n}\nfunction optimizeUnions(field) {\n  if (field.type === \"union\") {\n    if (field.of.length === 0)\n      return field;\n    if (field.of = removeDuplicateTypeNodes(field.of), field.of.length === 1)\n      return optimizeUnions(field.of[0]);\n    for (let idx = 0; field.of.length > idx; idx++) {\n      const subField = field.of[idx];\n      if (subField.type === \"union\") {\n        field.of.splice(idx, 1, ...subField.of), idx--;\n        continue;\n      }\n      field.of[idx] = optimizeUnions(subField);\n    }\n    return field.of.sort((a, b) => a.type === \"null\" ? 1 : compare(hashField(a), hashField(b))), field;\n  }\n  if (field.type === \"array\")\n    return field.of = optimizeUnions(field.of), field;\n  if (field.type === \"object\") {\n    for (const idx in field.attributes)\n      Object.hasOwn(field.attributes, idx) && (field.attributes[idx].value = optimizeUnions(field.attributes[idx].value));\n    return field;\n  }\n  return field;\n}\nfunction createReferenceTypeNode(name, inArray = !1) {\n  const attributes = {\n    _ref: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"string\"\n      }\n    },\n    _type: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"string\",\n        value: \"reference\"\n      }\n    },\n    _weak: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"boolean\"\n      },\n      optional: !0\n    }\n  };\n  return inArray && (attributes._key = {\n    type: \"objectAttribute\",\n    value: {\n      type: \"string\"\n    }\n  }), {\n    type: \"object\",\n    attributes,\n    dereferencesTo: name\n  };\n}\nfunction nullUnion(node) {\n  return node.type === \"union\" ? unionOf(...node.of, { type: \"null\" }) : unionOf(node, { type: \"null\" });\n}\nfunction unionOf(...nodes) {\n  return {\n    type: \"union\",\n    of: nodes\n  };\n}\nfunction resolveInline(node, scope) {\n  if (node.type === \"inline\") {\n    const resolvedInline = scope.context.lookupTypeDeclaration(node);\n    return resolveInline(resolvedInline, scope);\n  }\n  return node;\n}\nfunction mapNode(node, scope, mapper, mergeUnions = (nodes) => optimizeUnions({ type: \"union\", of: nodes })) {\n  switch (node.type) {\n    case \"boolean\":\n    case \"array\":\n    case \"null\":\n    case \"object\":\n    case \"string\":\n    case \"number\":\n    case \"unknown\":\n      return mapper(node);\n    case \"union\":\n      return mergeUnions(node.of.map((inner) => mapNode(inner, scope, mapper), mergeUnions));\n    case \"inline\": {\n      const resolvedInline = resolveInline(node, scope);\n      return mapNode(resolvedInline, scope, mapper, mergeUnions);\n    }\n    default:\n      throw new Error(`Unknown type: ${node.type}`);\n  }\n}\nfunction isFuncCall(node, name) {\n  return node.type === \"Group\" ? isFuncCall(node.base, name) : node.type === \"FuncCall\" && `${node.namespace}::${node.name}` === name;\n}\nfunction createGeoJson(type = \"Point\") {\n  let coordinateAttribute = {\n    type: \"array\",\n    of: {\n      type: \"number\"\n    }\n  };\n  return type === \"LineString\" && (coordinateAttribute = {\n    type: \"array\",\n    of: {\n      type: \"array\",\n      of: {\n        type: \"number\"\n      }\n    }\n  }), type === \"Polygon\" && (coordinateAttribute = {\n    type: \"array\",\n    of: {\n      type: \"array\",\n      of: {\n        type: \"array\",\n        of: {\n          type: \"number\"\n        }\n      }\n    }\n  }), {\n    type: \"object\",\n    attributes: {\n      type: {\n        type: \"objectAttribute\",\n        value: {\n          type: \"string\",\n          value: type\n        }\n      },\n      coordinates: {\n        type: \"objectAttribute\",\n        value: coordinateAttribute\n      }\n    }\n  };\n}\nfunction booleanValue(node, scope) {\n  switch (node.type) {\n    case \"unknown\":\n      return { canBeTrue: !0, canBeFalse: !0, canBeNull: !0 };\n    case \"boolean\":\n      return node.value === !0 ? { canBeTrue: !0, canBeFalse: !1, canBeNull: !1 } : node.value === !1 ? { canBeTrue: !1, canBeFalse: !0, canBeNull: !1 } : { canBeTrue: !0, canBeFalse: !0, canBeNull: !1 };\n    case \"union\": {\n      const value = { canBeTrue: !1, canBeFalse: !1, canBeNull: !1 };\n      for (const sub of node.of) {\n        const match2 = booleanValue(sub, scope);\n        match2.canBeNull && (value.canBeNull = !0), match2.canBeTrue && (value.canBeTrue = !0), match2.canBeFalse && (value.canBeFalse = !0);\n      }\n      return value;\n    }\n    case \"inline\": {\n      const resolved = resolveInline(node, scope);\n      return booleanValue(resolved, scope);\n    }\n    case \"null\":\n    case \"string\":\n    case \"number\":\n    case \"object\":\n    case \"array\":\n      return { canBeTrue: !1, canBeFalse: !1, canBeNull: !0 };\n    default:\n      throw new Error(`unknown node type ${node.type}`);\n  }\n}\nfunction booleanOr(left, right) {\n  return left.canBeTrue && !left.canBeFalse && !left.canBeNull ? left : right.canBeTrue && !right.canBeFalse && !right.canBeNull ? right : {\n    // Either side can be true for the expression to be true\n    canBeTrue: left.canBeTrue || right.canBeTrue,\n    // Both sides must be false for the expression to be false\n    canBeFalse: left.canBeFalse && right.canBeFalse,\n    // if either side can be null, the expression can be null if the other side can't only be true\n    canBeNull: left.canBeNull || right.canBeNull\n  };\n}\nfunction booleanAnd(left, right) {\n  return left.canBeFalse && !left.canBeTrue && !left.canBeNull ? left : right.canBeFalse && !right.canBeTrue && !right.canBeNull ? right : {\n    // Both sides must be true for the expression to be true\n    canBeTrue: left.canBeTrue && right.canBeTrue,\n    // if either side can be false, the expression can be false\n    canBeFalse: left.canBeFalse || right.canBeFalse,\n    // if either side can be null, the expression can be null\n    canBeNull: left.canBeNull || right.canBeNull\n  };\n}\nfunction booleanInterpretationToTypeNode(bool) {\n  return bool.canBeTrue ? bool.canBeFalse ? bool.canBeNull ? nullUnion({ type: \"boolean\" }) : { type: \"boolean\" } : bool.canBeNull ? nullUnion({ type: \"boolean\", value: !0 }) : { type: \"boolean\", value: !0 } : bool.canBeFalse ? bool.canBeNull ? nullUnion({ type: \"boolean\", value: !1 }) : { type: \"boolean\", value: !1 } : { type: \"null\" };\n}\nfunction unionWithoutNull(unionTypeNode) {\n  return unionTypeNode.type === \"union\" ? {\n    type: \"union\",\n    of: unionTypeNode.of.filter((type) => type.type !== \"null\")\n  } : unionTypeNode;\n}\nfunction handleFuncCallNode(node, scope) {\n  switch (`${node.namespace}.${node.name}`) {\n    case \"array.compact\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => {\n        if (arg2.type === \"unknown\")\n          return nullUnion({ type: \"array\", of: { type: \"unknown\" } });\n        if (arg2.type !== \"array\")\n          return { type: \"null\" };\n        const of = mapNode(arg2.of, scope, (of2) => of2);\n        return {\n          type: \"array\",\n          of: unionWithoutNull(of)\n        };\n      });\n    }\n    case \"array.join\": {\n      const arrayArg = walk({ node: node.args[0], scope }), sepArg = walk({ node: node.args[1], scope });\n      return mapNode(\n        arrayArg,\n        scope,\n        (arrayArg2) => mapNode(sepArg, scope, (sepArg2) => arrayArg2.type === \"unknown\" || sepArg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arrayArg2.type !== \"array\" || sepArg2.type !== \"string\" ? { type: \"null\" } : mapNode(arrayArg2.of, scope, (of) => of.type === \"unknown\" ? nullUnion({ type: \"string\" }) : of.type !== \"string\" && of.type !== \"number\" && of.type !== \"boolean\" ? { type: \"null\" } : { type: \"string\" }))\n      );\n    }\n    case \"array.unique\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"array\", of: { type: \"unknown\" } }) : arg2.type !== \"array\" ? { type: \"null\" } : arg2);\n    }\n    case \"array.intersects\": {\n      const arg1 = walk({ node: node.args[0], scope }), arg2 = walk({ node: node.args[1], scope });\n      return mapNode(\n        arg1,\n        scope,\n        (arg12) => mapNode(arg2, scope, (arg22) => arg12.type !== \"array\" ? { type: \"null\" } : arg22.type !== \"array\" ? { type: \"null\" } : { type: \"boolean\" })\n      );\n    }\n    case \"global.lower\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type !== \"string\" ? { type: \"null\" } : arg2.value !== void 0 ? {\n        type: \"string\",\n        value: arg2.value.toLowerCase()\n      } : { type: \"string\" });\n    }\n    case \"global.upper\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type !== \"string\" ? { type: \"null\" } : arg2.value !== void 0 ? {\n        type: \"string\",\n        value: arg2.value.toUpperCase()\n      } : { type: \"string\" });\n    }\n    case \"dateTime.now\":\n      return { type: \"string\" };\n    case \"global.now\":\n      return { type: \"string\" };\n    case \"global.defined\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (node2) => node2.type === \"unknown\" ? { type: \"boolean\" } : { type: \"boolean\", value: node2.type !== \"null\" });\n    }\n    case \"global.path\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type === \"string\" ? { type: \"string\" } : { type: \"null\" });\n    }\n    case \"global.coalesce\": {\n      if (node.args.length === 0)\n        return { type: \"null\" };\n      const typeNodes = [];\n      let canBeNull = !0;\n      for (const arg of node.args) {\n        const argNode = optimizeUnions(walk({ node: arg, scope })), allNull = argNode.type === \"null\" || argNode.type === \"union\" && argNode.of.every((t) => t.type === \"null\");\n        if (canBeNull = allNull || argNode.type === \"unknown\" || argNode.type === \"union\" && argNode.of.some((t) => t.type === \"null\" || t.type === \"unknown\"), allNull || typeNodes.push(unionWithoutNull(argNode)), !canBeNull)\n          break;\n      }\n      return canBeNull && typeNodes.push({ type: \"null\" }), {\n        type: \"union\",\n        of: typeNodes\n      };\n    }\n    case \"global.count\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type === \"array\" ? { type: \"number\" } : { type: \"null\" });\n    }\n    case \"global.dateTime\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type === \"string\" ? nullUnion({ type: \"string\" }) : { type: \"null\" });\n    }\n    case \"global.length\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : arg2.type === \"array\" || arg2.type === \"string\" ? { type: \"number\" } : { type: \"null\" });\n    }\n    case \"global.references\":\n      return { type: \"boolean\" };\n    case \"global.round\": {\n      const numNode = walk({ node: node.args[0], scope });\n      return mapNode(numNode, scope, (num) => {\n        if (num.type === \"unknown\")\n          return nullUnion({ type: \"number\" });\n        if (num.type !== \"number\")\n          return { type: \"null\" };\n        if (node.args.length === 2) {\n          const precisionNode = walk({ node: node.args[1], scope });\n          return mapNode(precisionNode, scope, (precision) => precision.type === \"unknown\" ? nullUnion({ type: \"number\" }) : precision.type !== \"number\" ? { type: \"null\" } : { type: \"number\" });\n        }\n        return { type: \"number\" };\n      });\n    }\n    case \"global.string\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : node2.type === \"string\" || node2.type === \"number\" || node2.type === \"boolean\" ? node2.value ? {\n        type: \"string\",\n        value: node2.value.toString()\n      } : {\n        type: \"string\"\n      } : { type: \"null\" });\n    }\n    case \"math.sum\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" || node3.type === \"null\" ? { type: \"number\" } : { type: \"null\" }));\n    }\n    case \"math.avg\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" ? { type: \"number\" } : { type: \"null\" }));\n    }\n    case \"math.max\":\n    case \"math.min\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" ? node3 : { type: \"null\" }));\n    }\n    case \"pt.text\":\n      return node.args.length === 0 ? { type: \"null\" } : {\n        type: \"string\"\n      };\n    case \"string.startsWith\": {\n      const strTypeNode = walk({ node: node.args[0], scope }), prefixTypeNode = walk({ node: node.args[1], scope });\n      return mapNode(strTypeNode, scope, (strNode) => mapNode(prefixTypeNode, scope, (prefixNode) => strNode.type === \"unknown\" || prefixNode.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : strNode.type !== \"string\" || prefixNode.type !== \"string\" ? { type: \"null\" } : { type: \"boolean\" }));\n    }\n    case \"string.split\": {\n      const strTypeNode = walk({ node: node.args[0], scope }), sepTypeNode = walk({ node: node.args[1], scope });\n      return mapNode(strTypeNode, scope, (strNode) => mapNode(sepTypeNode, scope, (sepNode) => strNode.type === \"unknown\" || sepNode.type === \"unknown\" ? nullUnion({ type: \"array\", of: { type: \"string\" } }) : strNode.type !== \"string\" || sepNode.type !== \"string\" ? { type: \"null\" } : { type: \"array\", of: { type: \"string\" } }));\n    }\n    case \"geo.latLng\": {\n      const latTypeNode = walk({ node: node.args[0], scope }), lngTypeNode = walk({ node: node.args[1], scope });\n      return mapNode(latTypeNode, scope, (latNode) => mapNode(lngTypeNode, scope, (lngNode) => latNode.type == \"unknown\" || lngNode.type == \"unknown\" ? nullUnion(createGeoJson()) : latNode.type !== \"number\" || lngNode.type !== \"number\" ? { type: \"null\" } : nullUnion(createGeoJson())));\n    }\n    case \"geo.contains\":\n      return nullUnion({ type: \"boolean\" });\n    case \"geo.intersects\":\n      return nullUnion({ type: \"boolean\" });\n    case \"geo.distance\":\n      return nullUnion({ type: \"number\" });\n    case \"sanity.versionOf\": {\n      const typeNode = walk({ node: node.args[0], scope });\n      return mapNode(typeNode, scope, (typeNode2) => typeNode2.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : typeNode2.type !== \"string\" ? { type: \"null\" } : { type: \"boolean\" });\n    }\n    case \"sanity.partOfRelease\": {\n      const typeNode = walk({ node: node.args[0], scope });\n      return mapNode(typeNode, scope, (typeNode2) => typeNode2.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : typeNode2.type !== \"string\" ? { type: \"null\" } : { type: \"boolean\" });\n    }\n    case \"documents.get\": {\n      const typeNode = walk({ node: node.args[0], scope });\n      return mapNode(typeNode, scope, (typeNode2) => typeNode2.type === \"unknown\" ? typeNode2 : typeNode2.type !== \"object\" ? { type: \"null\" } : { type: \"unknown\" });\n    }\n    default:\n      return { type: \"unknown\" };\n  }\n}\nfunction match(left, right) {\n  let tokens = [], patterns = [];\n  if (left.type === \"string\") {\n    if (left.value === void 0)\n      return;\n    tokens = tokens.concat(matchTokenize(left.value));\n  }\n  if (left.type === \"array\") {\n    if (left.of.type === \"unknown\")\n      return;\n    if (left.of.type === \"string\") {\n      if (left.of.value === void 0)\n        return;\n      tokens = tokens.concat(matchTokenize(left.of.value));\n    }\n    if (left.of.type === \"union\")\n      for (const node of left.of.of)\n        node.type === \"string\" && node.value !== void 0 && (tokens = tokens.concat(matchTokenize(node.value)));\n  }\n  if (right.type === \"string\") {\n    if (right.value === void 0)\n      return;\n    patterns = patterns.concat(matchAnalyzePattern(right.value));\n  }\n  if (right.type === \"array\") {\n    if (right.of.type === \"unknown\")\n      return;\n    if (right.of.type === \"string\") {\n      if (right.of.value === void 0)\n        return;\n      patterns = patterns.concat(matchAnalyzePattern(right.of.value));\n    }\n    if (right.of.type === \"union\")\n      for (const node of right.of.of) {\n        if (node.type === \"string\") {\n          if (node.value === void 0)\n            return;\n          patterns = patterns.concat(matchAnalyzePattern(node.value));\n        }\n        if (node.type !== \"string\")\n          return !1;\n      }\n  }\n  return matchText(tokens, patterns);\n}\nconst $trace$1 = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:scope:trace\");\n$trace$1.log = console.log.bind(console);\nclass Context {\n  schema;\n  constructor(schema) {\n    this.schema = schema;\n  }\n  lookupRef(refTo) {\n    for (const val of this.schema)\n      if (val.type === \"document\" && val.name === refTo)\n        return {\n          type: \"object\",\n          attributes: val.attributes\n        };\n    return { type: \"null\" };\n  }\n  lookupTypeDeclaration(alias) {\n    for (const val of this.schema)\n      if (val.type === \"type\" && val.name === alias.name)\n        return val.value;\n    return { type: \"null\" };\n  }\n}\nclass Scope2 {\n  value;\n  parent;\n  context;\n  isHidden;\n  constructor(value, parent, context) {\n    this.value = { type: \"union\", of: value }, this.parent = parent, this.context = context || parent?.context || new Context([]), this.isHidden = !1;\n  }\n  createNested(value) {\n    return this.isHidden ? new Scope2(value, this.parent, this.context) : new Scope2(value, this, this.context);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    return result.isHidden = !0, result;\n  }\n}\nconst $trace = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:trace\");\n$trace.log = console.log.bind(console);\nconst $debug = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:debug\");\n$debug.log = console.log.bind(console);\nconst $warn = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:warn\");\nfunction typeEvaluate(ast, schema) {\n  $debug(\"evaluateQueryType.ast %O\", ast), $debug(\"evaluateQueryType.schema %O\", schema);\n  const parsed = walk({\n    node: ast,\n    scope: new Scope2([], void 0, new Context(schema))\n  });\n  $trace(\"evaluateQueryType.parsed %O\", parsed);\n  const optimized = optimizeUnions(parsed);\n  return $debug(\"evaluateQueryType.optimized %O\", optimized), optimized;\n}\nfunction mapDeref(node, scope) {\n  return mapNode(node, scope, (base) => {\n    if (base.type === \"array\")\n      return {\n        type: \"array\",\n        of: mapDeref(base.of, scope)\n      };\n    if (base.type === \"object\") {\n      if (base.dereferencesTo !== void 0)\n        return scope.context.lookupRef(base.dereferencesTo);\n      if (base.rest !== void 0)\n        return mapDeref(resolveInline(base.rest, scope), scope);\n    }\n    return { type: \"null\" };\n  });\n}\nfunction handleDerefNode(node, scope) {\n  $trace(\"deref.node %O\", node);\n  const derefedNode = mapDeref(walk({ node: node.base, scope }), scope);\n  return $trace(\"deref.derefedNode %O\", derefedNode), derefedNode;\n}\nfunction handleObjectSplatNode(attr, scope) {\n  const value = walk({ node: attr.value, scope });\n  return $trace(\"object.splat.value %O\", value), mapNode(value, scope, (node) => {\n    if (node.type === \"unknown\")\n      return { type: \"unknown\" };\n    if (node.type !== \"object\")\n      return { type: \"object\", attributes: {} };\n    const attributes = {};\n    for (const name in node.attributes)\n      node.attributes.hasOwnProperty(name) && (attributes[name] = node.attributes[name]);\n    if (node.rest !== void 0) {\n      const resolvedRest = resolveInline(node.rest, scope);\n      if (resolvedRest.type === \"unknown\")\n        return { type: \"unknown\" };\n      if (resolvedRest.type !== \"object\")\n        return { type: \"null\" };\n      for (const name in resolvedRest.attributes)\n        resolvedRest.attributes.hasOwnProperty(name) && (attributes[name] = resolvedRest.attributes[name]);\n    }\n    return { type: \"object\", attributes };\n  });\n}\nfunction handleObjectNode(node, scope) {\n  if ($trace(\"object.node %O\", node), node.attributes.length === 0)\n    return {\n      type: \"object\",\n      attributes: {}\n    };\n  const objectAttributes = [], splatVariants = [], conditionalVariants = [];\n  for (const [idx, attr] of node.attributes.entries()) {\n    if (attr.type === \"ObjectAttributeValue\") {\n      const attributeNode = walk({ node: attr.value, scope });\n      objectAttributes.push([\n        idx,\n        attr.name,\n        {\n          type: \"objectAttribute\",\n          value: attributeNode\n        }\n      ]);\n      continue;\n    }\n    if (attr.type === \"ObjectSplat\") {\n      const attributeNode = handleObjectSplatNode(attr, scope);\n      switch ($trace(\"object.splat.result %O\", attributeNode), attributeNode.type) {\n        case \"object\": {\n          splatVariants.push([idx, attributeNode]);\n          continue;\n        }\n        case \"union\": {\n          for (const node2 of attributeNode.of)\n            if (node2.type === \"unknown\")\n              return node2;\n          splatVariants.push([idx, attributeNode]);\n          continue;\n        }\n        default:\n          return { type: \"unknown\" };\n      }\n    }\n    if (attr.type === \"ObjectConditionalSplat\") {\n      const condition = booleanValue(walk({ node: attr.condition, scope }), scope);\n      if ($trace(\"object.conditional.splat.condition %O\", condition), condition.canBeTrue === !1)\n        continue;\n      const attributeNode = handleObjectSplatNode(attr, scope);\n      if ($trace(\"object.conditional.splat.result %O\", attributeNode), condition.canBeFalse === !1 && condition.canBeNull === !1)\n        switch (attributeNode.type) {\n          case \"object\": {\n            splatVariants.push([idx, attributeNode]);\n            continue;\n          }\n          case \"union\": {\n            for (const node2 of attributeNode.of)\n              if (node2.type !== \"object\")\n                return { type: \"unknown\" };\n            splatVariants.push([idx, attributeNode]);\n            continue;\n          }\n          default:\n            return { type: \"unknown\" };\n        }\n      const variant = mapNode(attributeNode, scope, (attributeNode2) => ($trace(\"object.conditional.splat.result.concrete %O\", attributeNode2), attributeNode2.type !== \"object\" ? { type: \"unknown\" } : {\n        type: \"object\",\n        attributes: attributeNode2.attributes\n      }));\n      if (variant.type === \"union\") {\n        for (const node2 of variant.of)\n          if (node2.type !== \"object\")\n            return { type: \"unknown\" };\n        variant.of.push({ type: \"object\", attributes: {} }), conditionalVariants.push([idx, variant]);\n        continue;\n      }\n      if (variant.type !== \"object\")\n        return { type: \"unknown\" };\n      conditionalVariants.push([\n        idx,\n        {\n          type: \"union\",\n          of: [{ type: \"object\", attributes: {} }, variant]\n        }\n      ]);\n      continue;\n    }\n    throw new Error(`Unknown object attribute type: ${attr.type}`);\n  }\n  const guaranteedAttributes = [];\n  guaranteedAttributes.push(...objectAttributes);\n  for (const [idx, splatNode] of splatVariants) {\n    if (splatNode.type === \"object\") {\n      for (const name in splatNode.attributes) {\n        if (!splatNode.attributes.hasOwnProperty(name))\n          continue;\n        const attribute = splatNode.attributes[name];\n        guaranteedAttributes.push([idx, name, attribute]);\n      }\n      continue;\n    }\n    conditionalVariants.push([idx, splatNode]);\n  }\n  if (guaranteedAttributes.sort(([a], [b]) => a - b), conditionalVariants.length === 0)\n    return {\n      type: \"object\",\n      attributes: Object.fromEntries(\n        guaranteedAttributes.map(([, name, attribute]) => [name, attribute])\n      )\n    };\n  const matrix = [];\n  for (const [unionIdx, union] of conditionalVariants) {\n    const unionGuaranteedBefore = [], unionGuaranteedAfter = [];\n    for (const [guaranteedIndex, name, attribute] of guaranteedAttributes)\n      guaranteedIndex < unionIdx && unionGuaranteedBefore.push([guaranteedIndex, name, attribute]), guaranteedIndex > unionIdx && unionGuaranteedAfter.push([guaranteedIndex, name, attribute]);\n    const allVariantsAttributes = [];\n    for (const [conditionalVariantIdx, otherUnion] of conditionalVariants) {\n      const variantAttributes = [];\n      for (const node2 of otherUnion.of)\n        variantAttributes.push(node2.attributes);\n      allVariantsAttributes.push([conditionalVariantIdx, variantAttributes]);\n    }\n    for (const node2 of union.of) {\n      matrix.push({\n        type: \"object\",\n        attributes: {\n          ...Object.fromEntries(\n            unionGuaranteedBefore.map(([, name, attribute]) => [name, attribute])\n          ),\n          ...node2.attributes,\n          ...Object.fromEntries(\n            unionGuaranteedAfter.map(([, name, attribute]) => [name, attribute])\n          )\n        }\n      });\n      for (const [outerIdx, outerAttributes] of allVariantsAttributes)\n        for (const outer of outerAttributes)\n          for (const [innerIdx, innerAttributes] of allVariantsAttributes)\n            if (outerIdx !== innerIdx)\n              for (const inner of innerAttributes) {\n                const _before = [...unionGuaranteedBefore], _after = [...unionGuaranteedAfter];\n                for (const name in outer)\n                  outer.hasOwnProperty(name) && outerIdx !== unionIdx && (outerIdx < unionIdx && _before.push([outerIdx, name, outer[name]]), outerIdx > unionIdx && _after.push([outerIdx, name, outer[name]]));\n                for (const name in inner)\n                  inner.hasOwnProperty(name) && outerIdx !== unionIdx && (innerIdx < unionIdx && _before.push([innerIdx, name, inner[name]]), innerIdx > unionIdx && _after.push([innerIdx, name, inner[name]]));\n                _before.sort(([a], [b]) => a - b), _after.sort(([a], [b]) => a - b);\n                const before = Object.fromEntries(\n                  _before.map(([, name, attribute]) => [name, attribute])\n                ), after = Object.fromEntries(\n                  _after.map(([, name, attribute]) => [name, attribute])\n                );\n                matrix.push({\n                  type: \"object\",\n                  attributes: {\n                    ...before,\n                    ...node2.attributes,\n                    ...after\n                  }\n                });\n              }\n    }\n  }\n  return optimizeUnions({\n    type: \"union\",\n    of: matrix\n  });\n}\nfunction handleOpCallNode(node, scope) {\n  $trace(\"opcall.node %O\", node);\n  const lhs = walk({ node: node.left, scope }), rhs = walk({ node: node.right, scope });\n  return mapNode(\n    lhs,\n    scope,\n    (left) => (\n      // eslint-disable-next-line complexity, max-statements\n      mapNode(rhs, scope, (right) => {\n        switch ($trace('opcall.node.concrete \"%s\" %O', node.op, { left, right }), node.op) {\n          case \"==\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"boolean\" } : left.type !== right.type ? {\n              type: \"boolean\",\n              value: !1\n            } : left.type === \"null\" ? {\n              type: \"boolean\",\n              value: !0\n            } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? {\n              type: \"boolean\",\n              value: !1\n            } : {\n              type: \"boolean\",\n              value: evaluateComparison(node.op, left, right)\n            };\n          case \"!=\": {\n            if (left.type === \"unknown\" || right.type === \"unknown\")\n              return { type: \"boolean\" };\n            if (left.type !== right.type)\n              return {\n                type: \"boolean\",\n                value: !0\n              };\n            if (left.type === \"null\")\n              return {\n                type: \"boolean\",\n                value: !1\n              };\n            if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right))\n              return {\n                type: \"boolean\",\n                value: !0\n              };\n            let value = evaluateComparison(\"==\", left, right);\n            return value !== void 0 && (value = !value), {\n              type: \"boolean\",\n              value\n            };\n          }\n          case \">\":\n          case \">=\":\n          case \"<\":\n          case \"<=\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : left.type !== right.type ? { type: \"null\" } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? { type: \"null\" } : {\n              type: \"boolean\",\n              value: evaluateComparison(node.op, left, right)\n            };\n          case \"in\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : right.type !== \"array\" ? isFuncCall(node.right, \"global::path\") ? { type: \"boolean\" } : { type: \"null\" } : !isPrimitiveTypeNode(left) && left.type !== \"null\" ? {\n              type: \"boolean\",\n              value: !1\n            } : mapNode(right.of, scope, (arrayTypeNode) => arrayTypeNode.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : left.type === \"null\" ? {\n              type: \"boolean\",\n              value: arrayTypeNode.type === \"null\"\n            } : left.value === void 0 ? {\n              type: \"boolean\"\n            } : isPrimitiveTypeNode(arrayTypeNode) ? arrayTypeNode.value === void 0 ? {\n              type: \"boolean\"\n            } : {\n              type: \"boolean\",\n              value: left.value === arrayTypeNode.value\n            } : {\n              type: \"boolean\",\n              value: !1\n            });\n          case \"match\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"boolean\" } : {\n              type: \"boolean\",\n              value: match(left, right)\n            };\n          case \"+\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"unknown\" } : left.type === \"string\" && right.type === \"string\" ? {\n              type: \"string\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n            } : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n            } : left.type === \"array\" && right.type === \"array\" ? {\n              type: \"array\",\n              of: {\n                type: \"union\",\n                of: [left.of, right.of]\n              }\n            } : left.type === \"object\" && right.type === \"object\" ? {\n              type: \"object\",\n              attributes: { ...left.attributes, ...right.attributes }\n            } : { type: \"null\" };\n          case \"-\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value - right.value : void 0\n            } : { type: \"null\" };\n          case \"*\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value * right.value : void 0\n            } : { type: \"null\" };\n          case \"/\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value / right.value : void 0\n            } : { type: \"null\" };\n          case \"**\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value ** right.value : void 0\n            } : { type: \"null\" };\n          case \"%\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value % right.value : void 0\n            } : { type: \"null\" };\n          default:\n            return {\n              type: \"unknown\"\n            };\n        }\n      })\n    )\n  );\n}\nfunction handleSelectNode(node, scope) {\n  const values = [];\n  let guaranteed = !1;\n  for (const alternative of node.alternatives) {\n    const conditionValue = walk({ node: alternative.condition, scope }), conditionScope = resolveFilter(alternative.condition, scope);\n    conditionScope.type === \"union\" && conditionScope.of.length > 0 && values.push(walk({ node: alternative.value, scope: scope.createHidden(conditionScope.of) })), conditionValue.type === \"boolean\" && conditionValue.value === !0 && (guaranteed = !0);\n  }\n  return node.fallback && !guaranteed && values.push(walk({ node: node.fallback, scope })), values.length === 0 ? { type: \"null\" } : {\n    type: \"union\",\n    of: values\n  };\n}\nfunction handleArrayCoerceNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"arrayCoerce.base %O\", base), mapArray(base, scope, (base2) => base2);\n}\nfunction handleFlatMap(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapArray(base, scope, (base2) => {\n    const inner = walk({ node: node.expr, scope: scope.createHidden([base2.of]) });\n    return mapNode(\n      inner,\n      scope,\n      (inner2) => inner2.type === \"array\" ? inner2 : { type: \"array\", of: inner2 },\n      (nodes) => {\n        const inner2 = [];\n        for (const node2 of nodes) {\n          if (node2.type === \"unknown\") return { type: \"array\", of: node2 };\n          if (node2.type !== \"array\") throw new Error(`Unexpected type: ${node2.type}`);\n          inner2.push(node2.of);\n        }\n        return {\n          type: \"array\",\n          of: optimizeUnions({ type: \"union\", of: inner2 })\n        };\n      }\n    );\n  });\n}\nfunction handleMap(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"map.base %O\", base), mapArray(base, scope, (base2) => ({\n    type: \"array\",\n    of: walk({ node: node.expr, scope: scope.createHidden([base2.of]) })\n  }));\n}\nfunction handleProjectionNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"projection.base %O\", base), mapObject(\n    base,\n    scope,\n    (base2) => walk({ node: node.expr, scope: scope.createNested([base2]) })\n  );\n}\nfunction createFilterScope(base, scope) {\n  return base.type === \"array\" ? base.of.type === \"union\" ? scope.createNested(base.of.of) : scope.createNested([base.of]) : scope.createNested([base]);\n}\nfunction handleFilterNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"filter.base %O\", base), mapNode(base, scope, (base2) => {\n    if ($trace(\"filter.resolving %O\", base2), base2.type === \"null\")\n      return base2;\n    const resolved = resolveFilter(node.expr, createFilterScope(base2, scope));\n    return $trace(\"filter.resolved %O\", resolved), {\n      type: \"array\",\n      of: resolved\n    };\n  });\n}\nfunction handleAccessAttributeNode(node, scope) {\n  let attributeBase = scope.value;\n  return node.base && (attributeBase = walk({ node: node.base, scope })), $trace(\"accessAttribute.base %s %O\", node.name, attributeBase), handleAccessAttributeBase(attributeBase, node.name, scope);\n}\nfunction handleAccessAttributeBase(base, name, scope) {\n  return mapObject(base, scope, (base2) => {\n    $trace('Looking for attribute \"%s\" in object %O', name, base2);\n    const attribute = base2.attributes[name];\n    return attribute !== void 0 ? ($debug(`accessAttribute.attribute found ${name} %O`, attribute), attribute.optional ? nullUnion(attribute.value) : attribute.value) : base2.rest ? handleAccessAttributeBase(base2.rest, name, scope) : ($warn(`attribute \"${name}\" not found in object`), { type: \"null\" });\n  });\n}\nfunction handleAccessElementNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"accessElement.base %O\", base), mapArray(base, scope, (base2) => nullUnion(base2.of));\n}\nfunction handleArrayNode(node, scope) {\n  const of = [];\n  for (const el of node.elements) {\n    const node2 = walk({ node: el.value, scope });\n    node2 !== null && of.push(node2);\n  }\n  return {\n    type: \"array\",\n    of: {\n      type: \"union\",\n      of\n    }\n  };\n}\nfunction handleValueNode(node, scope) {\n  if (node.value === null)\n    return { type: \"null\" };\n  switch (typeof node.value) {\n    case \"string\":\n      return {\n        type: \"string\",\n        value: node.value\n      };\n    case \"number\":\n      return {\n        type: \"number\",\n        value: node.value\n      };\n    case \"boolean\":\n      return {\n        type: \"boolean\",\n        value: node.value\n      };\n    case \"object\":\n      return node.value === null ? { type: \"null\" } : Array.isArray(node.value) ? {\n        type: \"array\",\n        of: {\n          type: \"union\",\n          of: node.value.map((value) => walk({ node: { type: \"Value\", value }, scope }))\n        }\n      } : {\n        type: \"object\",\n        attributes: Object.fromEntries(\n          Object.entries(node.value).map(([key, value]) => [\n            key,\n            {\n              type: \"objectAttribute\",\n              value: walk({ node: { type: \"Value\", value }, scope })\n            }\n          ])\n        )\n      };\n    default:\n      return { type: \"unknown\" };\n  }\n}\nfunction handleSlice(node, scope) {\n  $trace(\"slice.node %O\", node);\n  const base = walk({ node: node.base, scope });\n  return mapArray(base, scope, (base2) => base2);\n}\nfunction handleParentNode({ n }, scope) {\n  $trace(\"handle.parent.currentScope %d %O\", n, scope);\n  let current = scope;\n  for (let i = 0; i < n; i++) {\n    for (; current?.isHidden; )\n      current = current.parent;\n    current = current?.parent;\n  }\n  return $trace(\"handle.parent.newScope %d %O\", n, current), current ? current.value.of.length === 0 ? { type: \"null\" } : current.value : { type: \"null\" };\n}\nfunction handleNotNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : base2.type === \"boolean\" ? base2.value !== void 0 ? { type: \"boolean\", value: base2.value === !1 } : { type: \"boolean\" } : { type: \"null\" });\n}\nfunction handleNegNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : base2.type !== \"number\" ? { type: \"null\" } : base2.value !== void 0 ? { type: \"number\", value: -base2.value } : base2);\n}\nfunction handlePosNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : base2.type !== \"number\" ? { type: \"null\" } : base2);\n}\nfunction handleEverythingNode(_, scope) {\n  return {\n    type: \"array\",\n    of: {\n      type: \"union\",\n      of: scope.context.schema.filter((obj) => obj.type === \"document\").map((doc) => ({\n        type: \"object\",\n        attributes: doc.attributes\n      }))\n    }\n  };\n}\nfunction handleAndNode(node, scope) {\n  const left = walk({ node: node.left, scope }), right = walk({ node: node.right, scope });\n  return mapNode(\n    left,\n    scope,\n    (lhs) => mapNode(right, scope, (rhs) => {\n      const value = booleanAnd(booleanValue(lhs, scope), booleanValue(rhs, scope));\n      return booleanInterpretationToTypeNode(value);\n    })\n  );\n}\nfunction handleOrNode(node, scope) {\n  const left = walk({ node: node.left, scope }), right = walk({ node: node.right, scope });\n  return mapNode(\n    left,\n    scope,\n    (lhs) => mapNode(right, scope, (rhs) => {\n      const value = booleanOr(booleanValue(lhs, scope), booleanValue(rhs, scope));\n      return booleanInterpretationToTypeNode(value);\n    })\n  );\n}\nconst OVERRIDE_TYPE_SYMBOL = Symbol(\"groq-js.type\");\nfunction walk({ node, scope }) {\n  if (OVERRIDE_TYPE_SYMBOL in node)\n    return node[OVERRIDE_TYPE_SYMBOL];\n  switch (node.type) {\n    // Filtering, traversal & projections\n    case \"Map\":\n      return handleMap(node, scope);\n    case \"Projection\":\n      return handleProjectionNode(node, scope);\n    case \"Filter\":\n      return handleFilterNode(node, scope);\n    case \"AccessAttribute\":\n      return optimizeUnions(handleAccessAttributeNode(node, scope));\n    case \"AccessElement\":\n      return handleAccessElementNode(node, scope);\n    case \"ArrayCoerce\":\n      return handleArrayCoerceNode(node, scope);\n    case \"FlatMap\":\n      return handleFlatMap(node, scope);\n    // Operations\n    case \"OpCall\":\n      return handleOpCallNode(node, scope);\n    case \"And\":\n      return handleAndNode(node, scope);\n    case \"Or\":\n      return handleOrNode(node, scope);\n    case \"Select\":\n      return handleSelectNode(node, scope);\n    case \"PipeFuncCall\":\n      return walk({ node: node.base, scope });\n    // Values\n    case \"Deref\":\n      return handleDerefNode(node, scope);\n    case \"Object\":\n      return handleObjectNode(node, scope);\n    case \"Value\":\n      return handleValueNode(node, scope);\n    case \"Array\":\n      return handleArrayNode(node, scope);\n    // Special cases\n    case \"Everything\":\n      return handleEverythingNode(node, scope);\n    case \"This\":\n      return $trace(\"this %O\", scope.value), scope.value;\n    case \"Parent\":\n      return handleParentNode(node, scope);\n    case \"FuncCall\":\n      return handleFuncCallNode(node, scope);\n    case \"Group\":\n      return walk({ node: node.base, scope });\n    case \"Not\":\n      return handleNotNode(node, scope);\n    case \"Parameter\":\n      return {\n        type: \"unknown\"\n      };\n    case \"Slice\":\n      return handleSlice(node, scope);\n    case \"Neg\":\n      return handleNegNode(node, scope);\n    case \"Pos\":\n      return handlePosNode(node, scope);\n    // everything else\n    case \"Asc\":\n    case \"Desc\":\n    case \"Context\":\n    case \"Tuple\":\n    case \"SelectorFuncCall\":\n    case \"SelectorNested\":\n    case \"InRange\":\n      return { type: \"unknown\" };\n    default:\n      throw new Error(`unknown node type ${node.type}`);\n  }\n}\nfunction isPrimitiveTypeNode(node) {\n  return node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\";\n}\nfunction evaluateComparison(opcall, left, right) {\n  if (!(left.value === void 0 || right.value === void 0))\n    switch (opcall) {\n      case \"==\":\n        return left.value === right.value;\n      case \"<\":\n        return left.value < right.value;\n      case \"<=\":\n        return left.value <= right.value;\n      case \">\":\n        return left.value > right.value;\n      case \">=\":\n        return left.value >= right.value;\n      default:\n        throw new Error(`unknown comparison operator ${opcall}`);\n    }\n}\nfunction resolveFilter(expr, scope) {\n  $trace(\"resolveFilter.expr %O\", expr);\n  const filtered = scope.value.of.filter((node) => {\n    const subScope = scope.createHidden([node]), cond = walk({ node: expr, scope: subScope });\n    return booleanValue(cond, subScope).canBeTrue;\n  });\n  return $trace(\n    `resolveFilter ${expr.type === \"OpCall\" ? `${expr.type}/${expr.op}` : expr.type} %O`,\n    filtered\n  ), { type: \"union\", of: filtered };\n}\nfunction mapArray(node, scope, mapper) {\n  return mapNode(node, scope, (base) => base.type === \"unknown\" ? base : base.type === \"array\" ? mapper(base) : { type: \"null\" });\n}\nfunction mapObject(node, scope, mapper) {\n  return mapNode(node, scope, (base) => base.type === \"unknown\" ? base : base.type === \"object\" ? mapper(base) : { type: \"null\" });\n}\n\n//# sourceMappingURL=1.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwVkFBMFYsNkJBQTZCO0FBQ3ZYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3Q0FBd0M7QUFDdEQ7QUFDQTtBQUNB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QUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw2QkFBNkI7QUFDNUY7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsNEJBQTRCLFVBQVUsR0FBRyxRQUFRLGVBQWU7QUFDckY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtIQUFrSCxjQUFjO0FBQ2hJO0FBQ0E7QUFDQSxtSEFBbUgsY0FBYztBQUNqSTtBQVlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb2hhbi9kZXYvcGVyc29uYWwvbWV4aXdlYi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcyKSB7XG4gIHJldHVybiBzdHJpbmcyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0dGVybikge1xuICBjb25zdCByZSA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybi5zcGxpdChcIi5cIikpXG4gICAgcGFydCA9PT0gXCIqXCIgPyByZS5wdXNoKFwiW14uXStcIikgOiBwYXJ0ID09PSBcIioqXCIgPyByZS5wdXNoKFwiLipcIikgOiByZS5wdXNoKGVzY2FwZVJlZ0V4cChwYXJ0KSk7XG4gIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZS5qb2luKFwiLlwiKX0kYCk7XG59XG5jbGFzcyBQYXRoIHtcbiAgcGF0dGVybjtcbiAgcGF0dGVyblJlO1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybiwgdGhpcy5wYXR0ZXJuUmUgPSBwYXRoUmVnRXhwKHBhdHRlcm4pO1xuICB9XG4gIG1hdGNoZXMoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVyblJlLnRlc3Qoc3RyKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVybjtcbiAgfVxufVxuY29uc3QgUkZDMzMzOV9SRUdFWCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkKyk/KFp8KFstK11cXGR7Mn06XFxkezJ9KSkkLztcbmZ1bmN0aW9uIHBhcnNlUkZDMzMzOShzdHIpIHtcbiAgcmV0dXJuIFJGQzMzMzlfUkVHRVgudGVzdChzdHIpID8gbmV3IERhdGUoc3RyKSA6IG51bGw7XG59XG5mdW5jdGlvbiBmb3JtYXRSRkMzMzM5KGQpIHtcbiAgY29uc3QgeWVhciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRnVsbFllYXIoKSwgNCksIG1vbnRoID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNb250aCgpICsgMSwgMiksIGRheSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRGF0ZSgpLCAyKSwgaG91ciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDSG91cnMoKSwgMiksIG1pbnV0ZSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTWludXRlcygpLCAyKSwgc2Vjb25kID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENTZWNvbmRzKCksIDIpO1xuICBsZXQgZnJhY3Rpb25hbFNlY29uZCA9IFwiXCI7XG4gIGNvbnN0IG1pbGxpcyA9IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIHJldHVybiBtaWxsaXMgIT0gMCAmJiAoZnJhY3Rpb25hbFNlY29uZCA9IGAuJHthZGRMZWFkaW5nWmVybyhtaWxsaXMsIDMpfWApLCBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1UJHtob3VyfToke21pbnV0ZX06JHtzZWNvbmR9JHtmcmFjdGlvbmFsU2Vjb25kfVpgO1xufVxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm8obnVtLCB0YXJnZXRMZW5ndGgpIHtcbiAgbGV0IHN0ciA9IG51bS50b1N0cmluZygpO1xuICBmb3IgKDsgc3RyLmxlbmd0aCA8IHRhcmdldExlbmd0aDsgKVxuICAgIHN0ciA9IGAwJHtzdHJ9YDtcbiAgcmV0dXJuIHN0cjtcbn1cbmNsYXNzIFN0YXRpY1ZhbHVlIHtcbiAgZGF0YTtcbiAgdHlwZTtcbiAgY29uc3RydWN0b3IoZGF0YSwgdHlwZSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGEsIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cbiAgaXNBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBcImFycmF5XCI7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbiAgYXN5bmMgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbiAgYXNTdGF0aWMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmRhdGEpKVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZGF0YSlcbiAgICAgICAgICB5aWVsZCBmcm9tSlMoZWxlbWVudCk7XG4gICAgICB9KHRoaXMuZGF0YSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaXRlcmF0ZSBvdmVyOiAke3RoaXMudHlwZX1gKTtcbiAgfVxufVxuY29uc3QgTlVMTF9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShudWxsLCBcIm51bGxcIiksIFRSVUVfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoITAsIFwiYm9vbGVhblwiKSwgRkFMU0VfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoITEsIFwiYm9vbGVhblwiKTtcbmNsYXNzIERhdGVUaW1lIHtcbiAgZGF0ZTtcbiAgY29uc3RydWN0b3IoZGF0ZSkge1xuICAgIHRoaXMuZGF0ZSA9IGRhdGU7XG4gIH1cbiAgc3RhdGljIHBhcnNlVG9WYWx1ZShzdHIpIHtcbiAgICBjb25zdCBkYXRlID0gcGFyc2VSRkMzMzM5KHN0cik7XG4gICAgcmV0dXJuIGRhdGUgPyBuZXcgU3RhdGljVmFsdWUobmV3IERhdGVUaW1lKGRhdGUpLCBcImRhdGV0aW1lXCIpIDogTlVMTF9WQUxVRTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSA9PSBvdGhlci5kYXRlLmdldFRpbWUoKTtcbiAgfVxuICBhZGQoc2Vjcykge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgRGF0ZSh0aGlzLmRhdGUuZ2V0VGltZSgpKTtcbiAgICByZXR1cm4gY29weS5zZXRUaW1lKGNvcHkuZ2V0VGltZSgpICsgc2VjcyAqIDFlMyksIG5ldyBEYXRlVGltZShjb3B5KTtcbiAgfVxuICBkaWZmZXJlbmNlKG90aGVyKSB7XG4gICAgcmV0dXJuICh0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCkpIC8gMWUzO1xuICB9XG4gIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdFJGQzMzMzkodGhpcy5kYXRlKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufVxuZnVuY3Rpb24gZnJvbU51bWJlcihudW0pIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShudW0pID8gbmV3IFN0YXRpY1ZhbHVlKG51bSwgXCJudW1iZXJcIikgOiBOVUxMX1ZBTFVFO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShzdHIsIFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gZnJvbURhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoZHQsIFwiZGF0ZXRpbWVcIik7XG59XG5mdW5jdGlvbiBmcm9tUGF0aChwYXRoKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUocGF0aCwgXCJwYXRoXCIpO1xufVxuZnVuY3Rpb24gaXNJdGVyYXRvcihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLm5leHQgPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gZnJvbUFycmF5KHZhbCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHZhbCwgXCJhcnJheVwiKTtcbn1cbmZ1bmN0aW9uIGZyb21KUyh2YWwpIHtcbiAgcmV0dXJuIGlzSXRlcmF0b3IodmFsKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdmFsKVxuICAgICAgeWllbGQgZnJvbUpTKHZhbHVlKTtcbiAgfSkgOiB2YWwgPT0gbnVsbCA/IE5VTExfVkFMVUUgOiBuZXcgU3RhdGljVmFsdWUodmFsLCBnZXRUeXBlKHZhbCkpO1xufVxuZnVuY3Rpb24gdG9KUyh2YWwpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IG1heWJlTm9ybWFsaXplKHZhbC5kYXRhKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQgPT09IHZvaWQgMCA/IHZhbC5kYXRhIDogbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIG1heWJlTm9ybWFsaXplKGRhdGEpIHtcbiAgaWYgKCEoZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA+IFwidVwiKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub3JtYWxpemVkID0gbWF5YmVOb3JtYWxpemUoZGF0YVtpXSk7XG4gICAgICAgIG5vcm1hbGl6ZWQgIT09IHZvaWQgMCAmJiByZXN1bHQgPT09IHZvaWQgMCAmJiAocmVzdWx0ID0gZGF0YS5zbGljZSgwLCBpKSksIHJlc3VsdCAhPT0gdm9pZCAwICYmIChub3JtYWxpemVkID09PSB2b2lkIDAgJiYgKG5vcm1hbGl6ZWQgPSBkYXRhW2ldKSwgcmVzdWx0LnB1c2gobm9ybWFsaXplZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChcInRvSlNPTlwiIGluIGRhdGEgJiYgdHlwZW9mIGRhdGEudG9KU09OID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGRhdGEudG9KU09OKCk7XG4gICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZGF0YSk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGVudHJpZXNbaV07XG4gICAgICAgIGxldCBub3JtYWxpemVkID0gbWF5YmVOb3JtYWxpemUodmFsdWUpO1xuICAgICAgICBub3JtYWxpemVkICE9PSB2b2lkIDAgJiYgcmVzdWx0ID09PSB2b2lkIDAgJiYgKHJlc3VsdCA9IE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzLnNsaWNlKDAsIGkpKSksIHJlc3VsdCAhPT0gdm9pZCAwICYmIChub3JtYWxpemVkID09PSB2b2lkIDAgJiYgKG5vcm1hbGl6ZWQgPSB2YWx1ZSksIHJlc3VsdFtrZXldID0gbm9ybWFsaXplZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID4gXCJ1XCIgPyBcIm51bGxcIiA6IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBcImFycmF5XCIgOiBkYXRhIGluc3RhbmNlb2YgUGF0aCA/IFwicGF0aFwiIDogZGF0YSBpbnN0YW5jZW9mIERhdGVUaW1lID8gXCJkYXRldGltZVwiIDogdHlwZW9mIGRhdGE7XG59XG5jbGFzcyBTdHJlYW1WYWx1ZSB7XG4gIHR5cGUgPSBcInN0cmVhbVwiO1xuICBnZW5lcmF0b3I7XG4gIHRpY2tlcjtcbiAgaXNEb25lO1xuICBkYXRhO1xuICBjb25zdHJ1Y3RvcihnZW5lcmF0b3IpIHtcbiAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvciwgdGhpcy50aWNrZXIgPSBudWxsLCB0aGlzLmlzRG9uZSA9ICExLCB0aGlzLmRhdGEgPSBbXTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBpc0FycmF5KCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBhc3luYyBnZXQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzKVxuICAgICAgcmVzdWx0LnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgYXNTdGF0aWMoKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShhd2FpdCB0aGlzLmdldCgpLCBcImFycmF5XCIpO1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGZvciAoOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICB5aWVsZCB0aGlzLmRhdGFbaV07XG4gICAgICBpZiAodGhpcy5pc0RvbmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGF3YWl0IHRoaXMuX25leHRUaWNrKCk7XG4gICAgfVxuICB9XG4gIF9uZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy50aWNrZXIpXG4gICAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gICAgbGV0IGN1cnJlbnRSZXNvbHZlciwgY3VycmVudFJlamVjdG9yO1xuICAgIGNvbnN0IHNldHVwVGlja2VyID0gKCkgPT4ge1xuICAgICAgdGhpcy50aWNrZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGN1cnJlbnRSZXNvbHZlciA9IHJlc29sdmUsIGN1cnJlbnRSZWplY3RvciA9IHJlamVjdDtcbiAgICAgIH0pO1xuICAgIH0sIHRpY2sgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKSwgc2V0dXBUaWNrZXIoKTtcbiAgICB9LCBmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZW5lcmF0b3IoKSlcbiAgICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSksIHRpY2soKTtcbiAgICAgICAgdGhpcy5pc0RvbmUgPSAhMCwgdGljaygpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY3VycmVudFJlamVjdG9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzZXR1cFRpY2tlcigpLCBmZXRjaCgpLCB0aGlzLnRpY2tlcjtcbiAgfVxufVxuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgYi50eXBlID09PSBcInN0cmluZ1wiIHx8IGEudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYi50eXBlID09PSBcImJvb2xlYW5cIiB8fCBhLnR5cGUgPT09IFwibnVsbFwiICYmIGIudHlwZSA9PT0gXCJudWxsXCIgfHwgYS50eXBlID09PSBcIm51bWJlclwiICYmIGIudHlwZSA9PT0gXCJudW1iZXJcIiA/IGEuZGF0YSA9PT0gYi5kYXRhIDogYS50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgYi50eXBlID09PSBcImRhdGV0aW1lXCIgPyBhLmRhdGEuZXF1YWxzKGIuZGF0YSkgOiAhMTtcbn1cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHJldHVybiBhID09PSBiO1xuICBjb25zdCB0eXBlT2ZBID0gdHlwZW9mIGEsIHR5cGVPZkIgPSB0eXBlb2YgYjtcbiAgaWYgKHR5cGVPZkEgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZU9mQiA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuICEwO1xuICBpZiAodHlwZU9mQSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVPZkIgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGEgPT09IGI7XG4gIGlmICh0eXBlT2ZBID09PSBcIm9iamVjdFwiICYmIHR5cGVPZkIgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBrZXlzT2ZBID0gT2JqZWN0LmtleXMoYSksIGtleXNPZkIgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoa2V5c09mQS5sZW5ndGggIT09IGtleXNPZkIubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5c09mQSlcbiAgICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuICExO1xuICAgIHJldHVybiAhMDtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn1cbmNvbnN0IENIQVJTID0gLyhbXiFAIyQlXiYqKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2csIENIQVJTX1dJVEhfV0lMRENBUkQgPSAvKFteIUAjJCVeJigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nLCBFREdFX0NIQVJTID0gLyhcXGJcXC4rfFxcLitcXGIpL2c7XG5mdW5jdGlvbiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykge1xuICByZXR1cm4gdG9rZW5zLmxlbmd0aCA9PT0gMCB8fCBwYXR0ZXJucy5sZW5ndGggPT09IDAgPyAhMSA6IHBhdHRlcm5zLmV2ZXJ5KChwYXR0ZXJuKSA9PiBwYXR0ZXJuKHRva2VucykpO1xufVxuZnVuY3Rpb24gbWF0Y2hUb2tlbml6ZSh0ZXh0Mikge1xuICByZXR1cm4gdGV4dDIucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSUykgfHwgW107XG59XG5mdW5jdGlvbiBtYXRjaEFuYWx5emVQYXR0ZXJuKHRleHQyKSB7XG4gIHJldHVybiBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0MikubWFwKChyZSkgPT4gKHRva2VucykgPT4gdG9rZW5zLnNvbWUoKHRva2VuKSA9PiByZS50ZXN0KHRva2VuKSkpO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dDIpIHtcbiAgcmV0dXJuICh0ZXh0Mi5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTX1dJVEhfV0lMRENBUkQpIHx8IFtdKS5tYXAoXG4gICAgKHRlcm0pID0+IG5ldyBSZWdFeHAoYF4ke3Rlcm0uc2xpY2UoMCwgMTAyNCkucmVwbGFjZSgvXFwqL2csIFwiLipcIil9JGAsIFwiaVwiKVxuICApO1xufVxuZnVuY3Rpb24gZ2F0aGVyVGV4dCh2YWx1ZSwgZmxhdE1hcDIpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHsgcGFydHM6IGZsYXRNYXAyKHZhbHVlLmRhdGEpLCBzdWNjZXNzOiAhMCB9O1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSAhMDtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiB2YWx1ZS5kYXRhKVxuICAgICAgdHlwZW9mIHBhcnQgPT0gXCJzdHJpbmdcIiA/IHBhcnRzLnB1c2goLi4uZmxhdE1hcDIocGFydCkpIDogc3VjY2VzcyA9ICExO1xuICAgIHJldHVybiB7IHBhcnRzLCBzdWNjZXNzIH07XG4gIH1cbiAgcmV0dXJuIHZhbHVlLnR5cGUgPT09IFwic3RyZWFtXCIgPyAoYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzdWNjZXNzID0gITA7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgdmFsdWUpXG4gICAgICBwYXJ0LnR5cGUgPT09IFwic3RyaW5nXCIgPyBwYXJ0cy5wdXNoKC4uLmZsYXRNYXAyKHBhcnQuZGF0YSkpIDogc3VjY2VzcyA9ICExO1xuICAgIHJldHVybiB7IHBhcnRzLCBzdWNjZXNzIH07XG4gIH0pKCkgOiB7IHBhcnRzOiBbXSwgc3VjY2VzczogITEgfTtcbn1cbmNvbnN0IFRZUEVfT1JERVIgPSB7XG4gIGRhdGV0aW1lOiAxLFxuICBudW1iZXI6IDIsXG4gIHN0cmluZzogMyxcbiAgYm9vbGVhbjogNFxufTtcbmZ1bmN0aW9uIHBhcnRpYWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpLCBiVHlwZSA9IGdldFR5cGUoYik7XG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpXG4gICAgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAoYVR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICByZXR1cm4gYS5jb21wYXJlVG8oYik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiB0b3RhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSksIGJUeXBlID0gZ2V0VHlwZShiKSwgYVR5cGVPcmRlciA9IFRZUEVfT1JERVJbYVR5cGVdIHx8IDEwMCwgYlR5cGVPcmRlciA9IFRZUEVfT1JERVJbYlR5cGVdIHx8IDEwMDtcbiAgaWYgKGFUeXBlT3JkZXIgIT09IGJUeXBlT3JkZXIpXG4gICAgcmV0dXJuIGFUeXBlT3JkZXIgLSBiVHlwZU9yZGVyO1xuICBsZXQgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUoYSwgYik7XG4gIHJldHVybiByZXN1bHQgPT09IG51bGwgJiYgKHJlc3VsdCA9IDApLCByZXN1bHQ7XG59XG5jb25zdCBvcGVyYXRvcnMgPSB7XG4gIFwiPT1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiIT1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIFwiPlwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA+IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPj1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiByZXN1bHQgPj0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogcmVzdWx0IDwgMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8PVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gIGluOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodC50eXBlID09PSBcInBhdGhcIilcbiAgICAgIHJldHVybiBsZWZ0LnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogcmlnaHQuZGF0YS5tYXRjaGVzKGxlZnQuZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgZm9yIChjb25zdCBiIG9mIHJpZ2h0LmRhdGEpXG4gICAgICAgIGlmIChpc0VxdWFsKGxlZnQsIGZyb21KUyhiKSkpXG4gICAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByaWdodC50eXBlID09PSBcInN0cmVhbVwiID8gKGFzeW5jICgpID0+IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgYiBvZiByaWdodClcbiAgICAgICAgaWYgKGlzRXF1YWwobGVmdCwgYikpXG4gICAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfSkoKSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIG1hdGNoOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IHRva2VucyA9IGdhdGhlclRleHQobGVmdCwgKHBhcnQpID0+IG1hdGNoVG9rZW5pemUocGFydCkpLCBwYXR0ZXJucyA9IGdhdGhlclRleHQocmlnaHQsIChwYXJ0KSA9PiBtYXRjaEFuYWx5emVQYXR0ZXJuKHBhcnQpKSwgcHJvY2VzcyA9ICh0b2tlbnMyLCBwYXR0ZXJuczIpID0+IHBhdHRlcm5zMi5zdWNjZXNzICYmIG1hdGNoVGV4dCh0b2tlbnMyLnBhcnRzLCBwYXR0ZXJuczIucGFydHMpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIHJldHVybiBcInRoZW5cIiBpbiB0b2tlbnMgfHwgXCJ0aGVuXCIgaW4gcGF0dGVybnMgPyAoYXN5bmMgKCkgPT4gcHJvY2Vzcyhhd2FpdCB0b2tlbnMsIGF3YWl0IHBhdHRlcm5zKSkoKSA6IHByb2Nlc3ModG9rZW5zLCBwYXR0ZXJucyk7XG4gIH0sXG4gIFwiK1wiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQocmlnaHQuZGF0YSkpIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tTnVtYmVyKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpIDogbGVmdC50eXBlID09PSBcInN0cmluZ1wiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIgPyBmcm9tU3RyaW5nKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpIDogbGVmdC50eXBlID09PSBcIm9iamVjdFwiICYmIHJpZ2h0LnR5cGUgPT09IFwib2JqZWN0XCIgPyBmcm9tSlMoeyAuLi5sZWZ0LmRhdGEsIC4uLnJpZ2h0LmRhdGEgfSkgOiBsZWZ0LnR5cGUgPT09IFwiYXJyYXlcIiAmJiByaWdodC50eXBlID09PSBcImFycmF5XCIgPyBmcm9tSlMobGVmdC5kYXRhLmNvbmNhdChyaWdodC5kYXRhKSkgOiBsZWZ0LmlzQXJyYXkoKSAmJiByaWdodC5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGxlZnQpXG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHJpZ2h0KVxuICAgICAgICB5aWVsZCB2YWw7XG4gICAgfSkgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBcIi1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IGZyb21EYXRlVGltZShsZWZ0LmRhdGEuYWRkKC1yaWdodC5kYXRhKSkgOiBsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcImRhdGV0aW1lXCIgPyBmcm9tTnVtYmVyKGxlZnQuZGF0YS5kaWZmZXJlbmNlKHJpZ2h0LmRhdGEpKSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8gZnJvbU51bWJlcihsZWZ0LmRhdGEgLSByaWdodC5kYXRhKSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIFwiKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgKiBiKSxcbiAgXCIvXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAvIGIpLFxuICBcIiVcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICUgYiksXG4gIFwiKipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBNYXRoLnBvdyhhLCBiKSlcbn07XG5mdW5jdGlvbiBudW1lcmljT3BlcmF0b3IoaW1wbCkge1xuICByZXR1cm4gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGltcGwobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9O1xufVxubGV0IFNjb3BlJDEgPSBjbGFzcyBTY29wZSB7XG4gIHBhcmFtcztcbiAgc291cmNlO1xuICB2YWx1ZTtcbiAgcGFyZW50O1xuICBjb250ZXh0O1xuICBpc0hpZGRlbiA9ICExO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICBjb25zdHJ1Y3RvcihwYXJhbXMsIHNvdXJjZSwgdmFsdWUsIGNvbnRleHQsIHBhcmVudCkge1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zLCB0aGlzLnNvdXJjZSA9IHNvdXJjZSwgdGhpcy52YWx1ZSA9IHZhbHVlLCB0aGlzLmNvbnRleHQgPSBjb250ZXh0LCB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuICBjcmVhdGVOZXN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0hpZGRlbiA/IG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMucGFyZW50KSA6IG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMpO1xuICB9XG4gIGNyZWF0ZUhpZGRlbih2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0LmlzSGlkZGVuID0gITAsIHJlc3VsdDtcbiAgfVxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlKG5vZGUsIHNjb3BlKSB7XG4gIHJldHVybiBleGVjdXRlQXN5bmMobm9kZSwgc2NvcGUpO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVN5bmMobm9kZSwgc2NvcGUpIHtcbiAgcmV0dXJuIEVYRUNVVE9SU1tub2RlLnR5cGVdLmV4ZWN1dGVTeW5jKG5vZGUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVBc3luYyhub2RlLCBzY29wZSkge1xuICByZXR1cm4gRVhFQ1VUT1JTW25vZGUudHlwZV0uZXhlY3V0ZUFzeW5jKG5vZGUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGFzeW5jT25seUV4ZWN1dG9yKGV4ZWN1dGVBc3luYzIpIHtcbiAgcmV0dXJuIHtcbiAgICBleGVjdXRlU3luYygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImV4ZWN1dGVTeW5jIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfSxcbiAgICBleGVjdXRlQXN5bmM6IGV4ZWN1dGVBc3luYzJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnN0YW50RXhlY3V0b3IoZm4pIHtcbiAgcmV0dXJuIHtcbiAgICBleGVjdXRlU3luYyhub2RlLCBzY29wZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBmbihub2RlLCBzY29wZSk7XG4gICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJzdHJlYW1cIikgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGVuY291bnRlcmVkIGluIGV2YWx1YXRlU3luY1wiKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGFzeW5jIGV4ZWN1dGVBc3luYyhub2RlLCBzY29wZSkge1xuICAgICAgcmV0dXJuIGZuKG5vZGUsIHNjb3BlKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtYXBwZWRFeGVjdXRvcihtYXAyLCByZWR1Y2UpIHtcbiAgcmV0dXJuIHtcbiAgICBleGVjdXRlU3luYyhub2RlLCBzY29wZSkge1xuICAgICAgY29uc3QgdmFsdWVzID0gbWFwMihub2RlKS5tYXAoKG5vZGUyKSA9PiBleGVjdXRlU3luYyhub2RlMiwgc2NvcGUpKSwgdmFsdWUgPSByZWR1Y2Uobm9kZSwgLi4udmFsdWVzKTtcbiAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0vaXRlcmF0b3Igbm90IHN1cHBvcnRlZCBpbiBzeW5jaHJvbm91cyBtb2RlXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKG5vZGUsIHNjb3BlKSB7XG4gICAgICBjb25zdCBub2RlcyA9IG1hcDIobm9kZSksIHZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBub2Rlcy5tYXAoKG5vZGUyKSA9PiBleGVjdXRlQXN5bmMobm9kZTIsIHNjb3BlKS50aGVuKCh2YWx1ZSkgPT4gdmFsdWUuYXNTdGF0aWMoKSkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlZHVjZShub2RlLCAuLi52YWx1ZXMpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IFNUT1BfSVRFUkFUT1IgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIGFycmF5UmVkdWNlckV4ZWN1dG9yKG1hcDIsIGluaXQsIHJlZHVjZSwgd3JhcCkge1xuICByZXR1cm4ge1xuICAgIGV4ZWN1dGVTeW5jKG5vZGUsIHNjb3BlKSB7XG4gICAgICBjb25zdCB7IGFycmF5OiBhcnJheU5vZGUsIGFyZ3M6IGFyZ05vZGVzID0gW10gfSA9IG1hcDIobm9kZSksIGFyciA9IGV4ZWN1dGVTeW5jKGFycmF5Tm9kZSwgc2NvcGUpO1xuICAgICAgaWYgKGFyci50eXBlICE9PSBcImFycmF5XCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgY29uc3QgYXJncyA9IGFyZ05vZGVzLm1hcCgobm9kZTIpID0+IGV4ZWN1dGVTeW5jKG5vZGUyLCBzY29wZSkpO1xuICAgICAgbGV0IHN0YXRlID0gaW5pdChub2RlLCAuLi5hcmdzKTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIuZGF0YSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWR1Y2Uobm9kZSwgc3RhdGUsIGl0ZW0sIC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBTVE9QX0lURVJBVE9SKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgc3RhdGUgPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcChzdGF0ZSk7XG4gICAgfSxcbiAgICBhc3luYyBleGVjdXRlQXN5bmMobm9kZSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IHsgYXJyYXk6IGFycmF5Tm9kZSwgYXJnczogYXJnTm9kZXMgPSBbXSB9ID0gbWFwMihub2RlKSwgYXJyID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGFycmF5Tm9kZSwgc2NvcGUpO1xuICAgICAgaWYgKGFyci50eXBlICE9PSBcImFycmF5XCIgJiYgYXJyLnR5cGUgIT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgY29uc3QgYXJncyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBhcmdOb2Rlcy5tYXAoKG5vZGUyKSA9PiBleGVjdXRlQXN5bmMobm9kZTIsIHNjb3BlKS50aGVuKCh2KSA9PiB2LmFzU3RhdGljKCkpKVxuICAgICAgKTtcbiAgICAgIGxldCBzdGF0ZSA9IGluaXQobm9kZSwgLi4uYXJncyk7XG4gICAgICBpZiAoYXJyLnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWR1Y2Uobm9kZSwgc3RhdGUsIGF3YWl0IGl0ZW0uZ2V0KCksIC4uLmFyZ3MpO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IFNUT1BfSVRFUkFUT1IpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICAgIHN0YXRlID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIuZGF0YSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZHVjZShub2RlLCBzdGF0ZSwgaXRlbSwgLi4uYXJncyk7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gU1RPUF9JVEVSQVRPUikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgICAgc3RhdGUgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwKHN0YXRlKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBhcnJheUV4ZWN1dG9yKG1hcDIsIHJlZHVjZSwgeyBoaWRkZW4gPSAhMSB9ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBleGVjdXRlU3luYyhub2RlLCBzY29wZSkge1xuICAgICAgY29uc3QgbWFwcGluZyA9IG1hcDIobm9kZSksIGFyciA9IGV4ZWN1dGVTeW5jKG1hcHBpbmcuYXJyYXksIHNjb3BlKTtcbiAgICAgIGlmIChhcnIudHlwZSAhPT0gXCJhcnJheVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFyci5kYXRhKSB7XG4gICAgICAgIGxldCBpbm5lcjtcbiAgICAgICAgaWYgKG1hcHBpbmcuaW5uZXIpIHtcbiAgICAgICAgICBjb25zdCBuZXdTY29wZSA9IGhpZGRlbiA/IHNjb3BlLmNyZWF0ZUhpZGRlbihmcm9tSlMoaXRlbSkpIDogc2NvcGUuY3JlYXRlTmVzdGVkKGZyb21KUyhpdGVtKSk7XG4gICAgICAgICAgaW5uZXIgPSBleGVjdXRlU3luYyhtYXBwaW5nLmlubmVyLCBuZXdTY29wZSkuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHJlZHVjZShub2RlLCBpdGVtLCBpbm5lciwgbWFwcGluZy5zdGF0ZSkpXG4gICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheShyZXN1bHQpO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKG5vZGUsIHNjb3BlKSB7XG4gICAgICBjb25zdCBtYXBwaW5nID0gbWFwMihub2RlKSwgYXJyID0gYXdhaXQgZXhlY3V0ZUFzeW5jKG1hcHBpbmcuYXJyYXksIHNjb3BlKTtcbiAgICAgIHJldHVybiBhcnIuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICBsZXQgaW5uZXI7XG4gICAgICAgICAgaWYgKG1hcHBpbmcuaW5uZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3BlID0gaGlkZGVuID8gc2NvcGUuY3JlYXRlSGlkZGVuKGl0ZW0pIDogc2NvcGUuY3JlYXRlTmVzdGVkKGl0ZW0pO1xuICAgICAgICAgICAgaW5uZXIgPSBhd2FpdCAoYXdhaXQgZXhlY3V0ZUFzeW5jKG1hcHBpbmcuaW5uZXIsIG5ld1Njb3BlKSkuZ2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcmVkdWNlKG5vZGUsIGF3YWl0IGl0ZW0uZ2V0KCksIGlubmVyLCBtYXBwaW5nLnN0YXRlKSlcbiAgICAgICAgICAgIHlpZWxkIGZyb21KUyhlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH0pIDogTlVMTF9WQUxVRTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBFWEVDVVRPUlMgPSB7XG4gIFRoaXM6IGNvbnN0YW50RXhlY3V0b3IoKF8sIHNjb3BlKSA9PiBzY29wZS52YWx1ZSksXG4gIFNlbGVjdG9yTmVzdGVkOiBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgdHlwZTogU2VsZWN0b3JOZXN0ZWRcIik7XG4gIH0pLFxuICBTZWxlY3RvckZ1bmNDYWxsOiBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgdHlwZTogU2VsZWN0b3JGdW5jQ2FsbFwiKTtcbiAgfSksXG4gIEV2ZXJ5dGhpbmc6IGNvbnN0YW50RXhlY3V0b3IoKF8sIHNjb3BlKSA9PiBzY29wZS5zb3VyY2UpLFxuICBQYXJhbWV0ZXI6IGNvbnN0YW50RXhlY3V0b3IoKHsgbmFtZSB9LCBzY29wZSkgPT4gZnJvbUpTKHNjb3BlLnBhcmFtc1tuYW1lXSkpLFxuICBDb250ZXh0OiBjb25zdGFudEV4ZWN1dG9yKCh7IGtleSB9LCBzY29wZSkgPT4ge1xuICAgIGlmIChrZXkgPT09IFwiYmVmb3JlXCIgfHwga2V5ID09PSBcImFmdGVyXCIpXG4gICAgICByZXR1cm4gc2NvcGUuY29udGV4dFtrZXldIHx8IE5VTExfVkFMVUU7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGNvbnRleHQga2V5OiAke2tleX1gKTtcbiAgfSksXG4gIFBhcmVudDogY29uc3RhbnRFeGVjdXRvcigoeyBuIH0sIHNjb3BlKSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSBzY29wZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKCFjdXJyZW50LnBhcmVudClcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICB9KSxcbiAgT3BDYWxsOiB7XG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgb3AsIGxlZnQsIHJpZ2h0IH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICAgIGlmICghZnVuYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wZXJhdG9yOiAke29wfWApO1xuICAgICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGxlZnQsIHNjb3BlKSwgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhyaWdodCwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGZ1bmMobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgICB9LFxuICAgIGV4ZWN1dGVTeW5jKHsgb3AsIGxlZnQsIHJpZ2h0IH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICAgIGlmICghZnVuYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wZXJhdG9yOiAke29wfWApO1xuICAgICAgY29uc3QgbGVmdFZhbHVlID0gZXhlY3V0ZVN5bmMobGVmdCwgc2NvcGUpLCByaWdodFZhbHVlID0gZXhlY3V0ZVN5bmMocmlnaHQsIHNjb3BlKSwgcmVzdWx0ID0gZnVuYyhsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICAgICAgaWYgKFwidGhlblwiIGluIHJlc3VsdCB8fCByZXN1bHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcGVyYXRvciAke29wfSBub3QgcG9zc2libGUgaW4gZXZhbHV0ZVN5bmNgKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LFxuICBTZWxlY3Q6IHtcbiAgICBleGVjdXRlU3luYyh7IGFsdGVybmF0aXZlcywgZmFsbGJhY2sgfSwgc2NvcGUpIHtcbiAgICAgIGZvciAoY29uc3QgYWx0IG9mIGFsdGVybmF0aXZlcykge1xuICAgICAgICBjb25zdCBhbHRDb25kID0gZXhlY3V0ZVN5bmMoYWx0LmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09ICEwKVxuICAgICAgICAgIHJldHVybiBleGVjdXRlU3luYyhhbHQudmFsdWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxsYmFjayA/IGV4ZWN1dGVTeW5jKGZhbGxiYWNrLCBzY29wZSkgOiBOVUxMX1ZBTFVFO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgYWx0ZXJuYXRpdmVzLCBmYWxsYmFjayB9LCBzY29wZSkge1xuICAgICAgZm9yIChjb25zdCBhbHQgb2YgYWx0ZXJuYXRpdmVzKSB7XG4gICAgICAgIGNvbnN0IGFsdENvbmQgPSBhd2FpdCBleGVjdXRlQXN5bmMoYWx0LmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09ICEwKVxuICAgICAgICAgIHJldHVybiBleGVjdXRlQXN5bmMoYWx0LnZhbHVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsbGJhY2sgPyBleGVjdXRlQXN5bmMoZmFsbGJhY2ssIHNjb3BlKSA6IE5VTExfVkFMVUU7XG4gICAgfVxuICB9LFxuICBJblJhbmdlOiBtYXBwZWRFeGVjdXRvcihcbiAgICAoeyBiYXNlLCBsZWZ0LCByaWdodCB9KSA9PiBbYmFzZSwgbGVmdCwgcmlnaHRdLFxuICAgICh7IGlzSW5jbHVzaXZlIH0sIHZhbHVlLCBsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGxlZnRDbXAgPSBwYXJ0aWFsQ29tcGFyZSh2YWx1ZS5kYXRhLCBsZWZ0VmFsdWUuZGF0YSk7XG4gICAgICBpZiAobGVmdENtcCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjb25zdCByaWdodENtcCA9IHBhcnRpYWxDb21wYXJlKHZhbHVlLmRhdGEsIHJpZ2h0VmFsdWUuZGF0YSk7XG4gICAgICByZXR1cm4gcmlnaHRDbXAgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogaXNJbmNsdXNpdmUgPyBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPD0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRSA6IGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfVxuICApLFxuICBGaWx0ZXI6IGFycmF5RXhlY3V0b3IoXG4gICAgKHsgYmFzZSwgZXhwciB9KSA9PiAoeyBhcnJheTogYmFzZSwgaW5uZXI6IGV4cHIgfSksXG4gICAgZnVuY3Rpb24qIChfLCBlbGVtLCBpbm5lcikge1xuICAgICAgaW5uZXIgPT09ICEwICYmICh5aWVsZCBlbGVtKTtcbiAgICB9XG4gICksXG4gIFByb2plY3Rpb246IHtcbiAgICBleGVjdXRlU3luYyh7IGJhc2UsIGV4cHIgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGV4ZWN1dGVTeW5jKGJhc2UsIHNjb3BlKTtcbiAgICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlVmFsdWUpO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVTeW5jKGV4cHIsIG5ld1Njb3BlKTtcbiAgICB9LFxuICAgIGFzeW5jIGV4ZWN1dGVBc3luYyh7IGJhc2UsIGV4cHIgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhiYXNlLCBzY29wZSk7XG4gICAgICBpZiAoYmFzZVZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoYmFzZVZhbHVlKTtcbiAgICAgIHJldHVybiBleGVjdXRlQXN5bmMoZXhwciwgbmV3U2NvcGUpO1xuICAgIH1cbiAgfSxcbiAgRnVuY0NhbGw6IHtcbiAgICBleGVjdXRlQXN5bmMoeyBmdW5jLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgICByZXR1cm4gZnVuYy5leGVjdXRlQXN5bmMoYXJncywgc2NvcGUpO1xuICAgIH0sXG4gICAgZXhlY3V0ZVN5bmMoeyBmdW5jLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgICByZXR1cm4gZnVuYy5leGVjdXRlU3luYyhhcmdzLCBzY29wZSk7XG4gICAgfVxuICB9LFxuICBQaXBlRnVuY0NhbGw6IHtcbiAgICBhc3luYyBleGVjdXRlQXN5bmMoeyBmdW5jLCBiYXNlLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlQXN5bmMoYmFzZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGJhc2VWYWx1ZS50eXBlICE9PSBcInN0cmVhbVwiICYmIGJhc2VWYWx1ZS50eXBlICE9PSBcImFycmF5XCIgPyBOVUxMX1ZBTFVFIDogZnVuYy5leGVjdXRlQXN5bmMoeyBiYXNlOiBiYXNlVmFsdWUsIGFyZ3MgfSwgc2NvcGUpO1xuICAgIH0sXG4gICAgZXhlY3V0ZVN5bmMoeyBmdW5jLCBiYXNlLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCBiYXNlVmFsdWUgPSBleGVjdXRlU3luYyhiYXNlLCBzY29wZSk7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlLnR5cGUgIT09IFwiYXJyYXlcIiA/IE5VTExfVkFMVUUgOiBmdW5jLmV4ZWN1dGVTeW5jKHsgYmFzZTogYmFzZVZhbHVlLCBhcmdzIH0sIHNjb3BlKTtcbiAgICB9XG4gIH0sXG4gIEFjY2Vzc0F0dHJpYnV0ZTogbWFwcGVkRXhlY3V0b3IoXG4gICAgKHsgYmFzZSB9KSA9PiBbYmFzZSB8fCB7IHR5cGU6IFwiVGhpc1wiIH1dLFxuICAgICh7IG5hbWUgfSwgdmFsdWUpID0+IHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUuZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IGZyb21KUyh2YWx1ZS5kYXRhW25hbWVdKSA6IE5VTExfVkFMVUVcbiAgKSxcbiAgQWNjZXNzRWxlbWVudDogbWFwcGVkRXhlY3V0b3IoXG4gICAgKHsgYmFzZSB9KSA9PiBbYmFzZV0sXG4gICAgKHsgaW5kZXggfSwgYmFzZVZhbHVlKSA9PiB7XG4gICAgICBpZiAoYmFzZVZhbHVlLnR5cGUgIT09IFwiYXJyYXlcIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjb25zdCBkYXRhID0gYmFzZVZhbHVlLmRhdGEsIGZpbmFsSW5kZXggPSBpbmRleCA8IDAgPyBpbmRleCArIGRhdGEubGVuZ3RoIDogaW5kZXg7XG4gICAgICByZXR1cm4gZnJvbUpTKGRhdGFbZmluYWxJbmRleF0pO1xuICAgIH1cbiAgKSxcbiAgU2xpY2U6IG1hcHBlZEV4ZWN1dG9yKFxuICAgICh7IGJhc2UgfSkgPT4gW2Jhc2VdLFxuICAgICh7IGxlZnQsIHJpZ2h0LCBpc0luY2x1c2l2ZSB9LCBiYXNlVmFsdWUpID0+IHtcbiAgICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gXCJhcnJheVwiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGNvbnN0IGFycmF5MiA9IGJhc2VWYWx1ZS5kYXRhO1xuICAgICAgbGV0IGxlZnRJZHggPSBsZWZ0LCByaWdodElkeCA9IHJpZ2h0O1xuICAgICAgcmV0dXJuIGxlZnRJZHggPCAwICYmIChsZWZ0SWR4ID0gYXJyYXkyLmxlbmd0aCArIGxlZnRJZHgpLCByaWdodElkeCA8IDAgJiYgKHJpZ2h0SWR4ID0gYXJyYXkyLmxlbmd0aCArIHJpZ2h0SWR4KSwgaXNJbmNsdXNpdmUgJiYgcmlnaHRJZHgrKywgbGVmdElkeCA8IDAgJiYgKGxlZnRJZHggPSAwKSwgcmlnaHRJZHggPCAwICYmIChyaWdodElkeCA9IDApLCBmcm9tQXJyYXkoYXJyYXkyLnNsaWNlKGxlZnRJZHgsIHJpZ2h0SWR4KSk7XG4gICAgfVxuICApLFxuICBEZXJlZjoge1xuICAgIGV4ZWN1dGVTeW5jKHsgYmFzZSB9LCBzY29wZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBleGVjdXRlU3luYyhiYXNlLCBzY29wZSk7XG4gICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjb25zdCBpZCA9IHZhbHVlLmRhdGEuX3JlZjtcbiAgICAgIGlmICh0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBpZiAoc2NvcGUuY29udGV4dC5kZXJlZmVyZW5jZSkge1xuICAgICAgICBjb25zdCB2YWx1ZTIgPSBzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKHsgX3JlZjogaWQgfSk7XG4gICAgICAgIGlmICh2YWx1ZTIgJiYgdHlwZW9mIHZhbHVlMiA9PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHZhbHVlMilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZXJlZmVyZW5jZSByZXR1cm5lZCBwcm9taXNlIGluIHN5bmNocm9ub3VzIG1vZGVcIik7XG4gICAgICAgIHJldHVybiBmcm9tSlModmFsdWUyKTtcbiAgICAgIH1cbiAgICAgIGlmIChzY29wZS5zb3VyY2UudHlwZSAhPT0gXCJhcnJheVwiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGZvciAoY29uc3QgZG9jIG9mIHNjb3BlLnNvdXJjZS5kYXRhKVxuICAgICAgICBpZiAoZG9jICYmIHR5cGVvZiBkb2MgPT0gXCJvYmplY3RcIiAmJiBcIl9pZFwiIGluIGRvYyAmJiBpZCA9PT0gZG9jLl9pZClcbiAgICAgICAgICByZXR1cm4gZnJvbUpTKGRvYyk7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9LFxuICAgIGFzeW5jIGV4ZWN1dGVBc3luYyh7IGJhc2UgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGJhc2UsIHNjb3BlKTtcbiAgICAgIGlmICghc2NvcGUuc291cmNlLmlzQXJyYXkoKSB8fCB2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGNvbnN0IGlkID0gdmFsdWUuZGF0YS5fcmVmO1xuICAgICAgaWYgKHR5cGVvZiBpZCAhPSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGlmIChzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKVxuICAgICAgICByZXR1cm4gZnJvbUpTKGF3YWl0IHNjb3BlLmNvbnRleHQuZGVyZWZlcmVuY2UoeyBfcmVmOiBpZCB9KSk7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBzY29wZS5zb3VyY2UpXG4gICAgICAgIGlmIChkb2MudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBpZCA9PT0gZG9jLmRhdGEuX2lkKVxuICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gIH0sXG4gIFZhbHVlOiBjb25zdGFudEV4ZWN1dG9yKCh7IHZhbHVlIH0pID0+IGZyb21KUyh2YWx1ZSkpLFxuICBHcm91cDoge1xuICAgIGV4ZWN1dGVTeW5jKHsgYmFzZSB9LCBzY29wZSkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVTeW5jKGJhc2UsIHNjb3BlKTtcbiAgICB9LFxuICAgIGV4ZWN1dGVBc3luYyh7IGJhc2UgfSwgc2NvcGUpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQXN5bmMoYmFzZSwgc2NvcGUpO1xuICAgIH1cbiAgfSxcbiAgT2JqZWN0OiB7XG4gICAgZXhlY3V0ZVN5bmMoeyBhdHRyaWJ1dGVzIH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJUeXBlID0gYXR0ci50eXBlO1xuICAgICAgICBzd2l0Y2ggKGF0dHIudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiOiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV4ZWN1dGVTeW5jKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIHJlc3VsdFthdHRyLm5hbWVdID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiOiB7XG4gICAgICAgICAgICBjb25zdCBjb25kID0gZXhlY3V0ZVN5bmMoYXR0ci5jb25kaXRpb24sIHNjb3BlKTtcbiAgICAgICAgICAgIGlmIChjb25kLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IGNvbmQuZGF0YSA9PT0gITEpXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBleGVjdXRlU3luYyhhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgICB2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiT2JqZWN0U3BsYXRcIjoge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBleGVjdXRlU3luYyhhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgICB2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHthdHRyVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21KUyhyZXN1bHQpO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgYXR0cmlidXRlcyB9LCBzY29wZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBhdHRyVHlwZSA9IGF0dHIudHlwZTtcbiAgICAgICAgc3dpdGNoIChhdHRyLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIjoge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlQXN5bmMoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgcmVzdWx0W2F0dHIubmFtZV0gPSBhd2FpdCB2YWx1ZS5nZXQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiOiB7XG4gICAgICAgICAgICBjb25zdCBjb25kID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGF0dHIuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICAgICAgICBpZiAoY29uZC50eXBlICE9PSBcImJvb2xlYW5cIiB8fCBjb25kLmRhdGEgPT09ICExKVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJPYmplY3RTcGxhdFwiOiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgICB2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHthdHRyVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21KUyhyZXN1bHQpO1xuICAgIH1cbiAgfSxcbiAgQXJyYXk6IHtcbiAgICBleGVjdXRlU3luYyh7IGVsZW1lbnRzIH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGV4ZWN1dGVTeW5jKGVsZW1lbnQudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNTcGxhdCkge1xuICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUuZGF0YSlcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2godik7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlLmRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheShyZXN1bHQpO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgZWxlbWVudHMgfSwgc2NvcGUpIHtcbiAgICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlQXN5bmMoZWxlbWVudC52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIGlmIChlbGVtZW50LmlzU3BsYXQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pc0FycmF5KCkpXG4gICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgdiBvZiB2YWx1ZSlcbiAgICAgICAgICAgICAgICB5aWVsZCB2O1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgVHVwbGU6IGNvbnN0YW50RXhlY3V0b3IoKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcInR1cGxlcyBjYW4gbm90IGJlIGV2YWx1YXRlZFwiKTtcbiAgfSksXG4gIE9yOiBtYXBwZWRFeGVjdXRvcihcbiAgICAoeyBsZWZ0LCByaWdodCB9KSA9PiBbbGVmdCwgcmlnaHRdLFxuICAgIChfLCBsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpID0+IGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBsZWZ0VmFsdWUuZGF0YSA9PT0gITAgfHwgcmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiByaWdodFZhbHVlLmRhdGEgPT09ICEwID8gVFJVRV9WQUxVRSA6IGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiID8gTlVMTF9WQUxVRSA6IEZBTFNFX1ZBTFVFXG4gICksXG4gIEFuZDogbWFwcGVkRXhlY3V0b3IoXG4gICAgKHsgbGVmdCwgcmlnaHQgfSkgPT4gW2xlZnQsIHJpZ2h0XSxcbiAgICAoXywgbGVmdFZhbHVlLCByaWdodFZhbHVlKSA9PiBsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgbGVmdFZhbHVlLmRhdGEgPT09ICExIHx8IHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmlnaHRWYWx1ZS5kYXRhID09PSAhMSA/IEZBTFNFX1ZBTFVFIDogbGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgPyBOVUxMX1ZBTFVFIDogVFJVRV9WQUxVRVxuICApLFxuICBOb3Q6IG1hcHBlZEV4ZWN1dG9yKFxuICAgICh7IGJhc2UgfSkgPT4gW2Jhc2VdLFxuICAgIChfLCB2YWx1ZSkgPT4gdmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgPyBOVUxMX1ZBTFVFIDogdmFsdWUuZGF0YSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRVxuICApLFxuICBOZWc6IG1hcHBlZEV4ZWN1dG9yKFxuICAgICh7IGJhc2UgfSkgPT4gW2Jhc2VdLFxuICAgIChfLCB2YWx1ZSkgPT4gdmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiA/IE5VTExfVkFMVUUgOiBmcm9tTnVtYmVyKC12YWx1ZS5kYXRhKVxuICApLFxuICBQb3M6IG1hcHBlZEV4ZWN1dG9yKFxuICAgICh7IGJhc2UgfSkgPT4gW2Jhc2VdLFxuICAgIChfLCB2YWx1ZSkgPT4gdmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiA/IE5VTExfVkFMVUUgOiBmcm9tTnVtYmVyKHZhbHVlLmRhdGEpXG4gICksXG4gIEFzYzogY29uc3RhbnRFeGVjdXRvcigoKSA9PiBOVUxMX1ZBTFVFKSxcbiAgRGVzYzogY29uc3RhbnRFeGVjdXRvcigoKSA9PiBOVUxMX1ZBTFVFKSxcbiAgQXJyYXlDb2VyY2U6IHtcbiAgICBleGVjdXRlU3luYyh7IGJhc2UgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZXhlY3V0ZVN5bmMoYmFzZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIHZhbHVlLmlzQXJyYXkoKSA/IHZhbHVlIDogTlVMTF9WQUxVRTtcbiAgICB9LFxuICAgIGFzeW5jIGV4ZWN1dGVBc3luYyh7IGJhc2UgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGJhc2UsIHNjb3BlKTtcbiAgICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyB2YWx1ZSA6IE5VTExfVkFMVUU7XG4gICAgfVxuICB9LFxuICBNYXA6IGFycmF5RXhlY3V0b3IoXG4gICAgKHsgYmFzZSwgZXhwciB9KSA9PiAoeyBhcnJheTogYmFzZSwgaW5uZXI6IGV4cHIgfSksXG4gICAgZnVuY3Rpb24qIChfLCBfaXRlbSwgaW5uZXIpIHtcbiAgICAgIHlpZWxkIGlubmVyO1xuICAgIH0sXG4gICAgeyBoaWRkZW46ICEwIH1cbiAgKSxcbiAgRmxhdE1hcDogYXJyYXlFeGVjdXRvcihcbiAgICAoeyBiYXNlLCBleHByIH0pID0+ICh7IGFycmF5OiBiYXNlLCBpbm5lcjogZXhwciB9KSxcbiAgICBmdW5jdGlvbiogKF8sIF9pdGVtLCBpbm5lcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5uZXIpKVxuICAgICAgICBmb3IgKGNvbnN0IGlubmVySW5uZXIgb2YgaW5uZXIpXG4gICAgICAgICAgeWllbGQgaW5uZXJJbm5lcjtcbiAgICAgIGVsc2VcbiAgICAgICAgeWllbGQgaW5uZXI7XG4gICAgfSxcbiAgICB7IGhpZGRlbjogITAgfVxuICApXG59O1xuZnVuY3Rpb24gZXZhbHVhdGVRdWVyeSh0cmVlLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIGV4ZWN1dGVBc3luYyh0cmVlLCBzY29wZUZyb21PcHRpb25zKG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnlTeW5jKHRyZWUsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gZXhlY3V0ZVN5bmModHJlZSwgc2NvcGVGcm9tT3B0aW9ucyhvcHRpb25zKSk7XG59XG5mdW5jdGlvbiBzY29wZUZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3Qgcm9vdCA9IGZyb21KUyhvcHRpb25zLnJvb3QpLCBkYXRhc2V0ID0gZnJvbUpTKG9wdGlvbnMuZGF0YXNldCksIHBhcmFtcyA9IHsgLi4ub3B0aW9ucy5wYXJhbXMgfTtcbiAgcmV0dXJuIG5ldyBTY29wZSQxKFxuICAgIHBhcmFtcyxcbiAgICBkYXRhc2V0LFxuICAgIHJvb3QsXG4gICAge1xuICAgICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCB8fCAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgIGlkZW50aXR5OiBvcHRpb25zLmlkZW50aXR5ID09PSB2b2lkIDAgPyBcIm1lXCIgOiBvcHRpb25zLmlkZW50aXR5LFxuICAgICAgc2FuaXR5OiBvcHRpb25zLnNhbml0eSxcbiAgICAgIGFmdGVyOiBvcHRpb25zLmFmdGVyID8gZnJvbUpTKG9wdGlvbnMuYWZ0ZXIpIDogbnVsbCxcbiAgICAgIGJlZm9yZTogb3B0aW9ucy5iZWZvcmUgPyBmcm9tSlMob3B0aW9ucy5iZWZvcmUpIDogbnVsbCxcbiAgICAgIGRlcmVmZXJlbmNlOiBvcHRpb25zLmRlcmVmZXJlbmNlXG4gICAgfSxcbiAgICBudWxsXG4gICk7XG59XG5mdW5jdGlvbiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUuYmFzZSk7XG4gICAgY2FzZSBcIlZhbHVlXCI6XG4gICAgY2FzZSBcIlBhcmFtZXRlclwiOlxuICAgICAgcmV0dXJuICEwO1xuICAgIGNhc2UgXCJQb3NcIjpcbiAgICBjYXNlIFwiTmVnXCI6XG4gICAgICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLmJhc2UpO1xuICAgIGNhc2UgXCJPcENhbGxcIjpcbiAgICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICBjYXNlIFwiJVwiOlxuICAgICAgICBjYXNlIFwiKipcIjpcbiAgICAgICAgICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLmxlZnQpICYmIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5yaWdodCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNvbnN0IERVTU1ZX1NDT1BFID0gbmV3IFNjb3BlJDEoXG4gIHt9LFxuICBOVUxMX1ZBTFVFLFxuICBOVUxMX1ZBTFVFLFxuICB7IHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApLCBpZGVudGl0eTogXCJtZVwiLCBiZWZvcmU6IG51bGwsIGFmdGVyOiBudWxsIH0sXG4gIG51bGxcbik7XG5mdW5jdGlvbiB0cnlDb25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkgPyBjb25zdGFudEV2YWx1YXRlKG5vZGUpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICByZXR1cm4gZXhlY3V0ZVN5bmMobm9kZSwgRFVNTVlfU0NPUEUpO1xufVxuZnVuY3Rpb24gaXNTZWxlY3Rvck5vZGUobm9kZSkge1xuICByZXR1cm4gW1xuICAgIFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgXCJTZWxlY3RvckZ1bmNDYWxsXCIsXG4gICAgXCJHcm91cFwiLFxuICAgIFwiVHVwbGVcIixcbiAgICBcIkFycmF5Q29lcmNlXCIsXG4gICAgXCJGaWx0ZXJcIixcbiAgICBcIlNlbGVjdG9yTmVzdGVkXCJcbiAgXS5pbmNsdWRlcyhub2RlLnR5cGUpO1xufVxuZnVuY3Rpb24gaXNTZWxlY3Rvck5lc3RlZChub2RlKSB7XG4gIHJldHVybiBbXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgXCJBcnJheUNvZXJjZVwiLCBcIkZpbHRlclwiLCBcIkdyb3VwXCIsIFwiVHVwbGVcIiwgXCJTZWxlY3Rvck5lc3RlZFwiXS5pbmNsdWRlcyhcbiAgICBub2RlLnR5cGVcbiAgKTtcbn1cbmNvbnN0IGFycmF5ID0ge307XG5hcnJheS5qb2luID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgYXJyLCBzZXApID0+IHtcbiAgICBpZiAoYXJyLnR5cGUgIT09IFwiYXJyYXlcIiB8fCBzZXAudHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGxldCBidWYgPSBcIlwiLCBuZWVkU2VwID0gITE7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIGFyci5kYXRhKSB7XG4gICAgICBzd2l0Y2ggKG5lZWRTZXAgJiYgKGJ1ZiArPSBzZXAuZGF0YSksIGdldFR5cGUoZWxlbSkpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICAgIGJ1ZiArPSBgJHtlbGVtfWA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICBuZWVkU2VwID0gITA7XG4gICAgfVxuICAgIHJldHVybiBmcm9tU3RyaW5nKGJ1Zik7XG4gIH1cbik7XG5hcnJheS5qb2luLmFyaXR5ID0gMjtcbmFycmF5LmNvbXBhY3QgPSBhcnJheUV4ZWN1dG9yKFxuICAoW2FycmF5Ml0pID0+ICh7IGFycmF5OiBhcnJheTIgfSksXG4gIGZ1bmN0aW9uKiAoXywgaXRlbSkge1xuICAgIGl0ZW0gIT09IG51bGwgJiYgKHlpZWxkIGl0ZW0pO1xuICB9XG4pO1xuYXJyYXkuY29tcGFjdC5hcml0eSA9IDE7XG5hcnJheS51bmlxdWUgPSBhcnJheUV4ZWN1dG9yKFxuICAoYXJncykgPT4gKHsgYXJyYXk6IGFyZ3NbMF0sIHN0YXRlOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpIH0pLFxuICBmdW5jdGlvbiogKF9ub2RlLCBpdGVyLCBfaW5uZXIsIGFkZGVkKSB7XG4gICAgc3dpdGNoIChnZXRUeXBlKGl0ZXIpKSB7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgIGFkZGVkLmhhcyhpdGVyKSB8fCAoYWRkZWQuYWRkKGl0ZXIpLCB5aWVsZCBpdGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB5aWVsZCBpdGVyO1xuICAgIH1cbiAgfVxuKTtcbmFycmF5LnVuaXF1ZS5hcml0eSA9IDE7XG5hcnJheS5pbnRlcnNlY3RzID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgYXJyMSwgYXJyMikgPT4ge1xuICAgIGlmIChhcnIxLnR5cGUgIT09IFwiYXJyYXlcIiB8fCBhcnIyLnR5cGUgIT09IFwiYXJyYXlcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGZvciAoY29uc3QgdjEgb2YgYXJyMS5kYXRhKVxuICAgICAgZm9yIChjb25zdCB2MiBvZiBhcnIyLmRhdGEpXG4gICAgICAgIGlmIChpc0VxdWFsKGZyb21KUyh2MSksIGZyb21KUyh2MikpKVxuICAgICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgfVxuKTtcbmFycmF5LmludGVyc2VjdHMuYXJpdHkgPSAyO1xuY29uc3QgZGF0ZVRpbWUgPSB7fTtcbmRhdGVUaW1lLm5vdyA9IGNvbnN0YW50RXhlY3V0b3IoXG4gIChfLCBzY29wZSkgPT4gZnJvbURhdGVUaW1lKG5ldyBEYXRlVGltZShzY29wZS5jb250ZXh0LnRpbWVzdGFtcCkpXG4pO1xuZGF0ZVRpbWUubm93LmFyaXR5ID0gMDtcbmFzeW5jIGZ1bmN0aW9uIHZhbHVlQXRQYXRoKGFyZywga2V5UGF0aCkge1xuICBmdW5jdGlvbiB0cnlBY2Nlc3NvcihhcmcyLCBhY2Nlc3Nvcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXJnMlthY2Nlc3Nvcl07XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGxldCBjdXJyZW50ID0gYXdhaXQgYXJnLmdldCgpO1xuICBmb3IgKGNvbnN0IHBhcnQgb2Yga2V5UGF0aClcbiAgICBpZiAoY3VycmVudCA9IHRyeUFjY2Vzc29yKGN1cnJlbnQsIHBhcnQpLCAhY3VycmVudCkgYnJlYWs7XG4gIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gc3RhcnRzV2l0aChrZXlQYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIHByZWZpeC5ldmVyeSgoaXRlbSwgaW5kZXgpID0+IGtleVBhdGhbaW5kZXhdID09PSBpdGVtKTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBkaWZmS2V5UGF0aHMoYmVmb3JlLCBhZnRlcikge1xuICBjb25zdCBjdXJyUGF0aHMgPSBbW11dO1xuICBmb3IgKDsgY3VyclBhdGhzLmxlbmd0aCA+IDA7ICkge1xuICAgIGNvbnN0IGN1cnJQYXRoID0gY3VyclBhdGhzLnNoaWZ0KCkgfHwgW10sIGIgPSBmcm9tSlMoYXdhaXQgdmFsdWVBdFBhdGgoYmVmb3JlLCBjdXJyUGF0aCkpLCBhID0gZnJvbUpTKGF3YWl0IHZhbHVlQXRQYXRoKGFmdGVyLCBjdXJyUGF0aCkpO1xuICAgIGlmIChhLnR5cGUgIT09IGIudHlwZSlcbiAgICAgIHlpZWxkIGN1cnJQYXRoO1xuICAgIGVsc2UgaWYgKGEudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBiLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgYS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBiLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IGEudHlwZSA9PT0gXCJudWxsXCIgJiYgYi50eXBlID09PSBcIm51bGxcIiB8fCBhLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgYi50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgYS5kYXRhICE9PSBiLmRhdGEgJiYgKHlpZWxkIGN1cnJQYXRoKTtcbiAgICBlbHNlIGlmIChhLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiBiLnR5cGUgPT09IFwiZGF0ZXRpbWVcIilcbiAgICAgIGEuZGF0YS5lcXVhbHMoYi5kYXRhKSB8fCAoeWllbGQgY3VyclBhdGgpO1xuICAgIGVsc2UgaWYgKGEudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBiLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGEuZGF0YSwgYi5kYXRhKSkge1xuICAgICAgICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGEuZGF0YSksIGJLZXlzID0gT2JqZWN0LmtleXMoYi5kYXRhKTtcbiAgICAgICAgbmV3IFNldChhS2V5cy5jb25jYXQoYktleXMpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICBjdXJyUGF0aHMucHVzaChbLi4uY3VyclBhdGgsIGtleV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGEudHlwZSA9PT0gXCJhcnJheVwiICYmIGIudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICBpZiAoYS5kYXRhLmxlbmd0aCAhPT0gYi5kYXRhLmxlbmd0aClcbiAgICAgICAgeWllbGQgY3VyclBhdGg7XG4gICAgICBlbHNlIGlmICghZGVlcEVxdWFsKGEuZGF0YSwgYi5kYXRhKSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiLmRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgY3VyclBhdGhzLnB1c2goWy4uLmN1cnJQYXRoLCBpXSk7XG4gICAgfSBlbHNlIGlmIChhLnR5cGUgPT09IFwic3RyZWFtXCIgJiYgYi50eXBlID09PSBcInN0cmVhbVwiKSB7XG4gICAgICBjb25zdCBhcnJheUEgPSBhd2FpdCBhLmdldCgpLCBhcnJheUIgPSBhd2FpdCBiLmdldCgpO1xuICAgICAgaWYgKGFycmF5QS5sZW5ndGggIT09IGFycmF5Qi5sZW5ndGgpXG4gICAgICAgIHlpZWxkIGN1cnJQYXRoO1xuICAgICAgZWxzZSBpZiAoIWRlZXBFcXVhbChhcnJheUEsIGFycmF5QikpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlCLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIGN1cnJQYXRocy5wdXNoKFsuLi5jdXJyUGF0aCwgaV0pO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVTZWxlY3Rvcihub2RlLCB2YWx1ZSwgc2NvcGUpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgIHJldHVybiBhd2FpdCBldmFsdWF0ZVNlbGVjdG9yKG5vZGUuYmFzZSwgdmFsdWUsIHNjb3BlKTtcbiAgICBjYXNlIFwiVHVwbGVcIjpcbiAgICAgIGNvbnN0IHR1cGxlUGF0aHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIG5vZGUubWVtYmVycykge1xuICAgICAgICBjb25zdCBtZW1iZXJQYXRocyA9IGF3YWl0IGV2YWx1YXRlU2VsZWN0b3IobWVtYmVyLCB2YWx1ZSwgc2NvcGUpO1xuICAgICAgICB0dXBsZVBhdGhzLnB1c2goLi4ubWVtYmVyUGF0aHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR1cGxlUGF0aHM7XG4gICAgY2FzZSBcIkFjY2Vzc0F0dHJpYnV0ZVwiOlxuICAgICAgcmV0dXJuIG5vZGUuYmFzZSA/IChhd2FpdCBldmFsdWF0ZVNlbGVjdG9yKG5vZGUuYmFzZSwgdmFsdWUsIHNjb3BlKSkubWFwKChwYXRoKSA9PiBbLi4ucGF0aCwgbm9kZS5uYW1lXSkgOiBbW25vZGUubmFtZV1dO1xuICAgIGNhc2UgXCJBcnJheUNvZXJjZVwiOiB7XG4gICAgICBjb25zdCBwYXRocyA9IGF3YWl0IGV2YWx1YXRlU2VsZWN0b3Iobm9kZS5iYXNlLCB2YWx1ZSwgc2NvcGUpLCBhcnJheVBhdGhzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleVBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgY29uc3QgaW5uZXJWYWx1ZSA9IGF3YWl0IHZhbHVlQXRQYXRoKHZhbHVlLCBrZXlQYXRoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5uZXJWYWx1ZSkpXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lclZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgYXJyYXlQYXRocy5wdXNoKFsuLi5rZXlQYXRoLCBpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlQYXRocztcbiAgICB9XG4gICAgY2FzZSBcIkZpbHRlclwiOiB7XG4gICAgICBjb25zdCBwYXRocyA9IGF3YWl0IGV2YWx1YXRlU2VsZWN0b3Iobm9kZS5iYXNlLCB2YWx1ZSwgc2NvcGUpLCBmaWx0ZXIgPSB7XG4gICAgICAgIC4uLm5vZGUsXG4gICAgICAgIGJhc2U6IHsgdHlwZTogXCJUaGlzXCIgfVxuICAgICAgfSwgYXJyYXlQYXRocyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXlQYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGNvbnN0IGlubmVyVmFsdWUgPSBhd2FpdCB2YWx1ZUF0UGF0aCh2YWx1ZSwga2V5UGF0aCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlubmVyVmFsdWUpKVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5uZXJWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGlubmVyVmFsdWVbaV0sIG5lc3RlZFNjb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGZyb21KUyhbaXRlbV0pKTtcbiAgICAgICAgICAgIChhd2FpdCAoYXdhaXQgZXZhbHVhdGUoZmlsdGVyLCBuZXN0ZWRTY29wZSkpLmdldCgpKS5sZW5ndGggPiAwICYmIGFycmF5UGF0aHMucHVzaChbLi4ua2V5UGF0aCwgaV0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVBhdGhzO1xuICAgIH1cbiAgICBjYXNlIFwiU2VsZWN0b3JGdW5jQ2FsbFwiOlxuICAgICAgcmV0dXJuIGFueXdoZXJlKG5vZGUuYXJnLCBzY29wZS5jcmVhdGVIaWRkZW4odmFsdWUpKTtcbiAgICBjYXNlIFwiU2VsZWN0b3JOZXN0ZWRcIjoge1xuICAgICAgY29uc3QgeyBiYXNlLCBuZXN0ZWQ6IGV4cHIgfSA9IG5vZGUsIHBhdGhzID0gYXdhaXQgZXZhbHVhdGVTZWxlY3RvcihiYXNlLCB2YWx1ZSwgc2NvcGUpLCBuZXN0ZWRQYXRocyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXlQYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGNvbnN0IGlubmVyVmFsdWUgPSBhd2FpdCB2YWx1ZUF0UGF0aCh2YWx1ZSwga2V5UGF0aCk7XG4gICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIkFjY2Vzc0F0dHJpYnV0ZVwiOlxuICAgICAgICAgIGNhc2UgXCJBcnJheUNvZXJjZVwiOlxuICAgICAgICAgIGNhc2UgXCJGaWx0ZXJcIjpcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1BhdGhzID0gYXdhaXQgZXZhbHVhdGVTZWxlY3RvcihleHByLCBmcm9tSlMoaW5uZXJWYWx1ZSksIHNjb3BlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjZXNzUGF0aHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgIG5lc3RlZFBhdGhzLnB1c2goWy4uLmtleVBhdGgsIC4uLmFjY2Vzc1BhdGhzW2ldXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgICAgICAgIGNvbnN0IGlubmVyUmVzdWx0ID0gYXdhaXQgZXZhbHVhdGVTZWxlY3RvcihleHByLmJhc2UsIGZyb21KUyhpbm5lclZhbHVlKSwgc2NvcGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbm5lcktleVBhdGggb2YgaW5uZXJSZXN1bHQpXG4gICAgICAgICAgICAgIG5lc3RlZFBhdGhzLnB1c2goWy4uLmtleVBhdGgsIC4uLmlubmVyS2V5UGF0aF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlR1cGxlXCI6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIGV4cHIubWVtYmVycykge1xuICAgICAgICAgICAgICBjb25zdCBpbm5lclJlc3VsdDIgPSBhd2FpdCBldmFsdWF0ZVNlbGVjdG9yKGlubmVyLCBmcm9tSlMoaW5uZXJWYWx1ZSksIHNjb3BlKTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpbm5lcktleVBhdGggb2YgaW5uZXJSZXN1bHQyKVxuICAgICAgICAgICAgICAgIG5lc3RlZFBhdGhzLnB1c2goWy4uLmtleVBhdGgsIC4uLmlubmVyS2V5UGF0aF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmVzdGVkUGF0aHM7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBhbnl3aGVyZShleHByLCBzY29wZSwgYmFzZSA9IFtdKSB7XG4gIGNvbnN0IHZhbHVlID0gc2NvcGUudmFsdWUsIHBhdGhMaXN0ID0gW107XG4gIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICBjb25zdCBhcnIgPSBhd2FpdCB2YWx1ZS5nZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3ViUGF0aHMgPSBhd2FpdCBhbnl3aGVyZShleHByLCBzY29wZS5jcmVhdGVIaWRkZW4oZnJvbUpTKGFycltpXSkpLCBbLi4uYmFzZSwgaV0pO1xuICAgICAgcGF0aExpc3QucHVzaCguLi5zdWJQYXRocyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmFsdWF0ZShleHByLCBzY29wZSk7XG4gICAgcmVzdWx0LnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlc3VsdC5kYXRhID09PSAhMCAmJiBwYXRoTGlzdC5wdXNoKGJhc2UpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlLmRhdGEpKSB7XG4gICAgICBjb25zdCBzdWJQYXRocyA9IGF3YWl0IGFueXdoZXJlKGV4cHIsIHNjb3BlLmNyZWF0ZUhpZGRlbihmcm9tSlModmFsdWUuZGF0YVtrZXldKSksIFtcbiAgICAgICAgLi4uYmFzZSxcbiAgICAgICAga2V5XG4gICAgICBdKTtcbiAgICAgIHBhdGhMaXN0LnB1c2goLi4uc3ViUGF0aHMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aExpc3Q7XG59XG5hc3luYyBmdW5jdGlvbiBjaGFuZ2VkQW55KGJlZm9yZSwgYWZ0ZXIsIHNlbGVjdG9yLCBzY29wZSkge1xuICBjb25zdCBiZWZvcmVTZWxlY3RvclNjb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGJlZm9yZSksIGJlZm9yZVBhdGhzID0gYXdhaXQgZXZhbHVhdGVTZWxlY3RvcihcbiAgICBzZWxlY3RvcixcbiAgICBiZWZvcmVTZWxlY3RvclNjb3BlLnZhbHVlLFxuICAgIGJlZm9yZVNlbGVjdG9yU2NvcGVcbiAgKSwgYWZ0ZXJTZWxlY3RvclNjb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGFmdGVyKSwgYWZ0ZXJQYXRocyA9IGF3YWl0IGV2YWx1YXRlU2VsZWN0b3Ioc2VsZWN0b3IsIGFmdGVyU2VsZWN0b3JTY29wZS52YWx1ZSwgYWZ0ZXJTZWxlY3RvclNjb3BlKTtcbiAgaWYgKGJlZm9yZVBhdGhzLmxlbmd0aCAhPT0gYWZ0ZXJQYXRocy5sZW5ndGgpXG4gICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBiZWZvcmVQYXRocykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKylcbiAgICAgIGlmICh0eXBlb2YgcGF0aFtpXSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNvbnN0IHNsaWNlID0gcGF0aC5zbGljZSgwLCBpKSwgYmVmb3JlQXJyID0gYXdhaXQgdmFsdWVBdFBhdGgoYmVmb3JlLCBzbGljZSksIGFmdGVyQXJyID0gYXdhaXQgdmFsdWVBdFBhdGgoYWZ0ZXIsIHNsaWNlKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJlZm9yZUFycikgfHwgIUFycmF5LmlzQXJyYXkoYWZ0ZXJBcnIpIHx8IGJlZm9yZUFyci5sZW5ndGggIT09IGFmdGVyQXJyLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIH1cbiAgICBjb25zdCBiZWZvcmVWYWx1ZSA9IGF3YWl0IHZhbHVlQXRQYXRoKGJlZm9yZSwgcGF0aCksIGFmdGVyVmFsdWUgPSBhd2FpdCB2YWx1ZUF0UGF0aChhZnRlciwgcGF0aCk7XG4gICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlVmFsdWUsIGFmdGVyVmFsdWUpKVxuICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xufVxuYXN5bmMgZnVuY3Rpb24gY2hhbmdlZE9ubHkoYmVmb3JlLCBhZnRlciwgc2VsZWN0b3IsIHNjb3BlKSB7XG4gIGNvbnN0IGJlZm9yZVNlbGVjdG9yU2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oYmVmb3JlKSwgc2VsZWN0ZWRQYXRocyA9IGF3YWl0IGV2YWx1YXRlU2VsZWN0b3IoXG4gICAgc2VsZWN0b3IsXG4gICAgYmVmb3JlU2VsZWN0b3JTY29wZS52YWx1ZSxcbiAgICBiZWZvcmVTZWxlY3RvclNjb3BlXG4gICk7XG4gIGZvciBhd2FpdCAoY29uc3QgZGlmZlBhdGggb2YgZGlmZktleVBhdGhzKGJlZm9yZSwgYWZ0ZXIpKSB7XG4gICAgbGV0IGZvdW5kID0gITE7XG4gICAgZm9yIChjb25zdCBzZWxlY3RlZFBhdGggb2Ygc2VsZWN0ZWRQYXRocylcbiAgICAgIGlmIChzdGFydHNXaXRoKGRpZmZQYXRoLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgIGZvdW5kID0gITA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGlmICghZm91bmQpXG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIFRSVUVfVkFMVUU7XG59XG5jb25zdCBkaWZmID0ge307XG5kaWZmLmNoYW5nZWRBbnkgPSBhc3luY09ubHlFeGVjdXRvcihhc3luYyAoYXJncywgc2NvcGUpID0+IHtcbiAgY29uc3QgbGhzID0gYXJnc1swXSwgcmhzID0gYXJnc1sxXSwgc2VsZWN0b3IgPSBhcmdzWzJdO1xuICBpZiAoIWlzU2VsZWN0b3JOb2RlKHNlbGVjdG9yKSkgdGhyb3cgbmV3IEVycm9yKFwiY2hhbmdlZEFueSB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIGEgc2VsZWN0b3JcIik7XG4gIGNvbnN0IGJlZm9yZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhsaHMsIHNjb3BlKSwgYWZ0ZXIgPSBhd2FpdCBleGVjdXRlQXN5bmMocmhzLCBzY29wZSk7XG4gIHJldHVybiBjaGFuZ2VkQW55KGJlZm9yZSwgYWZ0ZXIsIHNlbGVjdG9yLCBzY29wZSk7XG59KTtcbmRpZmYuY2hhbmdlZEFueS5hcml0eSA9IDM7XG5kaWZmLmNoYW5nZWRPbmx5ID0gYXN5bmNPbmx5RXhlY3V0b3IoYXN5bmMgKGFyZ3MsIHNjb3BlKSA9PiB7XG4gIGNvbnN0IGxocyA9IGFyZ3NbMF0sIHJocyA9IGFyZ3NbMV0sIHNlbGVjdG9yID0gYXJnc1syXTtcbiAgaWYgKCFpc1NlbGVjdG9yTm9kZShzZWxlY3RvcikpIHRocm93IG5ldyBFcnJvcihcImNoYW5nZWRPbmx5IHRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBzZWxlY3RvclwiKTtcbiAgY29uc3QgYmVmb3JlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGxocywgc2NvcGUpLCBhZnRlciA9IGF3YWl0IGV4ZWN1dGVBc3luYyhyaHMsIHNjb3BlKTtcbiAgcmV0dXJuIGNoYW5nZWRPbmx5KGJlZm9yZSwgYWZ0ZXIsIHNlbGVjdG9yLCBzY29wZSk7XG59KTtcbmRpZmYuY2hhbmdlZE9ubHkuYXJpdHkgPSAzO1xuY29uc3QgZGVsdGEgPSB7fTtcbmRlbHRhLm9wZXJhdGlvbiA9IGNvbnN0YW50RXhlY3V0b3IoKF8sIHNjb3BlKSA9PiB7XG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsLCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gIHJldHVybiBoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIgPyBmcm9tU3RyaW5nKFwidXBkYXRlXCIpIDogaGFzQWZ0ZXIgPyBmcm9tU3RyaW5nKFwiY3JlYXRlXCIpIDogaGFzQmVmb3JlID8gZnJvbVN0cmluZyhcImRlbGV0ZVwiKSA6IE5VTExfVkFMVUU7XG59KTtcbmRlbHRhLmNoYW5nZWRBbnkgPSBhc3luY09ubHlFeGVjdXRvcihhc3luYyAoYXJncywgc2NvcGUpID0+IHtcbiAgY29uc3QgYmVmb3JlID0gc2NvcGUuY29udGV4dC5iZWZvcmUgfHwgTlVMTF9WQUxVRSwgYWZ0ZXIgPSBzY29wZS5jb250ZXh0LmFmdGVyIHx8IE5VTExfVkFMVUUsIHNlbGVjdG9yID0gYXJnc1swXTtcbiAgaWYgKCFpc1NlbGVjdG9yTm9kZShzZWxlY3RvcikpIHRocm93IG5ldyBFcnJvcihcImNoYW5nZWRBbnkgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHNlbGVjdG9yXCIpO1xuICByZXR1cm4gY2hhbmdlZEFueShiZWZvcmUsIGFmdGVyLCBzZWxlY3Rvciwgc2NvcGUpO1xufSk7XG5kZWx0YS5jaGFuZ2VkQW55LmFyaXR5ID0gMTtcbmRlbHRhLmNoYW5nZWRBbnkubW9kZSA9IFwiZGVsdGFcIjtcbmRlbHRhLmNoYW5nZWRPbmx5ID0gYXN5bmNPbmx5RXhlY3V0b3IoYXN5bmMgKGFyZ3MsIHNjb3BlKSA9PiB7XG4gIGNvbnN0IGJlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlIHx8IE5VTExfVkFMVUUsIGFmdGVyID0gc2NvcGUuY29udGV4dC5hZnRlciB8fCBOVUxMX1ZBTFVFLCBzZWxlY3RvciA9IGFyZ3NbMF07XG4gIGlmICghaXNTZWxlY3Rvck5vZGUoc2VsZWN0b3IpKSB0aHJvdyBuZXcgRXJyb3IoXCJjaGFuZ2VkT25seSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc2VsZWN0b3JcIik7XG4gIHJldHVybiBjaGFuZ2VkT25seShiZWZvcmUsIGFmdGVyLCBzZWxlY3Rvciwgc2NvcGUpO1xufSk7XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xuY29uc3QgZG9jdW1lbnRzID0ge307XG5kb2N1bWVudHMuZ2V0ID0gY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn0pO1xuY29uc3QgZ2VvID0ge307XG5nZW8ubGF0TG5nID0gY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn0pO1xuZ2VvLmNvbnRhaW5zID0gY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn0pO1xuZ2VvLmludGVyc2VjdHMgPSBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufSk7XG5nZW8uZGlzdGFuY2UgPSBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufSk7XG5jb25zdCBzdHJpbmcgPSB7fTtcbnN0cmluZy5sb3dlciA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gYXJncyxcbiAgKF8sIHZhbHVlKSA9PiB2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IGZyb21TdHJpbmcodmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpKVxuKTtcbnN0cmluZy5sb3dlci5hcml0eSA9IDE7XG5zdHJpbmcudXBwZXIgPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIChfLCB2YWx1ZSkgPT4gdmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9VcHBlckNhc2UoKSlcbik7XG5zdHJpbmcudXBwZXIuYXJpdHkgPSAxO1xuc3RyaW5nLnNwbGl0ID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgc3RyLCBzZXApID0+IHN0ci50eXBlICE9PSBcInN0cmluZ1wiIHx8IHNlcC50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IHN0ci5kYXRhLmxlbmd0aCA9PT0gMCA/IGZyb21BcnJheShbXSkgOiBzZXAuZGF0YS5sZW5ndGggPT09IDAgPyBmcm9tQXJyYXkoQXJyYXkuZnJvbShzdHIuZGF0YSkpIDogZnJvbUFycmF5KHN0ci5kYXRhLnNwbGl0KHNlcC5kYXRhKSlcbik7XG5zdHJpbmcuc3BsaXQuYXJpdHkgPSAyO1xuc3RyaW5nLnN0YXJ0c1dpdGggPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIChfLCBzdHIsIHByZWZpeCkgPT4gc3RyLnR5cGUgIT09IFwic3RyaW5nXCIgfHwgcHJlZml4LnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogc3RyLmRhdGEuc3RhcnRzV2l0aChwcmVmaXguZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVcbik7XG5zdHJpbmcuc3RhcnRzV2l0aC5hcml0eSA9IDI7XG5jb25zdCBfZ2xvYmFsID0ge307XG5fZ2xvYmFsLmFueXdoZXJlID0gY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn0pO1xuX2dsb2JhbC5hbnl3aGVyZS5hcml0eSA9IDE7XG5fZ2xvYmFsLmNvYWxlc2NlID0ge1xuICBhc3luYyBleGVjdXRlQXN5bmMoYXJncywgc2NvcGUpIHtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhhcmcsIHNjb3BlKTtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bGxcIilcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgZXhlY3V0ZVN5bmMoYXJncywgc2NvcGUpIHtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4ZWN1dGVTeW5jKGFyZywgc2NvcGUpO1xuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVsbFwiKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG59O1xuX2dsb2JhbC5jb3VudCA9IGFycmF5UmVkdWNlckV4ZWN1dG9yKFxuICAoYXJncykgPT4gKHsgYXJyYXk6IGFyZ3NbMF0gfSksXG4gICgpID0+IDAsXG4gIChfLCBjb3VudCkgPT4gY291bnQgKyAxLFxuICBmcm9tTnVtYmVyXG4pO1xuX2dsb2JhbC5jb3VudC5hcml0eSA9IDE7XG5fZ2xvYmFsLmRhdGVUaW1lID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgdmFsKSA9PiB2YWwudHlwZSA9PT0gXCJkYXRldGltZVwiID8gdmFsIDogdmFsLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKVxuKTtcbl9nbG9iYWwuZGF0ZVRpbWUuYXJpdHkgPSAxO1xuX2dsb2JhbC5kZWZpbmVkID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgaW5uZXIpID0+IGlubmVyLnR5cGUgPT09IFwibnVsbFwiID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFXG4pO1xuX2dsb2JhbC5kZWZpbmVkLmFyaXR5ID0gMTtcbl9nbG9iYWwuaWRlbnRpdHkgPSBjb25zdGFudEV4ZWN1dG9yKChfYXJncywgc2NvcGUpID0+IGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5pZGVudGl0eSkpO1xuX2dsb2JhbC5pZGVudGl0eS5hcml0eSA9IDA7XG5fZ2xvYmFsLmxlbmd0aCA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gYXJncyxcbiAgKF8sIGlubmVyKSA9PiBpbm5lci50eXBlID09PSBcInN0cmluZ1wiID8gZnJvbU51bWJlcihjb3VudFVURjgoaW5uZXIuZGF0YSkpIDogaW5uZXIudHlwZSA9PT0gXCJhcnJheVwiID8gZnJvbU51bWJlcihpbm5lci5kYXRhLmxlbmd0aCkgOiBOVUxMX1ZBTFVFXG4pO1xuX2dsb2JhbC5sZW5ndGguYXJpdHkgPSAxO1xuX2dsb2JhbC5wYXRoID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgaW5uZXIpID0+IGlubmVyLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogZnJvbVBhdGgobmV3IFBhdGgoaW5uZXIuZGF0YSkpXG4pO1xuX2dsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbl9nbG9iYWwuc3RyaW5nID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgdmFsdWUpID0+IHtcbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoYCR7dmFsdWUuZGF0YX1gKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgfVxuKTtcbl9nbG9iYWwuc3RyaW5nLmFyaXR5ID0gMTtcbl9nbG9iYWwucmVmZXJlbmNlcyA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gW3sgdHlwZTogXCJUaGlzXCIgfSwgLi4uYXJnc10sXG4gIChfLCBzY29wZVZhbHVlLCAuLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgcGF0aFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIGFyZ3MpXG4gICAgICBpZiAocGF0aC50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICBwYXRoU2V0LmFkZChwYXRoLmRhdGEpO1xuICAgICAgZWxzZSBpZiAocGF0aC50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBwYXRoLmRhdGEpXG4gICAgICAgICAgdHlwZW9mIGVsZW0gPT0gXCJzdHJpbmdcIiAmJiBwYXRoU2V0LmFkZChlbGVtKTtcbiAgICByZXR1cm4gcGF0aFNldC5zaXplID09PSAwID8gRkFMU0VfVkFMVUUgOiBoYXNSZWZlcmVuY2Uoc2NvcGVWYWx1ZSwgcGF0aFNldCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH1cbik7XG5fZ2xvYmFsLnJlZmVyZW5jZXMuYXJpdHkgPSAoYykgPT4gYyA+PSAxO1xuX2dsb2JhbC5yb3VuZCA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gYXJncyxcbiAgKF8sIHZhbHVlLCBwcmVjVmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IG51bSA9IHZhbHVlLmRhdGE7XG4gICAgbGV0IHByZWMgPSAwO1xuICAgIGlmIChwcmVjVmFsdWUpIHtcbiAgICAgIGlmIChwcmVjVmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCBwcmVjVmFsdWUuZGF0YSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocHJlY1ZhbHVlLmRhdGEpKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIHByZWMgPSBwcmVjVmFsdWUuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHByZWMgPT09IDAgPyBudW0gPCAwID8gZnJvbU51bWJlcigtTWF0aC5yb3VuZCgtbnVtKSkgOiBmcm9tTnVtYmVyKE1hdGgucm91bmQobnVtKSkgOiBmcm9tTnVtYmVyKE51bWJlcihudW0udG9GaXhlZChwcmVjKSkpO1xuICB9XG4pO1xuX2dsb2JhbC5yb3VuZC5hcml0eSA9IChjb3VudCkgPT4gY291bnQgPj0gMSAmJiBjb3VudCA8PSAyO1xuX2dsb2JhbC5ub3cgPSBjb25zdGFudEV4ZWN1dG9yKChfYXJncywgc2NvcGUpID0+IGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC50aW1lc3RhbXAudG9JU09TdHJpbmcoKSkpO1xuX2dsb2JhbC5ub3cuYXJpdHkgPSAwO1xuX2dsb2JhbC5ib29zdCA9IGNvbnN0YW50RXhlY3V0b3IoKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0IGNhbGxcIik7XG59KTtcbl9nbG9iYWwuYm9vc3QuYXJpdHkgPSAyO1xuX2dsb2JhbC5sb3dlciA9IHN0cmluZy5sb3dlcjtcbl9nbG9iYWwudXBwZXIgPSBzdHJpbmcudXBwZXI7XG5mdW5jdGlvbiBjb3VudFVURjgoc3RyKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGNvZGUgPj0gNTUyOTYgJiYgY29kZSA8PSA1NjMxOSB8fCBjb3VudCsrO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGhhc1JlZmVyZW5jZSh2YWx1ZSwgcGF0aFNldCkge1xuICBzd2l0Y2ggKGdldFR5cGUodmFsdWUpKSB7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpXG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKHZhbHVlLl9yZWYpXG4gICAgICAgIHJldHVybiBwYXRoU2V0Lmhhcyh2YWx1ZS5fcmVmKTtcbiAgICAgIGZvciAoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSlcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gITE7XG59XG5jb25zdCBtYXRoID0ge307XG5tYXRoLm1pbiA9IGFycmF5UmVkdWNlckV4ZWN1dG9yKFxuICAoYXJncykgPT4gKHsgYXJyYXk6IGFyZ3NbMF0gfSksXG4gICgpID0+IHtcbiAgfSxcbiAgKF8sIG4sIGl0ZW0pID0+IGl0ZW0gPT09IG51bGwgPyBuIDogdHlwZW9mIGl0ZW0gIT0gXCJudW1iZXJcIiA/IFNUT1BfSVRFUkFUT1IgOiBuID09PSB2b2lkIDAgfHwgaXRlbSA8IG4gPyBpdGVtIDogbixcbiAgKG4pID0+IG4gPT09IHZvaWQgMCA/IE5VTExfVkFMVUUgOiBmcm9tTnVtYmVyKG4pXG4pO1xubWF0aC5taW4uYXJpdHkgPSAxO1xubWF0aC5tYXggPSBhcnJheVJlZHVjZXJFeGVjdXRvcihcbiAgKGFyZ3MpID0+ICh7IGFycmF5OiBhcmdzWzBdIH0pLFxuICAoKSA9PiB7XG4gIH0sXG4gIChfLCBuLCBpdGVtKSA9PiBpdGVtID09PSBudWxsID8gbiA6IHR5cGVvZiBpdGVtICE9IFwibnVtYmVyXCIgPyBTVE9QX0lURVJBVE9SIDogbiA9PT0gdm9pZCAwIHx8IGl0ZW0gPiBuID8gaXRlbSA6IG4sXG4gIChuKSA9PiBuID09PSB2b2lkIDAgPyBOVUxMX1ZBTFVFIDogZnJvbU51bWJlcihuKVxuKTtcbm1hdGgubWF4LmFyaXR5ID0gMTtcbm1hdGguc3VtID0gYXJyYXlSZWR1Y2VyRXhlY3V0b3IoXG4gIChhcmdzKSA9PiAoeyBhcnJheTogYXJnc1swXSB9KSxcbiAgKCkgPT4gMCxcbiAgKF8sIG4sIGl0ZW0pID0+IGl0ZW0gPT09IG51bGwgPyBuIDogdHlwZW9mIGl0ZW0gIT0gXCJudW1iZXJcIiA/IFNUT1BfSVRFUkFUT1IgOiBuICsgaXRlbSxcbiAgZnJvbU51bWJlclxuKTtcbm1hdGguc3VtLmFyaXR5ID0gMTtcbm1hdGguYXZnID0gYXJyYXlSZWR1Y2VyRXhlY3V0b3IoXG4gIChhcmdzKSA9PiAoeyBhcnJheTogYXJnc1swXSB9KSxcbiAgKCkgPT4gKHsgY291bnQ6IDAsIHN1bTogMCB9KSxcbiAgKF8sIHsgY291bnQsIHN1bSB9LCBpdGVtKSA9PiBpdGVtID09PSBudWxsID8geyBjb3VudCwgc3VtIH0gOiB0eXBlb2YgaXRlbSAhPSBcIm51bWJlclwiID8gU1RPUF9JVEVSQVRPUiA6IHsgY291bnQ6IGNvdW50ICsgMSwgc3VtOiBzdW0gKyBpdGVtIH0sXG4gICh7IGNvdW50LCBzdW0gfSkgPT4gY291bnQgPT09IDAgPyBOVUxMX1ZBTFVFIDogZnJvbU51bWJlcihzdW0gLyBjb3VudClcbik7XG5tYXRoLmF2Zy5hcml0eSA9IDE7XG5mdW5jdGlvbiBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKSB7XG4gIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBibG9ja1RleHQodmFsdWUuZGF0YSk7XG4gIGlmICh2YWx1ZS50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICBjb25zdCB0ZXh0cyA9IGFycmF5VGV4dCh2YWx1ZS5kYXRhKTtcbiAgICBpZiAodGV4dHMubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiB0ZXh0cy5qb2luKGBcblxuYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhcnJheVRleHQodmFsdWUsIHJlc3VsdCA9IFtdKSB7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgdmFsdWUpXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYmxvY2spKVxuICAgICAgYXJyYXlUZXh0KGJsb2NrLCByZXN1bHQpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBibG9jayA9PSBcIm9iamVjdFwiICYmIGJsb2NrKSB7XG4gICAgICBjb25zdCB0ZXh0MiA9IGJsb2NrVGV4dChibG9jayk7XG4gICAgICB0ZXh0MiAhPT0gbnVsbCAmJiByZXN1bHQucHVzaCh0ZXh0Mik7XG4gICAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYmxvY2tUZXh0KG9iaikge1xuICBpZiAodHlwZW9mIG9iai5fdHlwZSAhPSBcInN0cmluZ1wiKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW47XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHJldHVybiBudWxsO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbilcbiAgICBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY2hpbGQuX3R5cGUgPT0gXCJzdHJpbmdcIiAmJiBjaGlsZC5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgdHlwZW9mIGNoaWxkLnRleHQgPT0gXCJzdHJpbmdcIiAmJiAocmVzdWx0ICs9IGNoaWxkLnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgcHQgPSB7fTtcbnB0LnRleHQgPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIGZ1bmN0aW9uKF8sIHZhbHVlKSB7XG4gICAgY29uc3QgdGV4dDIgPSBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKTtcbiAgICByZXR1cm4gdGV4dDIgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogZnJvbVN0cmluZyh0ZXh0Mik7XG4gIH1cbik7XG5wdC50ZXh0LmFyaXR5ID0gMTtcbmNvbnN0IHJlbGVhc2VzID0ge307XG5yZWxlYXNlcy5hbGwgPSBhcnJheUV4ZWN1dG9yKFxuICAoKSA9PiAoeyBhcnJheTogeyB0eXBlOiBcIkV2ZXJ5dGhpbmdcIiB9IH0pLFxuICBmdW5jdGlvbiogKF8sIHZhbHVlKSB7XG4gICAgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgJiYgXCJfdHlwZVwiIGluIHZhbHVlICYmIHZhbHVlLl90eXBlID09PSBcInN5c3RlbS5yZWxlYXNlXCIgJiYgKHlpZWxkIHZhbHVlKTtcbiAgfVxuKTtcbnJlbGVhc2VzLmFsbC5hcml0eSA9IDA7XG5jb25zdCBzYW5pdHkgPSB7fTtcbnNhbml0eS5wcm9qZWN0SWQgPSBjb25zdGFudEV4ZWN1dG9yKChfLCBzY29wZSkgPT4gc2NvcGUuY29udGV4dC5zYW5pdHkgPyBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LnByb2plY3RJZCkgOiBOVUxMX1ZBTFVFKTtcbnNhbml0eS5kYXRhc2V0ID0gY29uc3RhbnRFeGVjdXRvcigoXywgc2NvcGUpID0+IHNjb3BlLmNvbnRleHQuc2FuaXR5ID8gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5kYXRhc2V0KSA6IE5VTExfVkFMVUUpO1xuc2FuaXR5LnZlcnNpb25PZiA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoW3ZhbHVlXSkgPT4gW3ZhbHVlLCB7IHR5cGU6IFwiVGhpc1wiIH1dLFxuICAoXywgdmFsdWUsIHZhbCkgPT4ge1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCBiYXNlSWQgPSB2YWx1ZS5kYXRhO1xuICAgIGlmICh2YWwudHlwZSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsLmRhdGEuX2lkICE9IFwic3RyaW5nXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGlmICh2YWwuZGF0YS5faWQgPT09IGJhc2VJZCkgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IHZhbC5kYXRhLl9pZC5zcGxpdChcIi5cIik7XG4gICAgcmV0dXJuIGNvbXBvbmVudHMubGVuZ3RoID49IDIgJiYgY29tcG9uZW50c1swXSA9PT0gXCJkcmFmdHNcIiAmJiBjb21wb25lbnRzLnNsaWNlKDEpLmpvaW4oXCIuXCIpID09PSBiYXNlSWQgfHwgY29tcG9uZW50cy5sZW5ndGggPj0gMyAmJiBjb21wb25lbnRzWzBdID09PSBcInZlcnNpb25zXCIgJiYgY29tcG9uZW50cy5zbGljZSgyKS5qb2luKFwiLlwiKSA9PT0gYmFzZUlkID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9XG4pO1xuc2FuaXR5LnZlcnNpb25PZi5hcml0eSA9IDE7XG5zYW5pdHkucGFydE9mUmVsZWFzZSA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gW2FyZ3NbMF0sIHsgdHlwZTogXCJUaGlzXCIgfV0sXG4gIChfLCB2YWx1ZSwgdmFsKSA9PiB7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IGJhc2VJZCA9IHZhbHVlLmRhdGE7XG4gICAgaWYgKHZhbC50eXBlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWwuZGF0YS5faWQgIT0gXCJzdHJpbmdcIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IHZhbC5kYXRhLl9pZC5zcGxpdChcIi5cIik7XG4gICAgcmV0dXJuIGNvbXBvbmVudHMubGVuZ3RoID49IDMgJiYgY29tcG9uZW50c1swXSA9PT0gXCJ2ZXJzaW9uc1wiICYmIGNvbXBvbmVudHNbMV0gPT09IGJhc2VJZCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfVxuKTtcbnNhbml0eS5wYXJ0T2ZSZWxlYXNlLmFyaXR5ID0gMTtcbmNvbnN0IHRleHQgPSB7fTtcbnRleHQucXVlcnkgPSBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufSk7XG50ZXh0LnF1ZXJ5LmFyaXR5ID0gMTtcbmNvbnN0IEJNMjVrID0gMS4yO1xuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVTY29yZUFzeW5jKG5vZGUsIHNjb3BlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiT3BDYWxsXCIgJiYgbm9kZS5vcCA9PT0gXCJtYXRjaFwiKVxuICAgIHJldHVybiBldmFsdWF0ZU1hdGNoU2NvcmVBc3luYyhub2RlLmxlZnQsIG5vZGUucmlnaHQsIHNjb3BlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIG5vZGUubmFtZSA9PT0gXCJib29zdFwiKSB7XG4gICAgY29uc3QgaW5uZXJTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmVBc3luYyhub2RlLmFyZ3NbMF0sIHNjb3BlKSwgYm9vc3QgPSBhd2FpdCBleGVjdXRlQXN5bmMobm9kZS5hcmdzWzFdLCBzY29wZSk7XG4gICAgcmV0dXJuIGJvb3N0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5uZXJTY29yZSA+IDAgPyBpbm5lclNjb3JlICsgYm9vc3QuZGF0YSA6IDA7XG4gIH1cbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiT3JcIjoge1xuICAgICAgY29uc3QgbGVmdFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZUFzeW5jKG5vZGUubGVmdCwgc2NvcGUpLCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZUFzeW5jKG5vZGUucmlnaHQsIHNjb3BlKTtcbiAgICAgIHJldHVybiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgIH1cbiAgICBjYXNlIFwiQW5kXCI6IHtcbiAgICAgIGNvbnN0IGxlZnRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmVBc3luYyhub2RlLmxlZnQsIHNjb3BlKSwgcmlnaHRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmVBc3luYyhub2RlLnJpZ2h0LCBzY29wZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDAgPyAwIDogbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZXhlY3V0ZUFzeW5jKG5vZGUsIHNjb3BlKTtcbiAgICAgIHJldHVybiByZXMudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmVzLmRhdGEgPT09ICEwID8gMSA6IDA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBldmFsdWF0ZVNjb3JlU3luYyhub2RlLCBzY29wZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIk9wQ2FsbFwiICYmIG5vZGUub3AgPT09IFwibWF0Y2hcIilcbiAgICByZXR1cm4gZXZhbHVhdGVNYXRjaFNjb3JlU3luYyhub2RlLmxlZnQsIG5vZGUucmlnaHQsIHNjb3BlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIG5vZGUubmFtZSA9PT0gXCJib29zdFwiKSB7XG4gICAgY29uc3QgaW5uZXJTY29yZSA9IGV2YWx1YXRlU2NvcmVTeW5jKG5vZGUuYXJnc1swXSwgc2NvcGUpLCBib29zdCA9IGV4ZWN1dGVTeW5jKG5vZGUuYXJnc1sxXSwgc2NvcGUpO1xuICAgIHJldHVybiBib29zdC50eXBlID09PSBcIm51bWJlclwiICYmIGlubmVyU2NvcmUgPiAwID8gaW5uZXJTY29yZSArIGJvb3N0LmRhdGEgOiAwO1xuICB9XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIk9yXCI6IHtcbiAgICAgIGNvbnN0IGxlZnRTY29yZSA9IGV2YWx1YXRlU2NvcmVTeW5jKG5vZGUubGVmdCwgc2NvcGUpLCByaWdodFNjb3JlID0gZXZhbHVhdGVTY29yZVN5bmMobm9kZS5yaWdodCwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGxlZnRTY29yZSArIHJpZ2h0U2NvcmU7XG4gICAgfVxuICAgIGNhc2UgXCJBbmRcIjoge1xuICAgICAgY29uc3QgbGVmdFNjb3JlID0gZXZhbHVhdGVTY29yZVN5bmMobm9kZS5sZWZ0LCBzY29wZSksIHJpZ2h0U2NvcmUgPSBldmFsdWF0ZVNjb3JlU3luYyhub2RlLnJpZ2h0LCBzY29wZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDAgPyAwIDogbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgcmVzID0gZXhlY3V0ZVN5bmMobm9kZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIHJlcy50eXBlID09PSBcImJvb2xlYW5cIiAmJiByZXMuZGF0YSA9PT0gITAgPyAxIDogMDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGV2YWx1YXRlTWF0Y2hTY29yZVN5bmMobGVmdCwgcmlnaHQsIHNjb3BlKSB7XG4gIGNvbnN0IHRleHQyID0gZXhlY3V0ZVN5bmMobGVmdCwgc2NvcGUpLCBwYXR0ZXJuID0gZXhlY3V0ZVN5bmMocmlnaHQsIHNjb3BlKSwgcmVzdWx0ID0gcHJvY2Vzc01hdGNoU2NvcmUodGV4dDIsIHBhdHRlcm4pO1xuICBpZiAodHlwZW9mIHJlc3VsdCA9PSBcIm51bWJlclwiKSByZXR1cm4gcmVzdWx0O1xuICB0aHJvdyBuZXcgRXJyb3IoXCJGb3VuZCBzeW5jaHJvbm91cyB2YWx1ZSBpbiBtYXRjaCgpXCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVNYXRjaFNjb3JlQXN5bmMobGVmdCwgcmlnaHQsIHNjb3BlKSB7XG4gIGNvbnN0IHRleHQyID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGxlZnQsIHNjb3BlKSwgcGF0dGVybiA9IGF3YWl0IGV4ZWN1dGVBc3luYyhyaWdodCwgc2NvcGUpO1xuICByZXR1cm4gcHJvY2Vzc01hdGNoU2NvcmUodGV4dDIsIHBhdHRlcm4pO1xufVxuZnVuY3Rpb24gcHJvY2Vzc01hdGNoU2NvcmUodGV4dDIsIHBhdHRlcm4pIHtcbiAgY29uc3QgdG9rZW5zID0gZ2F0aGVyVGV4dCh0ZXh0MiwgKHBhcnQpID0+IG1hdGNoVG9rZW5pemUocGFydCkpLCB0ZXJtcyA9IGdhdGhlclRleHQocGF0dGVybiwgKHBhcnQpID0+IG1hdGNoUGF0dGVyblJlZ2V4KHBhcnQpKSwgcHJvY2VzcyA9ICh0b2tlbnMyLCB0ZXJtczIpID0+IHtcbiAgICBpZiAoIXRlcm1zMi5zdWNjZXNzIHx8IHRva2VuczIucGFydHMubGVuZ3RoID09PSAwIHx8IHRlcm1zMi5wYXJ0cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gMDtcbiAgICBsZXQgc2NvcmUgPSAwO1xuICAgIGZvciAoY29uc3QgcmUgb2YgdGVybXMyLnBhcnRzKSB7XG4gICAgICBjb25zdCBmcmVxID0gdG9rZW5zMi5wYXJ0cy5yZWR1Y2UoKGMsIHRva2VuKSA9PiBjICsgKHJlLnRlc3QodG9rZW4pID8gMSA6IDApLCAwKTtcbiAgICAgIHNjb3JlICs9IGZyZXEgKiAoQk0yNWsgKyAxKSAvIChmcmVxICsgQk0yNWspO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcmU7XG4gIH07XG4gIHJldHVybiBcInRoZW5cIiBpbiB0b2tlbnMgfHwgXCJ0aGVuXCIgaW4gdGVybXMgPyAoYXN5bmMgKCkgPT4gcHJvY2Vzcyhhd2FpdCB0b2tlbnMsIGF3YWl0IHRlcm1zKSkoKSA6IHByb2Nlc3ModG9rZW5zLCB0ZXJtcyk7XG59XG5mdW5jdGlvbiBleHRyYWN0T3JkZXJBcmdzKGFyZ3MpIHtcbiAgY29uc3QgbWFwcGVycyA9IFtdLCBkaXJlY3Rpb25zID0gW107XG4gIGZvciAobGV0IG1hcHBlciBvZiBhcmdzKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IFwiYXNjXCI7XG4gICAgbWFwcGVyLnR5cGUgPT09IFwiRGVzY1wiID8gKGRpcmVjdGlvbiA9IFwiZGVzY1wiLCBtYXBwZXIgPSBtYXBwZXIuYmFzZSkgOiBtYXBwZXIudHlwZSA9PT0gXCJBc2NcIiAmJiAobWFwcGVyID0gbWFwcGVyLmJhc2UpLCBtYXBwZXJzLnB1c2gobWFwcGVyKSwgZGlyZWN0aW9ucy5wdXNoKGRpcmVjdGlvbik7XG4gIH1cbiAgcmV0dXJuIHsgbWFwcGVycywgZGlyZWN0aW9ucyB9O1xufVxuZnVuY3Rpb24gc29ydEFycmF5KGF1eCwgZGlyZWN0aW9ucykge1xuICByZXR1cm4gYXV4LnNvcnQoKGFUdXBsZSwgYlR1cGxlKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYyA9IHRvdGFsQ29tcGFyZShhVHVwbGVbaSArIDJdLCBiVHVwbGVbaSArIDJdKTtcbiAgICAgIGlmIChkaXJlY3Rpb25zW2ldID09PSBcImRlc2NcIiAmJiAoYyA9IC1jKSwgYyAhPT0gMClcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHJldHVybiBhVHVwbGVbMV0gLSBiVHVwbGVbMV07XG4gIH0pLCBhdXgubWFwKCh2KSA9PiB2WzBdKTtcbn1cbmNvbnN0IHBpcGVGdW5jdGlvbnMgPSB7fTtcbnBpcGVGdW5jdGlvbnMub3JkZXIgPSB7XG4gIGV4ZWN1dGVTeW5jKHsgYmFzZSwgYXJncyB9LCBzY29wZSkge1xuICAgIGNvbnN0IHsgbWFwcGVycywgZGlyZWN0aW9ucyB9ID0gZXh0cmFjdE9yZGVyQXJncyhhcmdzKSwgYXV4ID0gW107XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgY29uc3QgbiA9IGRpcmVjdGlvbnMubGVuZ3RoO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYmFzZS5kYXRhKSB7XG4gICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChmcm9tSlModmFsdWUpKSwgdHVwbGUgPSBbdmFsdWUsIGlkeF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBleGVjdXRlU3luYyhtYXBwZXJzW2ldLCBuZXdTY29wZSk7XG4gICAgICAgIHR1cGxlLnB1c2gocmVzdWx0LmRhdGEpO1xuICAgICAgfVxuICAgICAgYXV4LnB1c2godHVwbGUpLCBpZHgrKztcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheShzb3J0QXJyYXkoYXV4LCBkaXJlY3Rpb25zKSk7XG4gIH0sXG4gIGFzeW5jIGV4ZWN1dGVBc3luYyh7IGJhc2UsIGFyZ3MgfSwgc2NvcGUpIHtcbiAgICBjb25zdCB7IG1hcHBlcnMsIGRpcmVjdGlvbnMgfSA9IGV4dHJhY3RPcmRlckFyZ3MoYXJncyksIGF1eCA9IFtdO1xuICAgIGxldCBpZHggPSAwO1xuICAgIGNvbnN0IG4gPSBkaXJlY3Rpb25zLmxlbmd0aDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKSwgdHVwbGUgPSBbYXdhaXQgdmFsdWUuZ2V0KCksIGlkeF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlQXN5bmMobWFwcGVyc1tpXSwgbmV3U2NvcGUpO1xuICAgICAgICB0dXBsZS5wdXNoKGF3YWl0IHJlc3VsdC5nZXQoKSk7XG4gICAgICB9XG4gICAgICBhdXgucHVzaCh0dXBsZSksIGlkeCsrO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5KHNvcnRBcnJheShhdXgsIGRpcmVjdGlvbnMpKTtcbiAgfVxufTtcbnBpcGVGdW5jdGlvbnMub3JkZXIuYXJpdHkgPSAoY291bnQpID0+IGNvdW50ID49IDE7XG5waXBlRnVuY3Rpb25zLnNjb3JlID0ge1xuICBhc3luYyBleGVjdXRlQXN5bmMoeyBiYXNlLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgY29uc3QgdW5rbm93biA9IFtdLCBzY29yZWQgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVua25vd24ucHVzaChhd2FpdCB2YWx1ZS5nZXQoKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgICAgbGV0IHZhbHVlU2NvcmUgPSB0eXBlb2YgdmFsdWUuZGF0YS5fc2NvcmUgPT0gXCJudW1iZXJcIiA/IHZhbHVlLmRhdGEuX3Njb3JlIDogMDtcbiAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpXG4gICAgICAgIHZhbHVlU2NvcmUgKz0gYXdhaXQgZXZhbHVhdGVTY29yZUFzeW5jKGFyZywgbmV3U2NvcGUpO1xuICAgICAgY29uc3QgbmV3T2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUuZGF0YSwgeyBfc2NvcmU6IHZhbHVlU2NvcmUgfSk7XG4gICAgICBzY29yZWQucHVzaChuZXdPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcmVkLnNvcnQoKGEsIGIpID0+IGIuX3Njb3JlIC0gYS5fc2NvcmUpLCBmcm9tSlMoc2NvcmVkKTtcbiAgfSxcbiAgZXhlY3V0ZVN5bmMoeyBiYXNlLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgY29uc3Qgc2NvcmVkID0gW107XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBiYXNlLmRhdGEpIHtcbiAgICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB2YWx1ZU9iaiA9IHZhbHVlLCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChmcm9tSlModmFsdWUpKTtcbiAgICAgIGxldCB2YWx1ZVNjb3JlID0gdHlwZW9mIHZhbHVlT2JqLl9zY29yZSA9PSBcIm51bWJlclwiID8gdmFsdWVPYmouX3Njb3JlIDogMDtcbiAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpXG4gICAgICAgIHZhbHVlU2NvcmUgKz0gZXZhbHVhdGVTY29yZVN5bmMoYXJnLCBuZXdTY29wZSk7XG4gICAgICBjb25zdCBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZU9iaiwgeyBfc2NvcmU6IHZhbHVlU2NvcmUgfSk7XG4gICAgICBzY29yZWQucHVzaChuZXdPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcmVkLnNvcnQoKGEsIGIpID0+IGIuX3Njb3JlIC0gYS5fc2NvcmUpLCBmcm9tQXJyYXkoc2NvcmVkKTtcbiAgfVxufTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUuYXJpdHkgPSAoY291bnQpID0+IGNvdW50ID49IDE7XG5jb25zdCBuYW1lc3BhY2VzID0ge1xuICBnbG9iYWw6IF9nbG9iYWwsXG4gIHN0cmluZyxcbiAgYXJyYXksXG4gIHB0LFxuICBkZWx0YSxcbiAgZGlmZixcbiAgc2FuaXR5LFxuICBtYXRoLFxuICBkYXRlVGltZSxcbiAgcmVsZWFzZXMsXG4gIHRleHQsXG4gIGdlbyxcbiAgZG9jdW1lbnRzXG59O1xuY2xhc3MgTWFya1Byb2Nlc3NvciB7XG4gIHN0cmluZztcbiAgbWFya3M7XG4gIGluZGV4O1xuICBwYXJzZU9wdGlvbnM7XG4gIGFsbG93Qm9vc3QgPSAhMTtcbiAgY29uc3RydWN0b3Ioc3RyaW5nMiwgbWFya3MsIHBhcnNlT3B0aW9ucykge1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nMiwgdGhpcy5tYXJrcyA9IG1hcmtzLCB0aGlzLmluZGV4ID0gMCwgdGhpcy5wYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnM7XG4gIH1cbiAgaGFzTWFyayhwb3MgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXggKyBwb3MgPCB0aGlzLm1hcmtzLmxlbmd0aDtcbiAgfVxuICBnZXRNYXJrKHBvcyA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrc1t0aGlzLmluZGV4ICsgcG9zXTtcbiAgfVxuICBzaGlmdCgpIHtcbiAgICB0aGlzLmluZGV4ICs9IDE7XG4gIH1cbiAgcHJvY2Vzcyh2aXNpdG9yKSB7XG4gICAgY29uc3QgbWFyayA9IHRoaXMubWFya3NbdGhpcy5pbmRleF07XG4gICAgdGhpcy5zaGlmdCgpO1xuICAgIGNvbnN0IGZ1bmMgPSB2aXNpdG9yW21hcmsubmFtZV07XG4gICAgaWYgKCFmdW5jKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGhhbmRsZXI6ICR7bWFyay5uYW1lfWApO1xuICAgIHJldHVybiBmdW5jLmNhbGwodmlzaXRvciwgdGhpcywgbWFyayk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zaGlmdCgpLCB0aGlzLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nRW5kKCkge1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXggLSAxXSwgY3VyciA9IHRoaXMubWFya3NbdGhpcy5pbmRleF07XG4gICAgcmV0dXJuIHRoaXMuc2hpZnQoKSwgdGhpcy5zdHJpbmcuc2xpY2UocHJldi5wb3NpdGlvbiwgY3Vyci5wb3NpdGlvbik7XG4gIH1cbiAgc2xpY2UobGVuKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XS5wb3NpdGlvbjtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBwb3MgKyBsZW4pO1xuICB9XG59XG5jb25zdCBXUyA9IC9eKFtcXHRcXG5cXHZcXGZcXHIgXFx1MDA4NVxcdTAwQTBdfChcXC9cXC9bXlxcbl0qXFxuKSkrLywgTlVNID0gL15cXGQrLywgSURFTlQgPSAvXlthLXpBLVpfXVthLXpBLVpfMC05XSovO1xuZnVuY3Rpb24gcGFyc2UkMShzdHIpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIiA/IHJlc3VsdCA6IChwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pLCBwb3MgIT09IHN0ci5sZW5ndGggPyAocmVzdWx0LmZhaWxQb3NpdGlvbiAmJiAocG9zID0gcmVzdWx0LmZhaWxQb3NpdGlvbiAtIDEpLCB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogXCJVbmV4cGVjdGVkIGVuZCBvZiBxdWVyeVwiLCBwb3NpdGlvbjogcG9zIH0pIDogKGRlbGV0ZSByZXN1bHQucG9zaXRpb24sIGRlbGV0ZSByZXN1bHQuZmFpbFBvc2l0aW9uLCByZXN1bHQpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHIsIHBvcywgbGV2ZWwpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zLCB0b2tlbiA9IHN0cltwb3NdLCBtYXJrcztcbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMTApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwicG9zXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCItXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgOCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJuZWdcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIihcIjoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlR3JvdXBPclR1cGxlKHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uLCBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiIVwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDEwKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcIm5vdFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwie1wiOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcywgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJbXCI6XG4gICAgICBpZiAobWFya3MgPSBbeyBuYW1lOiBcImFycmF5XCIsIHBvc2l0aW9uOiBwb3MgfV0sIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSAhPT0gXCJdXCIpXG4gICAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICAgIHN0ci5zbGljZShwb3MsIHBvcyArIDMpID09PSBcIi4uLlwiICYmIChtYXJrcy5wdXNoKHsgbmFtZTogXCJhcnJheV9zcGxhdFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKSk7XG4gICAgICAgICAgbGV0IHJlcyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgaWYgKHJlcy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXM7XG4gICAgICAgICAgaWYgKG1hcmtzID0gbWFya3MuY29uY2F0KHJlcy5tYXJrcyksIHBvcyA9IHJlcy5wb3NpdGlvbiwgcG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgc3RyW3Bvc10gIT09IFwiLFwiIHx8IChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwiXVwiKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpXG4gICAgICAgIHBvcysrLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJhcnJheV9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiAnRXhwZWN0ZWQgXCJdXCIgYWZ0ZXIgYXJyYXkgZXhwcmVzc2lvbicsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VTdHJpbmcoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcywgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJeXCI6IHtcbiAgICAgIGZvciAocG9zKyssIG1hcmtzID0gW107IHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiXlwiOyApXG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImRibHBhcmVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyArPSAyO1xuICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwicGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiQFwiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInRoaXNcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLCBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIqXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwiZXZlcnl0aGluZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sIHBvcysrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiRcIjoge1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIElERU5UKTtcbiAgICAgIGlkZW50TGVuICYmIChwb3MgKz0gMSArIGlkZW50TGVuLCBtYXJrcyA9IFtcbiAgICAgICAgeyBuYW1lOiBcInBhcmFtXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zICsgMSB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgXSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGV0IG51bUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICBpZiAobnVtTGVuKSB7XG4gICAgICAgIHBvcyArPSBudW1MZW47XG4gICAgICAgIGxldCBuYW1lID0gXCJpbnRlZ2VyXCI7XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xuICAgICAgICAgIGZyYWNMZW4gJiYgKG5hbWUgPSBcImZsb2F0XCIsIHBvcyArPSAxICsgZnJhY0xlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcImVcIiB8fCBzdHJbcG9zXSA9PT0gXCJFXCIpIHtcbiAgICAgICAgICBuYW1lID0gXCJzY2lcIiwgcG9zKyssIChzdHJbcG9zXSA9PT0gXCIrXCIgfHwgc3RyW3Bvc10gPT09IFwiLVwiKSAmJiBwb3MrKztcbiAgICAgICAgICBsZXQgZXhwTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgICBpZiAoIWV4cExlbikgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiBcIkV4cG9uZW50IG11c3QgYmUgYSBudW1iZXJcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgICAgIHBvcyArPSBleHBMZW47XG4gICAgICAgIH1cbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgeyBuYW1lLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IG5hbWUgKyBcIl9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHN3aXRjaCAocG9zICs9IGlkZW50TGVuLCBzdHJbcG9zXSkge1xuICAgICAgICAgIGNhc2UgXCI6XCI6XG4gICAgICAgICAgY2FzZSBcIihcIjoge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3MsIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJ0aGlzX2F0dHJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghbWFya3MpXG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiBcIkV4cGVjdGVkIGV4cHJlc3Npb25cIiwgcG9zaXRpb246IHBvcyB9O1xuICBsZXQgbGhzTGV2ZWwgPSAxMiwgdHJhdjtcbiAgbG9vcDogZm9yICg7IDsgKSB7XG4gICAgbGV0IGlubmVyUG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICBpZiAoaW5uZXJQb3MgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIHBvcyA9IGlubmVyUG9zO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBpbm5lclBvcyksIHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgIGZvciAobWFya3MudW5zaGlmdCh7IG5hbWU6IFwidHJhdmVyc2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pOyB0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiOyApXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHRyYXYubWFya3MpLCBwb3MgPSB0cmF2LnBvc2l0aW9uLCB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBza2lwV1Moc3RyLCBwb3MpKTtcbiAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInRyYXZlcnNhbF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0cltpbm5lclBvc10pIHtcbiAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgc3dpdGNoIChzdHJbaW5uZXJQb3MgKyAxXSkge1xuICAgICAgICAgIGNhc2UgXCI+XCI6IHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDEgfHwgbGhzTGV2ZWwgPD0gMSkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCAxKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGFpclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA1KTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIitcIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA2IHx8IGxoc0xldmVsIDwgNikgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDcpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiYWRkXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIi1cIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA2IHx8IGxoc0xldmVsIDwgNikgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDcpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwic3ViXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIipcIjoge1xuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgaWYgKGxldmVsID4gOCB8fCBsaHNMZXZlbCA8PSA4KSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMyID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgOCk7XG4gICAgICAgICAgaWYgKHJoczIudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzMjtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMyLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicG93XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzMi5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbCA+IDcgfHwgbGhzTGV2ZWwgPCA3KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgOCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJtdWxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiL1wiOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IDcgfHwgbGhzTGV2ZWwgPCA3KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgOCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJkaXZcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiJVwiOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IDcgfHwgbGhzTGV2ZWwgPCA3KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgOCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJtb2RcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiPFwiOlxuICAgICAgY2FzZSBcIj5cIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCBuZXh0UG9zID0gaW5uZXJQb3MgKyAxO1xuICAgICAgICBzdHJbbmV4dFBvc10gPT09IFwiPVwiICYmIG5leHRQb3MrKztcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MpLCA1KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogbmV4dFBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInxcIjoge1xuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwifFwiKSB7XG4gICAgICAgICAgaWYgKGxldmVsID4gMiB8fCBsaHNMZXZlbCA8IDIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDMpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm9yXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxldmVsID4gMTEgfHwgbGhzTGV2ZWwgPCAxMSkgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgICAgIGlmICghaWRlbnRMZW4pIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogXCJFeHBlY3RlZCBpZGVudGlmaWVyXCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9O1xuICAgICAgICAgIGlmIChwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuLCBzdHJbcG9zXSA9PT0gXCIoXCIgfHwgc3RyW3Bvc10gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGdW5jQ2FsbChzdHIsIGlkZW50UG9zLCBwb3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwaXBlY2FsbFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJlc3VsdC5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAxMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiJlwiOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPSBcIiZcIiB8fCBsZXZlbCA+IDMgfHwgbGhzTGV2ZWwgPCAzKSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhbmRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiIVwiOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPT0gXCI9XCIgfHwgbGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA1KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZFwiOiB7XG4gICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgNCkgIT09IFwiZGVzY1wiIHx8IGxldmVsID4gNCB8fCBsaHNMZXZlbCA8IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRlc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSBpbm5lclBvcyArIDQsIGxoc0xldmVsID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYVwiOiB7XG4gICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgMykgIT09IFwiYXNjXCIgfHwgbGV2ZWwgPiA0IHx8IGxoc0xldmVsIDwgNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiYXNjXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gaW5uZXJQb3MgKyAzLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3dpdGNoIChwYXJzZVJlZ2V4U3RyKHN0ciwgaW5uZXJQb3MsIElERU5UKSkge1xuICAgICAgICAgIGNhc2UgXCJpblwiOiB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpO1xuICAgICAgICAgICAgbGV0IGlzR3JvdXAgPSAhMTtcbiAgICAgICAgICAgIHN0cltwb3NdID09PSBcIihcIiAmJiAoaXNHcm91cCA9ICEwLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSk7XG4gICAgICAgICAgICBsZXQgcmFuZ2VQb3MgPSBwb3MsIHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgNSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pLCBzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgICAgICAgIHN0cltwb3MgKyAyXSA9PT0gXCIuXCIgPyAodHlwZSA9IFwiZXhjX3JhbmdlXCIsIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpKSA6IHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCA1KTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImluX3JhbmdlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQoeyBuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3MgfSwgcmVzdWx0Lm1hcmtzLCByaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgc3RyW3Bvc10gIT09IFwiKVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIFwiKVwiIGluIGdyb3VwJywgcG9zaXRpb246IHBvcyB9O1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibWF0Y2hcIjoge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KSBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgNSksIDUpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgNSB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGZhaWxQb3NpdGlvbiA9IHRyYXY/LnR5cGUgPT09IFwiZXJyb3JcIiAmJiB0cmF2LnBvc2l0aW9uO1xuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MsIGZhaWxQb3NpdGlvbiB9O1xufVxuZnVuY3Rpb24gcGFyc2VHcm91cE9yVHVwbGUoc3RyLCBwb3MpIHtcbiAgY29uc3Qgc3RhcnRQb3MgPSBwb3M7XG4gIGxldCBtYXJrcywgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDApO1xuICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgc3dpdGNoIChwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pLCBzdHJbcG9zXSkge1xuICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgIGZvciAobWFya3MgPSBbeyBuYW1lOiBcInR1cGxlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7IDsgKSB7XG4gICAgICAgIGlmIChyaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApLCByaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBpZiAobWFya3MucHVzaCguLi5yaHMubWFya3MpLCBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pLCBzdHJbcG9zXSAhPT0gXCIsXCIpIGJyZWFrO1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIFwiKVwiIGFmdGVyIHR1cGxlIGV4cHJlc3Npb24nLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBwb3MrKywgbWFya3MucHVzaCh7IG5hbWU6IFwidHVwbGVfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIilcIjoge1xuICAgICAgcG9zKyssIG1hcmtzID0gW3sgbmFtZTogXCJncm91cFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiJHtzdHJbcG9zXX1cImAsIHBvc2l0aW9uOiBwb3MgfTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVHJhdmVyc2FsKHN0ciwgcG9zKSB7XG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgIGNhc2UgXCIuXCI6IHtcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwiKFwiKVxuICAgICAgICByZXR1cm4gcGFyc2VHcm91cE9yVHVwbGUoc3RyLCBwb3MpO1xuICAgICAgbGV0IGlkZW50U3RhcnQgPSBwb3MsIGlkZW50TGVuMiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICAgIHJldHVybiBpZGVudExlbjIgPyAocG9zICs9IGlkZW50TGVuMiwge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICB7IG5hbWU6IFwiYXR0cl9hY2Nlc3NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFN0YXJ0IH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgXSxcbiAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgfSkgOiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIGlkZW50aWZpZXIgYWZ0ZXIgXCIuXCInLCBwb3NpdGlvbjogcG9zIH07XG4gICAgfVxuICAgIGNhc2UgXCItXCI6XG4gICAgICBpZiAoc3RyW3BvcyArIDFdICE9PSBcIj5cIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiAnRXhwZWN0ZWQgXCI+XCIgaW4gcmVmZXJlbmNlJywgcG9zaXRpb246IHBvcyB9O1xuICAgICAgbGV0IG1hcmtzID0gW3sgbmFtZTogXCJkZXJlZlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV07XG4gICAgICBwb3MgKz0gMjtcbiAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIHBvcyksIGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICByZXR1cm4gaWRlbnRMZW4gJiYgKHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW4sIG1hcmtzLnB1c2goXG4gICAgICAgIHsgbmFtZTogXCJkZXJlZl9hdHRyXCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IGlkZW50UG9zIH0sXG4gICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICApKSwge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3MsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH07XG4gICAgY2FzZSBcIltcIjoge1xuICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSA9PT0gXCJdXCIpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwiYXJyYXlfcG9zdGZpeFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfTtcbiAgICAgIGxldCByYW5nZVBvcyA9IHBvcywgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiLlwiKSB7XG4gICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgc3RyW3BvcyArIDJdID09PSBcIi5cIiA/ICh0eXBlID0gXCJleGNfcmFuZ2VcIiwgcG9zICs9IDMpIDogcG9zICs9IDIsIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICByZXR1cm4gcmhzLnR5cGUgPT09IFwiZXJyb3JcIiA/IHJocyA6IChwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pLCBzdHJbcG9zXSAhPT0gXCJdXCIgPyB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIFwiXVwiIGFmdGVyIGFycmF5IGV4cHJlc3Npb24nLCBwb3NpdGlvbjogcG9zIH0gOiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJzbGljZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgIHsgbmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zIH1cbiAgICAgICAgICBdLmNvbmNhdChyZXN1bHQubWFya3MsIHJocy5tYXJrcyksXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyW3Bvc10gIT09IFwiXVwiID8geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIl1cIiBhZnRlciBhcnJheSBleHByZXNzaW9uJywgcG9zaXRpb246IHBvcyB9IDoge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwic3F1YXJlX2JyYWNrZXRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyZXN1bHQubWFya3MpLFxuICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInxcIjoge1xuICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBcImVycm9yXCIgfHwgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInByb2plY3Rpb25cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCByZXN1bHQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIntcIjoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIHx8IHJlc3VsdC5tYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwcm9qZWN0aW9uXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6IFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgaW4gdHJhdmVyc2FsXCIsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFtdO1xuICBpZiAobWFya3MucHVzaCh7IG5hbWU6IFwiZnVuY19jYWxsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgc3RyW3Bvc10gPT09IFwiOlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCI6XCIpIHtcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJuYW1lc3BhY2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAyKTtcbiAgICBsZXQgbmFtZUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICBpZiAoIW5hbWVMZW4pIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogXCJFeHBlY3RlZCBmdW5jdGlvbiBuYW1lXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICBpZiAobWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgKyBuYW1lTGVuIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyBuYW1lTGVuKSwgc3RyW3Bvc10gIT09IFwiKFwiKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiAnRXhwZWN0ZWQgXCIoXCIgYWZ0ZXIgZnVuY3Rpb24gbmFtZScsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICBwb3MrKywgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgfSBlbHNlXG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIGxldCBsYXN0UG9zID0gcG9zO1xuICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKVxuICAgIGZvciAoOyA7ICkge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmIChtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpLCBsYXN0UG9zID0gcmVzdWx0LnBvc2l0aW9uLCBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pLCBzdHJbcG9zXSAhPT0gXCIsXCIgfHwgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSA9PT0gXCIpXCIpKSBicmVhaztcbiAgICB9XG4gIHJldHVybiBzdHJbcG9zXSAhPT0gXCIpXCIgPyB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIFwiKVwiIGFmdGVyIGZ1bmN0aW9uIGFyZ3VtZW50cycsIHBvc2l0aW9uOiBwb3MgfSA6IChtYXJrcy5wdXNoKHsgbmFtZTogXCJmdW5jX2FyZ3NfZW5kXCIsIHBvc2l0aW9uOiBsYXN0UG9zIH0pLCB7XG4gICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgbWFya3MsXG4gICAgcG9zaXRpb246IHBvcyArIDFcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdChzdHIsIHBvcykge1xuICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcIm9iamVjdFwiLCBwb3NpdGlvbjogcG9zIH1dO1xuICBmb3IgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpOyBzdHJbcG9zXSAhPT0gXCJ9XCI7ICkge1xuICAgIGxldCBwYWlyUG9zID0gcG9zO1xuICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIilcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKSwgc3RyW3Bvc10gIT09IFwifVwiICYmIHN0cltwb3NdICE9PSBcIixcIikge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIGV4cHI7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9zcGxhdFwiLCBwb3NpdGlvbjogcGFpclBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQoZXhwci5tYXJrcyksIHBvcyA9IGV4cHIucG9zaXRpb247XG4gICAgICB9IGVsc2VcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3NwbGF0X3RoaXNcIiwgcG9zaXRpb246IHBhaXJQb3MgfSk7XG4gICAgZWxzZSB7XG4gICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpIHJldHVybiBleHByO1xuICAgICAgbGV0IG5leHRQb3MgPSBza2lwV1Moc3RyLCBleHByLnBvc2l0aW9uKTtcbiAgICAgIGlmIChleHByLm1hcmtzWzBdLm5hbWUgPT09IFwic3RyXCIgJiYgc3RyW25leHRQb3NdID09PSBcIjpcIikge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zICsgMSksIDApO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9wYWlyXCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzLCB2YWx1ZS5tYXJrcyksIHBvcyA9IHZhbHVlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHsgbmFtZTogXCJvYmplY3RfZXhwclwiLCBwb3NpdGlvbjogcG9zIH0sIGV4cHIubWFya3MpLCBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgIH1cbiAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgfVxuICByZXR1cm4gc3RyW3Bvc10gIT09IFwifVwiID8geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIn1cIiBhZnRlciBvYmplY3QnLCBwb3NpdGlvbjogcG9zIH0gOiAocG9zKyssIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSwgeyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIsIHBvcykge1xuICBsZXQgdG9rZW4gPSBzdHJbcG9zXTtcbiAgcG9zID0gcG9zICsgMTtcbiAgY29uc3QgbWFya3MgPSBbeyBuYW1lOiBcInN0clwiLCBwb3NpdGlvbjogcG9zIH1dO1xuICBzdHI6IGZvciAoOyA7IHBvcysrKSB7XG4gICAgaWYgKHBvcyA+IHN0ci5sZW5ndGgpIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogXCJVbmV4cGVjdGVkIGVuZCBvZiBxdWVyeVwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgY2FzZSB0b2tlbjoge1xuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcysrO1xuICAgICAgICBicmVhayBzdHI7XG4gICAgICB9XG4gICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfcGF1c2VcIiwgcG9zaXRpb246IHBvcyB9KSwgc3RyW3BvcyArIDFdID09PSBcInVcIiA/IHN0cltwb3MgKyAyXSA9PT0gXCJ7XCIgPyAobWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDMgfSksIHBvcyA9IHN0ci5pbmRleE9mKFwifVwiLCBwb3MgKyAzKSwgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSkpIDogKG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4XCIsIHBvc2l0aW9uOiBwb3MgKyAyIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleF9lbmRcIiwgcG9zaXRpb246IHBvcyArIDYgfSksIHBvcyArPSA1KSA6IChtYXJrcy5wdXNoKHsgbmFtZTogXCJzaW5nbGVfZXNjYXBlXCIsIHBvc2l0aW9uOiBwb3MgKyAxIH0pLCBwb3MgKz0gMSksIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9zdGFydFwiLCBwb3NpdGlvbjogcG9zICsgMSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zIH07XG59XG5mdW5jdGlvbiBza2lwV1Moc3RyLCBwb3MpIHtcbiAgcmV0dXJuIHBvcyArIHBhcnNlUmVnZXgoc3RyLCBwb3MsIFdTKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXgoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXS5sZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleFN0cihzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGpvaW4oYSwgYikge1xuICByZXR1cm4gKGJhc2UpID0+IGIoYShiYXNlKSk7XG59XG5mdW5jdGlvbiBtYXAoaW5uZXIpIHtcbiAgcmV0dXJuIChiYXNlKSA9PiAoeyB0eXBlOiBcIk1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xufVxuZnVuY3Rpb24gZmxhdE1hcChpbm5lcikge1xuICByZXR1cm4gKGJhc2UpID0+ICh7IHR5cGU6IFwiRmxhdE1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VBcnJheShidWlsZCwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgIGJ1aWxkXG4gICAgfTtcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBtYXAocmlnaHQuYnVpbGQpKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgZmxhdE1hcChyaWdodC5idWlsZCkpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVBsYWluKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImEtYlwiOlxuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUVsZW1lbnQobWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUHJvamVjdGlvbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5jb25zdCBFU0NBUEVfU0VRVUVOQ0UgPSB7XG4gIFwiJ1wiOiBcIidcIixcbiAgJ1wiJzogJ1wiJyxcbiAgXCJcXFxcXCI6IFwiXFxcXFwiLFxuICBcIi9cIjogXCIvXCIsXG4gIGI6IFwiXFxiXCIsXG4gIGY6IFwiXFxmXCIsXG4gIG46IGBcbmAsXG4gIHI6IFwiXFxyXCIsXG4gIHQ6IFwiXHRcIlxufTtcbmZ1bmN0aW9uIGV4cGFuZEhleChzdHIpIHtcbiAgY29uc3QgY2hhckNvZGUgPSBwYXJzZUludChzdHIsIDE2KTtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xufVxuY2xhc3MgR3JvcVF1ZXJ5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWUgPSBcIkdyb3FRdWVyeUVycm9yXCI7XG59XG5jb25zdCBFWFBSX0JVSUxERVIgPSB7XG4gIGdyb3VwKHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJHcm91cFwiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBldmVyeXRoaW5nKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiRXZlcnl0aGluZ1wiIH07XG4gIH0sXG4gIHRoaXMoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJUaGlzXCIgfTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhcmVudFwiLFxuICAgICAgbjogMVxuICAgIH07XG4gIH0sXG4gIGRibHBhcmVudChwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKS5uICsgMVxuICAgIH07XG4gIH0sXG4gIHRyYXZlcnNlKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHRyYXZlcnNhbExpc3QgPSBbXTtcbiAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0cmF2ZXJzYWxfZW5kXCI7IClcbiAgICAgIHRyYXZlcnNhbExpc3QucHVzaChwLnByb2Nlc3MoVFJBVkVSU0VfQlVJTERFUikpO1xuICAgIHAuc2hpZnQoKTtcbiAgICBsZXQgdHJhdmVyc2FsID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gdHJhdmVyc2FsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgIHRyYXZlcnNhbCA9IHRyYXZlcnNhbExpc3RbaV0odHJhdmVyc2FsKTtcbiAgICBpZiAoKGJhc2UudHlwZSA9PT0gXCJFdmVyeXRoaW5nXCIgfHwgYmFzZS50eXBlID09PSBcIkFycmF5XCIgfHwgYmFzZS50eXBlID09PSBcIlBpcGVGdW5jQ2FsbFwiKSAmJiAodHJhdmVyc2FsID0gdHJhdmVyc2VBcnJheSgodmFsKSA9PiB2YWwsIHRyYXZlcnNhbCkpLCB0cmF2ZXJzYWwgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkJVRzogdW5leHBlY3RlZCBlbXB0eSB0cmF2ZXJzYWxcIik7XG4gICAgcmV0dXJuIHRyYXZlcnNhbC5idWlsZChiYXNlKTtcbiAgfSxcbiAgdGhpc19hdHRyKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIG5hbWUgPT09IFwibnVsbFwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiBudWxsIH0gOiBuYW1lID09PSBcInRydWVcIiA/IHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogITAgfSA6IG5hbWUgPT09IFwiZmFsc2VcIiA/IHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogITEgfSA6IHtcbiAgICAgIHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfSxcbiAgbmVnKHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOZWdcIixcbiAgICAgIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpXG4gICAgfTtcbiAgfSxcbiAgcG9zKHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQb3NcIixcbiAgICAgIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpXG4gICAgfTtcbiAgfSxcbiAgYWRkKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIrXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBzdWIocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi1cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG11bChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgZGl2KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIvXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBtb2QocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIiVcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHBvdyhwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKipcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGNvbXAocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgb3AgPSBwLnByb2Nlc3NTdHJpbmcoKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgaW5fcmFuZ2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW5SYW5nZVwiLFxuICAgICAgYmFzZSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGlzSW5jbHVzaXZlXG4gICAgfTtcbiAgfSxcbiAgc3RyKHApIHtcbiAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgIGxvb3A6IGZvciAoOyBwLmhhc01hcmsoKTsgKSB7XG4gICAgICBjb25zdCBtYXJrID0gcC5nZXRNYXJrKCk7XG4gICAgICBzd2l0Y2ggKG1hcmsubmFtZSkge1xuICAgICAgICBjYXNlIFwic3RyX2VuZFwiOlxuICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIGNhc2UgXCJzdHJfcGF1c2VcIjpcbiAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0cl9zdGFydFwiOlxuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNpbmdsZV9lc2NhcGVcIjoge1xuICAgICAgICAgIGNvbnN0IGNoYXIgPSBwLnNsaWNlKDEpO1xuICAgICAgICAgIHAuc2hpZnQoKSwgdmFsdWUgKz0gRVNDQVBFX1NFUVVFTkNFW2NoYXJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ1bmljb2RlX2hleFwiOlxuICAgICAgICAgIHAuc2hpZnQoKSwgdmFsdWUgKz0gZXhwYW5kSGV4KHAucHJvY2Vzc1N0cmluZ0VuZCgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgbWFyazogJHttYXJrLm5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWUgfTtcbiAgfSxcbiAgaW50ZWdlcihwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBmbG9hdChwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBzY2kocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0KHApIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwib2JqZWN0X2VuZFwiOyApXG4gICAgICBhdHRyaWJ1dGVzLnB1c2gocC5wcm9jZXNzKE9CSkVDVF9CVUlMREVSKSk7XG4gICAgcmV0dXJuIHAuc2hpZnQoKSwge1xuICAgICAgdHlwZTogXCJPYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9O1xuICB9LFxuICBhcnJheShwKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJhcnJheV9lbmRcIjsgKSB7XG4gICAgICBsZXQgaXNTcGxhdCA9ICExO1xuICAgICAgcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJhcnJheV9zcGxhdFwiICYmIChpc1NwbGF0ID0gITAsIHAuc2hpZnQoKSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgZWxlbWVudHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiQXJyYXlFbGVtZW50XCIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpc1NwbGF0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHAuc2hpZnQoKSwge1xuICAgICAgdHlwZTogXCJBcnJheVwiLFxuICAgICAgZWxlbWVudHNcbiAgICB9O1xuICB9LFxuICB0dXBsZShwKSB7XG4gICAgY29uc3QgbWVtYmVycyA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInR1cGxlX2VuZFwiOyApXG4gICAgICBtZW1iZXJzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIHJldHVybiBwLnNoaWZ0KCksIHtcbiAgICAgIHR5cGU6IFwiVHVwbGVcIixcbiAgICAgIG1lbWJlcnNcbiAgICB9O1xuICB9LFxuICBmdW5jX2NhbGwocCkge1xuICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgIHAuZ2V0TWFyaygpLm5hbWUgPT09IFwibmFtZXNwYWNlXCIgJiYgKHAuc2hpZnQoKSwgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCkpO1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJTZWxlY3RcIixcbiAgICAgICAgYWx0ZXJuYXRpdmVzOiBbXVxuICAgICAgfTtcbiAgICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIjsgKVxuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKSB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuYWx0ZXJuYXRpdmVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJTZWxlY3RBbHRlcm5hdGl2ZVwiLFxuICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKSB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgcmVzdWx0LmZhbGxiYWNrID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBwLnNoaWZ0KCksIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIjsgKVxuICAgICAgYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgbmFtZSwgYXJncy5sZW5ndGgpID8gYXJncy5wdXNoKHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKSkgOiBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIGlmIChwLnNoaWZ0KCksIG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiAobmFtZSA9PT0gXCJiZWZvcmVcIiB8fCBuYW1lID09PSBcImFmdGVyXCIpICYmIHAucGFyc2VPcHRpb25zLm1vZGUgPT09IFwiZGVsdGFcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiQ29udGV4dFwiLFxuICAgICAgICBrZXk6IG5hbWVcbiAgICAgIH07XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcImJvb3N0XCIgJiYgIXAuYWxsb3dCb29zdClcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3RcIik7XG4gICAgY29uc3QgZnVuY3MgPSBuYW1lc3BhY2VzW25hbWVzcGFjZV07XG4gICAgaWYgKCFmdW5jcylcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIG5hbWVzcGFjZTogJHtuYW1lc3BhY2V9YCk7XG4gICAgY29uc3QgZnVuYyA9IGZ1bmNzW25hbWVdO1xuICAgIGlmICghZnVuYylcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgaWYgKGZ1bmMuYXJpdHkgIT09IHZvaWQgMCAmJiB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKSwgZnVuYy5tb2RlICE9PSB2b2lkIDAgJiYgZnVuYy5tb2RlICE9PSBwLnBhcnNlT3B0aW9ucy5tb2RlKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJGdW5jQ2FsbFwiLFxuICAgICAgZnVuYyxcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIG5hbWUsXG4gICAgICBhcmdzXG4gICAgfTtcbiAgfSxcbiAgcGlwZWNhbGwocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBwLnNoaWZ0KCk7XG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwibmFtZXNwYWNlXCIgJiYgKHAuc2hpZnQoKSwgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCkpLCBuYW1lc3BhY2UgIT09IFwiZ2xvYmFsXCIpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBuYW1lc3BhY2U6ICR7bmFtZXNwYWNlfWApO1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKSwgYXJncyA9IFtdLCBvbGRBbGxvd0Jvb3N0ID0gcC5hbGxvd0Jvb3N0O1xuICAgIGZvciAobmFtZSA9PT0gXCJzY29yZVwiICYmIChwLmFsbG93Qm9vc3QgPSAhMCk7IDsgKSB7XG4gICAgICBjb25zdCBtYXJrTmFtZSA9IHAuZ2V0TWFyaygpLm5hbWU7XG4gICAgICBpZiAobWFya05hbWUgPT09IFwiZnVuY19hcmdzX2VuZFwiKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChuYW1lID09PSBcIm9yZGVyXCIpIHtcbiAgICAgICAgaWYgKG1hcmtOYW1lID09PSBcImFzY1wiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpLCBhcmdzLnB1c2goeyB0eXBlOiBcIkFzY1wiLCBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXJrTmFtZSA9PT0gXCJkZXNjXCIpIHtcbiAgICAgICAgICBwLnNoaWZ0KCksIGFyZ3MucHVzaCh7IHR5cGU6IFwiRGVzY1wiLCBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpLCBwLmFsbG93Qm9vc3QgPSBvbGRBbGxvd0Jvb3N0O1xuICAgIGNvbnN0IGZ1bmMgPSBwaXBlRnVuY3Rpb25zW25hbWVdO1xuICAgIGlmICghZnVuYylcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIHBpcGUgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICByZXR1cm4gZnVuYy5hcml0eSAmJiB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKSwge1xuICAgICAgdHlwZTogXCJQaXBlRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBiYXNlLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9LFxuICBwYWlyKCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgPT5cIik7XG4gIH0sXG4gIGFuZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFuZFwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgb3IocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPclwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbm90KHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOb3RcIixcbiAgICAgIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpXG4gICAgfTtcbiAgfSxcbiAgYXNjKCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXNjXCIpO1xuICB9LFxuICBkZXNjKCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgZGVzY1wiKTtcbiAgfSxcbiAgcGFyYW0ocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gcC5wYXJzZU9wdGlvbnMucGFyYW1zICYmIHAucGFyc2VPcHRpb25zLnBhcmFtcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBwLnBhcnNlT3B0aW9ucy5wYXJhbXNbbmFtZV1cbiAgICB9IDoge1xuICAgICAgdHlwZTogXCJQYXJhbWV0ZXJcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9XG59LCBPQkpFQ1RfQlVJTERFUiA9IHtcbiAgb2JqZWN0X2V4cHIocCkge1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInBhaXJcIikge1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgY29uc3QgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHZhbHVlMiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCIsXG4gICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgbmFtZTogZXh0cmFjdFByb3BlcnR5S2V5KHZhbHVlKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3BhaXIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBpZiAobmFtZS50eXBlICE9PSBcIlZhbHVlXCIpIHRocm93IG5ldyBFcnJvcihcIm5hbWUgbXVzdCBiZSBzdHJpbmdcIik7XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgbmFtZTogbmFtZS52YWx1ZSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3NwbGF0KHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxuICAgICAgdmFsdWU6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3NwbGF0X3RoaXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlOiB7IHR5cGU6IFwiVGhpc1wiIH1cbiAgICB9O1xuICB9XG59LCBUUkFWRVJTRV9CVUlMREVSID0ge1xuICBzcXVhcmVfYnJhY2tldChwKSB7XG4gICAgY29uc3QgZXhwciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCB2YWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUoZXhwcik7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwibnVtYmVyXCIgPyAocmlnaHQpID0+IHRyYXZlcnNlRWxlbWVudCgoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NFbGVtZW50XCIsIGJhc2UsIGluZGV4OiB2YWx1ZS5kYXRhIH0pLCByaWdodCkgOiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiID8gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lOiB2YWx1ZS5kYXRhIH0pLCByaWdodCkgOiAocmlnaHQpID0+IHRyYXZlcnNlQXJyYXkoXG4gICAgICAoYmFzZSkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJGaWx0ZXJcIixcbiAgICAgICAgYmFzZSxcbiAgICAgICAgZXhwclxuICAgICAgfSksXG4gICAgICByaWdodFxuICAgICk7XG4gIH0sXG4gIHNsaWNlKHApIHtcbiAgICBjb25zdCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgbGVmdFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShsZWZ0KSwgcmlnaHRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUocmlnaHQpO1xuICAgIGlmICghbGVmdFZhbHVlIHx8ICFyaWdodFZhbHVlIHx8IGxlZnRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInNsaWNpbmcgbXVzdCB1c2UgY29uc3RhbnQgbnVtYmVyc1wiKTtcbiAgICByZXR1cm4gKHJocykgPT4gdHJhdmVyc2VBcnJheShcbiAgICAgIChiYXNlKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIlNsaWNlXCIsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGxlZnQ6IGxlZnRWYWx1ZS5kYXRhLFxuICAgICAgICByaWdodDogcmlnaHRWYWx1ZS5kYXRhLFxuICAgICAgICBpc0luY2x1c2l2ZVxuICAgICAgfSksXG4gICAgICByaHNcbiAgICApO1xuICB9LFxuICBwcm9qZWN0aW9uKHApIHtcbiAgICBjb25zdCBvYmogPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVByb2plY3Rpb24oKGJhc2UpID0+ICh7IHR5cGU6IFwiUHJvamVjdGlvblwiLCBiYXNlLCBleHByOiBvYmogfSksIHJpZ2h0KTtcbiAgfSxcbiAgYXR0cl9hY2Nlc3MocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lIH0pLCByaWdodCk7XG4gIH0sXG4gIGRlcmVmKHApIHtcbiAgICBsZXQgYXR0ciA9IG51bGw7XG4gICAgcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJkZXJlZl9hdHRyXCIgJiYgKHAuc2hpZnQoKSwgYXR0ciA9IHAucHJvY2Vzc1N0cmluZygpKTtcbiAgICBjb25zdCB3cmFwID0gKGJhc2UpID0+IGF0dHIgPyB7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWU6IGF0dHIgfSA6IGJhc2U7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbihcbiAgICAgIChiYXNlKSA9PiB3cmFwKHtcbiAgICAgICAgdHlwZTogXCJEZXJlZlwiLFxuICAgICAgICBiYXNlXG4gICAgICB9KSxcbiAgICAgIHJpZ2h0XG4gICAgKTtcbiAgfSxcbiAgYXJyYXlfcG9zdGZpeCgpIHtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZUFycmF5KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFycmF5Q29lcmNlXCIsIGJhc2UgfSksIHJpZ2h0KTtcbiAgfVxufSwgU0VMRUNUT1JfQlVJTERFUiA9IHtcbiAgZ3JvdXAocCkge1xuICAgIHJldHVybiBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gIH0sXG4gIGV2ZXJ5dGhpbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHRoaXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBhcmVudCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZGJscGFyZW50KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0cmF2ZXJzZShwKSB7XG4gICAgbGV0IG5vZGUgPSBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHJhdmVyc2FsX2VuZFwiOyApXG4gICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJhcnJheV9wb3N0Zml4XCIpXG4gICAgICAgIHAuc2hpZnQoKSwgbm9kZSA9IHsgdHlwZTogXCJBcnJheUNvZXJjZVwiLCBiYXNlOiBub2RlIH07XG4gICAgICBlbHNlIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInNxdWFyZV9icmFja2V0XCIpIHtcbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICBjb25zdCBleHByID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShleHByKTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcnJheSBhY2Nlc3MgZXhwcmVzc2lvblwiKTtcbiAgICAgICAgdmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIiA/IG5vZGUgPSB7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2U6IG5vZGUsIG5hbWU6IHZhbHVlLmRhdGEgfSA6IG5vZGUgPSB7IHR5cGU6IFwiRmlsdGVyXCIsIGJhc2U6IG5vZGUsIGV4cHIgfTtcbiAgICAgIH0gZWxzZSBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJhdHRyX2FjY2Vzc1wiKSB7XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICBub2RlID0geyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlOiBub2RlLCBuYW1lIH07XG4gICAgICB9IGVsc2UgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwidHVwbGVcIiB8fCBwLmdldE1hcmsoKS5uYW1lID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgICAgIGlmICghaXNTZWxlY3Rvck5lc3RlZChzZWxlY3RvcikpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHJlc3VsdCBwYXJzaW5nIG5lc3RlZCBzZWxlY3RvcjogJHtzZWxlY3Rvci50eXBlfWApO1xuICAgICAgICBub2RlID0geyB0eXBlOiBcIlNlbGVjdG9yTmVzdGVkXCIsIGJhc2U6IG5vZGUsIG5lc3RlZDogc2VsZWN0b3IgfTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgICByZXR1cm4gcC5zaGlmdCgpLCBub2RlO1xuICB9LFxuICB0aGlzX2F0dHIocCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIG5hbWU6IHAucHJvY2Vzc1N0cmluZygpIH07XG4gIH0sXG4gIGF0dHJfYWNjZXNzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBuZWcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYWRkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBzdWIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG11bCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZGl2KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBtb2QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvdygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgY29tcCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgaW5fcmFuZ2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN0cigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgaW50ZWdlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZmxvYXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHNjaSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgb2JqZWN0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhcnJheSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdHVwbGUocCkge1xuICAgIGNvbnN0IHNlbGVjdG9ycyA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInR1cGxlX2VuZFwiOyApXG4gICAgICBzZWxlY3RvcnMucHVzaChwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUikpO1xuICAgIHJldHVybiBwLnNoaWZ0KCksIHsgdHlwZTogXCJUdXBsZVwiLCBtZW1iZXJzOiBzZWxlY3RvcnMgfTtcbiAgfSxcbiAgZnVuY19jYWxsKHAsIG1hcmspIHtcbiAgICBjb25zdCBmdW5jID0gRVhQUl9CVUlMREVSLmZ1bmNfY2FsbChwLCBtYXJrKTtcbiAgICBpZiAoZnVuYy5uYW1lID09PSBcImFueXdoZXJlXCIgJiYgZnVuYy5hcmdzLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiU2VsZWN0b3JGdW5jQ2FsbFwiLFxuICAgICAgICBuYW1lOiBcImFueXdoZXJlXCIsXG4gICAgICAgIGFyZzogZnVuYy5hcmdzWzBdXG4gICAgICB9O1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwaXBlY2FsbCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFpcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYW5kKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbm90KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhc2MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRlc2MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBhcmFtKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9XG59O1xuZnVuY3Rpb24gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NBdHRyaWJ1dGVcIiAmJiAhbm9kZS5iYXNlKVxuICAgIHJldHVybiBub2RlLm5hbWU7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiUGlwZUZ1bmNDYWxsXCIgfHwgbm9kZS50eXBlID09PSBcIkRlcmVmXCIgfHwgbm9kZS50eXBlID09PSBcIk1hcFwiIHx8IG5vZGUudHlwZSA9PT0gXCJQcm9qZWN0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlNsaWNlXCIgfHwgbm9kZS50eXBlID09PSBcIkZpbHRlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NFbGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkFycmF5Q29lcmNlXCIgfHwgbm9kZS50eXBlID09PSBcIkdyb3VwXCIpXG4gICAgcmV0dXJuIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlLmJhc2UpO1xuICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYENhbm5vdCBkZXRlcm1pbmUgcHJvcGVydHkga2V5IGZvciB0eXBlOiAke25vZGUudHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXJpdHkobmFtZSwgYXJpdHksIGNvdW50KSB7XG4gIGlmICh0eXBlb2YgYXJpdHkgPT0gXCJudW1iZXJcIikge1xuICAgIGlmIChjb3VudCAhPT0gYXJpdHkpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXG4gICAgICAgIGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuIEV4cGVjdGVkICR7YXJpdHl9LCBnb3QgJHtjb3VudH0uYFxuICAgICAgKTtcbiAgfSBlbHNlIGlmIChhcml0eSAmJiAhYXJpdHkoY291bnQpKVxuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJHtuYW1lfSgpLmApO1xufVxuZnVuY3Rpb24gYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgZnVuY3Rpb25OYW1lLCBhcmdDb3VudCkge1xuICBjb25zdCBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMgPSBbXCJjaGFuZ2VkQW55XCIsIFwiY2hhbmdlZE9ubHlcIl07XG4gIHJldHVybiBuYW1lc3BhY2UgPT0gXCJkaWZmXCIgJiYgYXJnQ291bnQgPT0gMiAmJiBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMuaW5jbHVkZXMoZnVuY3Rpb25OYW1lKTtcbn1cbmNsYXNzIEdyb3FTeW50YXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcG9zaXRpb247XG4gIG5hbWUgPSBcIkdyb3FTeW50YXhFcnJvclwiO1xuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbiwgZGV0YWlsKSB7XG4gICAgc3VwZXIoYFN5bnRheCBlcnJvciBpbiBHUk9RIHF1ZXJ5IGF0IHBvc2l0aW9uICR7cG9zaXRpb259JHtkZXRhaWwgPyBcIjogXCIgKyBkZXRhaWwgOiBcIlwifWApLCB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2UkMShpbnB1dCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgIHRocm93IG5ldyBHcm9xU3ludGF4RXJyb3IocmVzdWx0LnBvc2l0aW9uLCByZXN1bHQubWVzc2FnZSk7XG4gIHJldHVybiBuZXcgTWFya1Byb2Nlc3NvcihpbnB1dCwgcmVzdWx0Lm1hcmtzLCBvcHRpb25zKS5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG59XG5jb25zdCB7IGNvbXBhcmUgfSA9IG5ldyBJbnRsLkNvbGxhdG9yKFwiZW5cIik7XG5mdW5jdGlvbiB0eXBlTm9kZXNTb3J0ZXIoYSwgYikge1xuICByZXR1cm4gYS50eXBlID09PSBcIm51bGxcIiA/IDEgOiBjb21wYXJlKGhhc2hGaWVsZChhKSwgaGFzaEZpZWxkKGIpKTtcbn1cbmNvbnN0IGhhc2hDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaGFzaEZpZWxkKGZpZWxkKSB7XG4gIGlmIChoYXNoQ2FjaGUuaGFzKGZpZWxkKSlcbiAgICByZXR1cm4gaGFzaENhY2hlLmdldChmaWVsZCk7XG4gIGNvbnN0IGhhc2ggPSBjYWxjdWxhdGVGaWVsZEhhc2goZmllbGQpO1xuICByZXR1cm4gaGFzaENhY2hlLnNldChmaWVsZCwgaGFzaCksIGhhc2g7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVGaWVsZEhhc2goZmllbGQpIHtcbiAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIGZpZWxkLnZhbHVlICE9PSB2b2lkIDAgPyBgJHtmaWVsZC50eXBlfSgke2ZpZWxkLnZhbHVlfSlgIDogYCR7ZmllbGQudHlwZX1gO1xuICAgIGNhc2UgXCJudWxsXCI6XG4gICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgIHJldHVybiBmaWVsZC50eXBlO1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIGAke2ZpZWxkLnR5cGV9KCR7aGFzaEZpZWxkKGZpZWxkLm9mKX0pYDtcbiAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhmaWVsZC5hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzLnNvcnQoKFthXSwgW2JdKSA9PiBjb21wYXJlKGEsIGIpKSwgYCR7ZmllbGQudHlwZX06KCR7YXR0cmlidXRlcy5tYXAoXG4gICAgICAgIChba2V5LCB2YWx1ZV0pID0+IGAke2tleX06JHtoYXNoRmllbGQodmFsdWUudmFsdWUpfSgke3ZhbHVlLm9wdGlvbmFsID8gXCJvcHRpb25hbFwiIDogXCJub24tb3B0aW9uYWxcIn0pYFxuICAgICAgKS5qb2luKFwiLFwiKX0pOnJlZi0ke2ZpZWxkLmRlcmVmZXJlbmNlc1RvfToke2ZpZWxkLnJlc3QgPyBoYXNoRmllbGQoZmllbGQucmVzdCkgOiBcIm5vLXJlc3RcIn1gO1xuICAgIH1cbiAgICBjYXNlIFwidW5pb25cIjoge1xuICAgICAgY29uc3Qgc29ydGVkID0gWy4uLmZpZWxkLm9mXTtcbiAgICAgIHJldHVybiBzb3J0ZWQuc29ydCh0eXBlTm9kZXNTb3J0ZXIpLCBgJHtmaWVsZC50eXBlfSgke3NvcnRlZC5tYXAoaGFzaEZpZWxkKS5qb2luKFwiLFwiKX0pYDtcbiAgICB9XG4gICAgY2FzZSBcImlubGluZVwiOlxuICAgICAgcmV0dXJuIGAke2ZpZWxkLnR5cGV9KCR7ZmllbGQubmFtZX0pYDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZpZWxkLnR5cGU7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZVR5cGVOb2Rlcyh0eXBlTm9kZXMpIHtcbiAgY29uc3Qgc2VlblR5cGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbmV3VHlwZU5vZGVzID0gW10sIHNvcnRlZFR5cGVOb2RlcyA9IFsuLi50eXBlTm9kZXNdO1xuICBzb3J0ZWRUeXBlTm9kZXMuc29ydCh0eXBlTm9kZXNTb3J0ZXIpO1xuICBmb3IgKGNvbnN0IHR5cGVOb2RlIG9mIHNvcnRlZFR5cGVOb2Rlcykge1xuICAgIGNvbnN0IGhhc2ggPSBoYXNoRmllbGQodHlwZU5vZGUpO1xuICAgIGlmIChoYXNoID09PSBudWxsKSB7XG4gICAgICBuZXdUeXBlTm9kZXMucHVzaCh0eXBlTm9kZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc2VlblR5cGVzLmhhcyhoYXNoKSB8fCAoc2VlblR5cGVzLmFkZChoYXNoKSwgbmV3VHlwZU5vZGVzLnB1c2godHlwZU5vZGUpKTtcbiAgfVxuICByZXR1cm4gbmV3VHlwZU5vZGVzO1xufVxuZnVuY3Rpb24gb3B0aW1pemVVbmlvbnMoZmllbGQpIHtcbiAgaWYgKGZpZWxkLnR5cGUgPT09IFwidW5pb25cIikge1xuICAgIGlmIChmaWVsZC5vZi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gZmllbGQ7XG4gICAgaWYgKGZpZWxkLm9mID0gcmVtb3ZlRHVwbGljYXRlVHlwZU5vZGVzKGZpZWxkLm9mKSwgZmllbGQub2YubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIG9wdGltaXplVW5pb25zKGZpZWxkLm9mWzBdKTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBmaWVsZC5vZi5sZW5ndGggPiBpZHg7IGlkeCsrKSB7XG4gICAgICBjb25zdCBzdWJGaWVsZCA9IGZpZWxkLm9mW2lkeF07XG4gICAgICBpZiAoc3ViRmllbGQudHlwZSA9PT0gXCJ1bmlvblwiKSB7XG4gICAgICAgIGZpZWxkLm9mLnNwbGljZShpZHgsIDEsIC4uLnN1YkZpZWxkLm9mKSwgaWR4LS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZmllbGQub2ZbaWR4XSA9IG9wdGltaXplVW5pb25zKHN1YkZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLm9mLnNvcnQoKGEsIGIpID0+IGEudHlwZSA9PT0gXCJudWxsXCIgPyAxIDogY29tcGFyZShoYXNoRmllbGQoYSksIGhhc2hGaWVsZChiKSkpLCBmaWVsZDtcbiAgfVxuICBpZiAoZmllbGQudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgIHJldHVybiBmaWVsZC5vZiA9IG9wdGltaXplVW5pb25zKGZpZWxkLm9mKSwgZmllbGQ7XG4gIGlmIChmaWVsZC50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgZm9yIChjb25zdCBpZHggaW4gZmllbGQuYXR0cmlidXRlcylcbiAgICAgIE9iamVjdC5oYXNPd24oZmllbGQuYXR0cmlidXRlcywgaWR4KSAmJiAoZmllbGQuYXR0cmlidXRlc1tpZHhdLnZhbHVlID0gb3B0aW1pemVVbmlvbnMoZmllbGQuYXR0cmlidXRlc1tpZHhdLnZhbHVlKSk7XG4gICAgcmV0dXJuIGZpZWxkO1xuICB9XG4gIHJldHVybiBmaWVsZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZmVyZW5jZVR5cGVOb2RlKG5hbWUsIGluQXJyYXkgPSAhMSkge1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgIF9yZWY6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9XG4gICAgfSxcbiAgICBfdHlwZToge1xuICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBcInJlZmVyZW5jZVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBfd2Vhazoge1xuICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICB9LFxuICAgICAgb3B0aW9uYWw6ICEwXG4gICAgfVxuICB9O1xuICByZXR1cm4gaW5BcnJheSAmJiAoYXR0cmlidXRlcy5fa2V5ID0ge1xuICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICB9XG4gIH0pLCB7XG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGRlcmVmZXJlbmNlc1RvOiBuYW1lXG4gIH07XG59XG5mdW5jdGlvbiBudWxsVW5pb24obm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcInVuaW9uXCIgPyB1bmlvbk9mKC4uLm5vZGUub2YsIHsgdHlwZTogXCJudWxsXCIgfSkgOiB1bmlvbk9mKG5vZGUsIHsgdHlwZTogXCJudWxsXCIgfSk7XG59XG5mdW5jdGlvbiB1bmlvbk9mKC4uLm5vZGVzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiBub2Rlc1xuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUlubGluZShub2RlLCBzY29wZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcImlubGluZVwiKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmxpbmUgPSBzY29wZS5jb250ZXh0Lmxvb2t1cFR5cGVEZWNsYXJhdGlvbihub2RlKTtcbiAgICByZXR1cm4gcmVzb2x2ZUlubGluZShyZXNvbHZlZElubGluZSwgc2NvcGUpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbWFwTm9kZShub2RlLCBzY29wZSwgbWFwcGVyLCBtZXJnZVVuaW9ucyA9IChub2RlcykgPT4gb3B0aW1pemVVbmlvbnMoeyB0eXBlOiBcInVuaW9uXCIsIG9mOiBub2RlcyB9KSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwidW5rbm93blwiOlxuICAgICAgcmV0dXJuIG1hcHBlcihub2RlKTtcbiAgICBjYXNlIFwidW5pb25cIjpcbiAgICAgIHJldHVybiBtZXJnZVVuaW9ucyhub2RlLm9mLm1hcCgoaW5uZXIpID0+IG1hcE5vZGUoaW5uZXIsIHNjb3BlLCBtYXBwZXIpLCBtZXJnZVVuaW9ucykpO1xuICAgIGNhc2UgXCJpbmxpbmVcIjoge1xuICAgICAgY29uc3QgcmVzb2x2ZWRJbmxpbmUgPSByZXNvbHZlSW5saW5lKG5vZGUsIHNjb3BlKTtcbiAgICAgIHJldHVybiBtYXBOb2RlKHJlc29sdmVkSW5saW5lLCBzY29wZSwgbWFwcGVyLCBtZXJnZVVuaW9ucyk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdHlwZTogJHtub2RlLnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRnVuY0NhbGwobm9kZSwgbmFtZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcIkdyb3VwXCIgPyBpc0Z1bmNDYWxsKG5vZGUuYmFzZSwgbmFtZSkgOiBub2RlLnR5cGUgPT09IFwiRnVuY0NhbGxcIiAmJiBgJHtub2RlLm5hbWVzcGFjZX06OiR7bm9kZS5uYW1lfWAgPT09IG5hbWU7XG59XG5mdW5jdGlvbiBjcmVhdGVHZW9Kc29uKHR5cGUgPSBcIlBvaW50XCIpIHtcbiAgbGV0IGNvb3JkaW5hdGVBdHRyaWJ1dGUgPSB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG9mOiB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgfVxuICB9O1xuICByZXR1cm4gdHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIgJiYgKGNvb3JkaW5hdGVBdHRyaWJ1dGUgPSB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG9mOiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBvZjoge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICB9XG4gICAgfVxuICB9KSwgdHlwZSA9PT0gXCJQb2x5Z29uXCIgJiYgKGNvb3JkaW5hdGVBdHRyaWJ1dGUgPSB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG9mOiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBvZjoge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIG9mOiB7XG4gICAgICAgICAgdHlwZTogXCJudW1iZXJcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSwge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgdHlwZToge1xuICAgICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvb3JkaW5hdGVzOiB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICAgIHZhbHVlOiBjb29yZGluYXRlQXR0cmlidXRlXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYm9vbGVhblZhbHVlKG5vZGUsIHNjb3BlKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgIHJldHVybiB7IGNhbkJlVHJ1ZTogITAsIGNhbkJlRmFsc2U6ICEwLCBjYW5CZU51bGw6ICEwIH07XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBub2RlLnZhbHVlID09PSAhMCA/IHsgY2FuQmVUcnVlOiAhMCwgY2FuQmVGYWxzZTogITEsIGNhbkJlTnVsbDogITEgfSA6IG5vZGUudmFsdWUgPT09ICExID8geyBjYW5CZVRydWU6ICExLCBjYW5CZUZhbHNlOiAhMCwgY2FuQmVOdWxsOiAhMSB9IDogeyBjYW5CZVRydWU6ICEwLCBjYW5CZUZhbHNlOiAhMCwgY2FuQmVOdWxsOiAhMSB9O1xuICAgIGNhc2UgXCJ1bmlvblwiOiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHsgY2FuQmVUcnVlOiAhMSwgY2FuQmVGYWxzZTogITEsIGNhbkJlTnVsbDogITEgfTtcbiAgICAgIGZvciAoY29uc3Qgc3ViIG9mIG5vZGUub2YpIHtcbiAgICAgICAgY29uc3QgbWF0Y2gyID0gYm9vbGVhblZhbHVlKHN1Yiwgc2NvcGUpO1xuICAgICAgICBtYXRjaDIuY2FuQmVOdWxsICYmICh2YWx1ZS5jYW5CZU51bGwgPSAhMCksIG1hdGNoMi5jYW5CZVRydWUgJiYgKHZhbHVlLmNhbkJlVHJ1ZSA9ICEwKSwgbWF0Y2gyLmNhbkJlRmFsc2UgJiYgKHZhbHVlLmNhbkJlRmFsc2UgPSAhMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNhc2UgXCJpbmxpbmVcIjoge1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlSW5saW5lKG5vZGUsIHNjb3BlKTtcbiAgICAgIHJldHVybiBib29sZWFuVmFsdWUocmVzb2x2ZWQsIHNjb3BlKTtcbiAgICB9XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJldHVybiB7IGNhbkJlVHJ1ZTogITEsIGNhbkJlRmFsc2U6ICExLCBjYW5CZU51bGw6ICEwIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBub2RlIHR5cGUgJHtub2RlLnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJvb2xlYW5PcihsZWZ0LCByaWdodCkge1xuICByZXR1cm4gbGVmdC5jYW5CZVRydWUgJiYgIWxlZnQuY2FuQmVGYWxzZSAmJiAhbGVmdC5jYW5CZU51bGwgPyBsZWZ0IDogcmlnaHQuY2FuQmVUcnVlICYmICFyaWdodC5jYW5CZUZhbHNlICYmICFyaWdodC5jYW5CZU51bGwgPyByaWdodCA6IHtcbiAgICAvLyBFaXRoZXIgc2lkZSBjYW4gYmUgdHJ1ZSBmb3IgdGhlIGV4cHJlc3Npb24gdG8gYmUgdHJ1ZVxuICAgIGNhbkJlVHJ1ZTogbGVmdC5jYW5CZVRydWUgfHwgcmlnaHQuY2FuQmVUcnVlLFxuICAgIC8vIEJvdGggc2lkZXMgbXVzdCBiZSBmYWxzZSBmb3IgdGhlIGV4cHJlc3Npb24gdG8gYmUgZmFsc2VcbiAgICBjYW5CZUZhbHNlOiBsZWZ0LmNhbkJlRmFsc2UgJiYgcmlnaHQuY2FuQmVGYWxzZSxcbiAgICAvLyBpZiBlaXRoZXIgc2lkZSBjYW4gYmUgbnVsbCwgdGhlIGV4cHJlc3Npb24gY2FuIGJlIG51bGwgaWYgdGhlIG90aGVyIHNpZGUgY2FuJ3Qgb25seSBiZSB0cnVlXG4gICAgY2FuQmVOdWxsOiBsZWZ0LmNhbkJlTnVsbCB8fCByaWdodC5jYW5CZU51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGJvb2xlYW5BbmQobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIGxlZnQuY2FuQmVGYWxzZSAmJiAhbGVmdC5jYW5CZVRydWUgJiYgIWxlZnQuY2FuQmVOdWxsID8gbGVmdCA6IHJpZ2h0LmNhbkJlRmFsc2UgJiYgIXJpZ2h0LmNhbkJlVHJ1ZSAmJiAhcmlnaHQuY2FuQmVOdWxsID8gcmlnaHQgOiB7XG4gICAgLy8gQm90aCBzaWRlcyBtdXN0IGJlIHRydWUgZm9yIHRoZSBleHByZXNzaW9uIHRvIGJlIHRydWVcbiAgICBjYW5CZVRydWU6IGxlZnQuY2FuQmVUcnVlICYmIHJpZ2h0LmNhbkJlVHJ1ZSxcbiAgICAvLyBpZiBlaXRoZXIgc2lkZSBjYW4gYmUgZmFsc2UsIHRoZSBleHByZXNzaW9uIGNhbiBiZSBmYWxzZVxuICAgIGNhbkJlRmFsc2U6IGxlZnQuY2FuQmVGYWxzZSB8fCByaWdodC5jYW5CZUZhbHNlLFxuICAgIC8vIGlmIGVpdGhlciBzaWRlIGNhbiBiZSBudWxsLCB0aGUgZXhwcmVzc2lvbiBjYW4gYmUgbnVsbFxuICAgIGNhbkJlTnVsbDogbGVmdC5jYW5CZU51bGwgfHwgcmlnaHQuY2FuQmVOdWxsXG4gIH07XG59XG5mdW5jdGlvbiBib29sZWFuSW50ZXJwcmV0YXRpb25Ub1R5cGVOb2RlKGJvb2wpIHtcbiAgcmV0dXJuIGJvb2wuY2FuQmVUcnVlID8gYm9vbC5jYW5CZUZhbHNlID8gYm9vbC5jYW5CZU51bGwgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IHsgdHlwZTogXCJib29sZWFuXCIgfSA6IGJvb2wuY2FuQmVOdWxsID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIsIHZhbHVlOiAhMCB9KSA6IHsgdHlwZTogXCJib29sZWFuXCIsIHZhbHVlOiAhMCB9IDogYm9vbC5jYW5CZUZhbHNlID8gYm9vbC5jYW5CZU51bGwgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6ICExIH0pIDogeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6ICExIH0gOiB7IHR5cGU6IFwibnVsbFwiIH07XG59XG5mdW5jdGlvbiB1bmlvbldpdGhvdXROdWxsKHVuaW9uVHlwZU5vZGUpIHtcbiAgcmV0dXJuIHVuaW9uVHlwZU5vZGUudHlwZSA9PT0gXCJ1bmlvblwiID8ge1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBvZjogdW5pb25UeXBlTm9kZS5vZi5maWx0ZXIoKHR5cGUpID0+IHR5cGUudHlwZSAhPT0gXCJudWxsXCIpXG4gIH0gOiB1bmlvblR5cGVOb2RlO1xufVxuZnVuY3Rpb24gaGFuZGxlRnVuY0NhbGxOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIHN3aXRjaCAoYCR7bm9kZS5uYW1lc3BhY2V9LiR7bm9kZS5uYW1lfWApIHtcbiAgICBjYXNlIFwiYXJyYXkuY29tcGFjdFwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiB7XG4gICAgICAgIGlmIChhcmcyLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgICAgIHJldHVybiBudWxsVW5pb24oeyB0eXBlOiBcImFycmF5XCIsIG9mOiB7IHR5cGU6IFwidW5rbm93blwiIH0gfSk7XG4gICAgICAgIGlmIChhcmcyLnR5cGUgIT09IFwiYXJyYXlcIilcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICBjb25zdCBvZiA9IG1hcE5vZGUoYXJnMi5vZiwgc2NvcGUsIChvZjIpID0+IG9mMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIG9mOiB1bmlvbldpdGhvdXROdWxsKG9mKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJhcnJheS5qb2luXCI6IHtcbiAgICAgIGNvbnN0IGFycmF5QXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSksIHNlcEFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoXG4gICAgICAgIGFycmF5QXJnLFxuICAgICAgICBzY29wZSxcbiAgICAgICAgKGFycmF5QXJnMikgPT4gbWFwTm9kZShzZXBBcmcsIHNjb3BlLCAoc2VwQXJnMikgPT4gYXJyYXlBcmcyLnR5cGUgPT09IFwidW5rbm93blwiIHx8IHNlcEFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJyYXlBcmcyLnR5cGUgIT09IFwiYXJyYXlcIiB8fCBzZXBBcmcyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKGFycmF5QXJnMi5vZiwgc2NvcGUsIChvZikgPT4gb2YudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogb2YudHlwZSAhPT0gXCJzdHJpbmdcIiAmJiBvZi50eXBlICE9PSBcIm51bWJlclwiICYmIG9mLnR5cGUgIT09IFwiYm9vbGVhblwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogeyB0eXBlOiBcInN0cmluZ1wiIH0pKVxuICAgICAgKTtcbiAgICB9XG4gICAgY2FzZSBcImFycmF5LnVuaXF1ZVwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiBhcmcyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJhcnJheVwiLCBvZjogeyB0eXBlOiBcInVua25vd25cIiB9IH0pIDogYXJnMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBhcmcyKTtcbiAgICB9XG4gICAgY2FzZSBcImFycmF5LmludGVyc2VjdHNcIjoge1xuICAgICAgY29uc3QgYXJnMSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pLCBhcmcyID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1sxXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShcbiAgICAgICAgYXJnMSxcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIChhcmcxMikgPT4gbWFwTm9kZShhcmcyLCBzY29wZSwgKGFyZzIyKSA9PiBhcmcxMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBhcmcyMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLmxvd2VyXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJnMi50eXBlICE9PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bGxcIiB9IDogYXJnMi52YWx1ZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogYXJnMi52YWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgICB9IDogeyB0eXBlOiBcInN0cmluZ1wiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLnVwcGVyXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJnMi50eXBlICE9PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bGxcIiB9IDogYXJnMi52YWx1ZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogYXJnMi52YWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgICB9IDogeyB0eXBlOiBcInN0cmluZ1wiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZGF0ZVRpbWUubm93XCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInN0cmluZ1wiIH07XG4gICAgY2FzZSBcImdsb2JhbC5ub3dcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIgfTtcbiAgICBjYXNlIFwiZ2xvYmFsLmRlZmluZWRcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAobm9kZTIpID0+IG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8geyB0eXBlOiBcImJvb2xlYW5cIiB9IDogeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6IG5vZGUyLnR5cGUgIT09IFwibnVsbFwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLnBhdGhcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwic3RyaW5nXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwuY29hbGVzY2VcIjoge1xuICAgICAgaWYgKG5vZGUuYXJncy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICBjb25zdCB0eXBlTm9kZXMgPSBbXTtcbiAgICAgIGxldCBjYW5CZU51bGwgPSAhMDtcbiAgICAgIGZvciAoY29uc3QgYXJnIG9mIG5vZGUuYXJncykge1xuICAgICAgICBjb25zdCBhcmdOb2RlID0gb3B0aW1pemVVbmlvbnMod2Fsayh7IG5vZGU6IGFyZywgc2NvcGUgfSkpLCBhbGxOdWxsID0gYXJnTm9kZS50eXBlID09PSBcIm51bGxcIiB8fCBhcmdOb2RlLnR5cGUgPT09IFwidW5pb25cIiAmJiBhcmdOb2RlLm9mLmV2ZXJ5KCh0KSA9PiB0LnR5cGUgPT09IFwibnVsbFwiKTtcbiAgICAgICAgaWYgKGNhbkJlTnVsbCA9IGFsbE51bGwgfHwgYXJnTm9kZS50eXBlID09PSBcInVua25vd25cIiB8fCBhcmdOb2RlLnR5cGUgPT09IFwidW5pb25cIiAmJiBhcmdOb2RlLm9mLnNvbWUoKHQpID0+IHQudHlwZSA9PT0gXCJudWxsXCIgfHwgdC50eXBlID09PSBcInVua25vd25cIiksIGFsbE51bGwgfHwgdHlwZU5vZGVzLnB1c2godW5pb25XaXRob3V0TnVsbChhcmdOb2RlKSksICFjYW5CZU51bGwpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuQmVOdWxsICYmIHR5cGVOb2Rlcy5wdXNoKHsgdHlwZTogXCJudWxsXCIgfSksIHtcbiAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICBvZjogdHlwZU5vZGVzXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLmNvdW50XCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJnMi50eXBlID09PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVtYmVyXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwuZGF0ZVRpbWVcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgPT09IFwic3RyaW5nXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5sZW5ndGhcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBhcmcyLnR5cGUgPT09IFwiYXJyYXlcIiB8fCBhcmcyLnR5cGUgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVtYmVyXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwucmVmZXJlbmNlc1wiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJib29sZWFuXCIgfTtcbiAgICBjYXNlIFwiZ2xvYmFsLnJvdW5kXCI6IHtcbiAgICAgIGNvbnN0IG51bU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKG51bU5vZGUsIHNjb3BlLCAobnVtKSA9PiB7XG4gICAgICAgIGlmIChudW0udHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgcmV0dXJuIG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSk7XG4gICAgICAgIGlmIChudW0udHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICBpZiAobm9kZS5hcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGNvbnN0IHByZWNpc2lvbk5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzFdLCBzY29wZSB9KTtcbiAgICAgICAgICByZXR1cm4gbWFwTm9kZShwcmVjaXNpb25Ob2RlLCBzY29wZSwgKHByZWNpc2lvbikgPT4gcHJlY2lzaW9uLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IHByZWNpc2lvbi50eXBlICE9PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogeyB0eXBlOiBcIm51bWJlclwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVtYmVyXCIgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLnN0cmluZ1wiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChub2RlMikgPT4gbm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogbm9kZTIudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBub2RlMi50eXBlID09PSBcIm51bWJlclwiIHx8IG5vZGUyLnR5cGUgPT09IFwiYm9vbGVhblwiID8gbm9kZTIudmFsdWUgPyB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBub2RlMi52YWx1ZS50b1N0cmluZygpXG4gICAgICB9IDoge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcIm1hdGguc3VtXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodmFsdWVzLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKG5vZGUyLm9mLCBzY29wZSwgKG5vZGUzKSA9PiBub2RlMy50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMy50eXBlID09PSBcIm51bWJlclwiIHx8IG5vZGUzLnR5cGUgPT09IFwibnVsbFwiID8geyB0eXBlOiBcIm51bWJlclwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcIm1hdGguYXZnXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodmFsdWVzLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKG5vZGUyLm9mLCBzY29wZSwgKG5vZGUzKSA9PiBub2RlMy50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMy50eXBlID09PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bWJlclwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcIm1hdGgubWF4XCI6XG4gICAgY2FzZSBcIm1hdGgubWluXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodmFsdWVzLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKG5vZGUyLm9mLCBzY29wZSwgKG5vZGUzKSA9PiBub2RlMy50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMy50eXBlID09PSBcIm51bWJlclwiID8gbm9kZTMgOiB7IHR5cGU6IFwibnVsbFwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcInB0LnRleHRcIjpcbiAgICAgIHJldHVybiBub2RlLmFyZ3MubGVuZ3RoID09PSAwID8geyB0eXBlOiBcIm51bGxcIiB9IDoge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9O1xuICAgIGNhc2UgXCJzdHJpbmcuc3RhcnRzV2l0aFwiOiB7XG4gICAgICBjb25zdCBzdHJUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pLCBwcmVmaXhUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoc3RyVHlwZU5vZGUsIHNjb3BlLCAoc3RyTm9kZSkgPT4gbWFwTm9kZShwcmVmaXhUeXBlTm9kZSwgc2NvcGUsIChwcmVmaXhOb2RlKSA9PiBzdHJOb2RlLnR5cGUgPT09IFwidW5rbm93blwiIHx8IHByZWZpeE5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IHN0ck5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIiB8fCBwcmVmaXhOb2RlLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcInN0cmluZy5zcGxpdFwiOiB7XG4gICAgICBjb25zdCBzdHJUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pLCBzZXBUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoc3RyVHlwZU5vZGUsIHNjb3BlLCAoc3RyTm9kZSkgPT4gbWFwTm9kZShzZXBUeXBlTm9kZSwgc2NvcGUsIChzZXBOb2RlKSA9PiBzdHJOb2RlLnR5cGUgPT09IFwidW5rbm93blwiIHx8IHNlcE5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImFycmF5XCIsIG9mOiB7IHR5cGU6IFwic3RyaW5nXCIgfSB9KSA6IHN0ck5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIiB8fCBzZXBOb2RlLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0pKTtcbiAgICB9XG4gICAgY2FzZSBcImdlby5sYXRMbmdcIjoge1xuICAgICAgY29uc3QgbGF0VHlwZU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KSwgbG5nVHlwZU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzFdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGxhdFR5cGVOb2RlLCBzY29wZSwgKGxhdE5vZGUpID0+IG1hcE5vZGUobG5nVHlwZU5vZGUsIHNjb3BlLCAobG5nTm9kZSkgPT4gbGF0Tm9kZS50eXBlID09IFwidW5rbm93blwiIHx8IGxuZ05vZGUudHlwZSA9PSBcInVua25vd25cIiA/IG51bGxVbmlvbihjcmVhdGVHZW9Kc29uKCkpIDogbGF0Tm9kZS50eXBlICE9PSBcIm51bWJlclwiIHx8IGxuZ05vZGUudHlwZSAhPT0gXCJudW1iZXJcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG51bGxVbmlvbihjcmVhdGVHZW9Kc29uKCkpKSk7XG4gICAgfVxuICAgIGNhc2UgXCJnZW8uY29udGFpbnNcIjpcbiAgICAgIHJldHVybiBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KTtcbiAgICBjYXNlIFwiZ2VvLmludGVyc2VjdHNcIjpcbiAgICAgIHJldHVybiBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KTtcbiAgICBjYXNlIFwiZ2VvLmRpc3RhbmNlXCI6XG4gICAgICByZXR1cm4gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KTtcbiAgICBjYXNlIFwic2FuaXR5LnZlcnNpb25PZlwiOiB7XG4gICAgICBjb25zdCB0eXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodHlwZU5vZGUsIHNjb3BlLCAodHlwZU5vZGUyKSA9PiB0eXBlTm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IHR5cGVOb2RlMi50eXBlICE9PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bGxcIiB9IDogeyB0eXBlOiBcImJvb2xlYW5cIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcInNhbml0eS5wYXJ0T2ZSZWxlYXNlXCI6IHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh0eXBlTm9kZSwgc2NvcGUsICh0eXBlTm9kZTIpID0+IHR5cGVOb2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogdHlwZU5vZGUyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZG9jdW1lbnRzLmdldFwiOiB7XG4gICAgICBjb25zdCB0eXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodHlwZU5vZGUsIHNjb3BlLCAodHlwZU5vZGUyKSA9PiB0eXBlTm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyB0eXBlTm9kZTIgOiB0eXBlTm9kZTIudHlwZSAhPT0gXCJvYmplY3RcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJ1bmtub3duXCIgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICB9XG59XG5mdW5jdGlvbiBtYXRjaChsZWZ0LCByaWdodCkge1xuICBsZXQgdG9rZW5zID0gW10sIHBhdHRlcm5zID0gW107XG4gIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobGVmdC52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShsZWZ0LnZhbHVlKSk7XG4gIH1cbiAgaWYgKGxlZnQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKGxlZnQub2YudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGxlZnQub2YudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGxlZnQub2YudmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKGxlZnQub2YudmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKGxlZnQub2YudHlwZSA9PT0gXCJ1bmlvblwiKVxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIGxlZnQub2Yub2YpXG4gICAgICAgIG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBub2RlLnZhbHVlICE9PSB2b2lkIDAgJiYgKHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShub2RlLnZhbHVlKSkpO1xuICB9XG4gIGlmIChyaWdodC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHJpZ2h0LnZhbHVlID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihyaWdodC52YWx1ZSkpO1xuICB9XG4gIGlmIChyaWdodC50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAocmlnaHQub2YudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJpZ2h0Lm9mLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChyaWdodC5vZi52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBwYXR0ZXJucyA9IHBhdHRlcm5zLmNvbmNhdChtYXRjaEFuYWx5emVQYXR0ZXJuKHJpZ2h0Lm9mLnZhbHVlKSk7XG4gICAgfVxuICAgIGlmIChyaWdodC5vZi50eXBlID09PSBcInVuaW9uXCIpXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgcmlnaHQub2Yub2YpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChub2RlLnZhbHVlID09PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihub2RlLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKTtcbn1cbmNvbnN0ICR0cmFjZSQxID0gZGVidWcoXCJ0eXBlRXZhbHVhdG9yOnNjb3BlOnRyYWNlXCIpO1xuJHRyYWNlJDEubG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbmNsYXNzIENvbnRleHQge1xuICBzY2hlbWE7XG4gIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICB9XG4gIGxvb2t1cFJlZihyZWZUbykge1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuc2NoZW1hKVxuICAgICAgaWYgKHZhbC50eXBlID09PSBcImRvY3VtZW50XCIgJiYgdmFsLm5hbWUgPT09IHJlZlRvKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgYXR0cmlidXRlczogdmFsLmF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICB9XG4gIGxvb2t1cFR5cGVEZWNsYXJhdGlvbihhbGlhcykge1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuc2NoZW1hKVxuICAgICAgaWYgKHZhbC50eXBlID09PSBcInR5cGVcIiAmJiB2YWwubmFtZSA9PT0gYWxpYXMubmFtZSlcbiAgICAgICAgcmV0dXJuIHZhbC52YWx1ZTtcbiAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICB9XG59XG5jbGFzcyBTY29wZTIge1xuICB2YWx1ZTtcbiAgcGFyZW50O1xuICBjb250ZXh0O1xuICBpc0hpZGRlbjtcbiAgY29uc3RydWN0b3IodmFsdWUsIHBhcmVudCwgY29udGV4dCkge1xuICAgIHRoaXMudmFsdWUgPSB7IHR5cGU6IFwidW5pb25cIiwgb2Y6IHZhbHVlIH0sIHRoaXMucGFyZW50ID0gcGFyZW50LCB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHBhcmVudD8uY29udGV4dCB8fCBuZXcgQ29udGV4dChbXSksIHRoaXMuaXNIaWRkZW4gPSAhMTtcbiAgfVxuICBjcmVhdGVOZXN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0hpZGRlbiA/IG5ldyBTY29wZTIodmFsdWUsIHRoaXMucGFyZW50LCB0aGlzLmNvbnRleHQpIDogbmV3IFNjb3BlMih2YWx1ZSwgdGhpcywgdGhpcy5jb250ZXh0KTtcbiAgfVxuICBjcmVhdGVIaWRkZW4odmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5pc0hpZGRlbiA9ICEwLCByZXN1bHQ7XG4gIH1cbn1cbmNvbnN0ICR0cmFjZSA9IGRlYnVnKFwidHlwZUV2YWx1YXRvcjpldmFsdWF0ZTp0cmFjZVwiKTtcbiR0cmFjZS5sb2cgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuY29uc3QgJGRlYnVnID0gZGVidWcoXCJ0eXBlRXZhbHVhdG9yOmV2YWx1YXRlOmRlYnVnXCIpO1xuJGRlYnVnLmxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5jb25zdCAkd2FybiA9IGRlYnVnKFwidHlwZUV2YWx1YXRvcjpldmFsdWF0ZTp3YXJuXCIpO1xuZnVuY3Rpb24gdHlwZUV2YWx1YXRlKGFzdCwgc2NoZW1hKSB7XG4gICRkZWJ1ZyhcImV2YWx1YXRlUXVlcnlUeXBlLmFzdCAlT1wiLCBhc3QpLCAkZGVidWcoXCJldmFsdWF0ZVF1ZXJ5VHlwZS5zY2hlbWEgJU9cIiwgc2NoZW1hKTtcbiAgY29uc3QgcGFyc2VkID0gd2Fsayh7XG4gICAgbm9kZTogYXN0LFxuICAgIHNjb3BlOiBuZXcgU2NvcGUyKFtdLCB2b2lkIDAsIG5ldyBDb250ZXh0KHNjaGVtYSkpXG4gIH0pO1xuICAkdHJhY2UoXCJldmFsdWF0ZVF1ZXJ5VHlwZS5wYXJzZWQgJU9cIiwgcGFyc2VkKTtcbiAgY29uc3Qgb3B0aW1pemVkID0gb3B0aW1pemVVbmlvbnMocGFyc2VkKTtcbiAgcmV0dXJuICRkZWJ1ZyhcImV2YWx1YXRlUXVlcnlUeXBlLm9wdGltaXplZCAlT1wiLCBvcHRpbWl6ZWQpLCBvcHRpbWl6ZWQ7XG59XG5mdW5jdGlvbiBtYXBEZXJlZihub2RlLCBzY29wZSkge1xuICByZXR1cm4gbWFwTm9kZShub2RlLCBzY29wZSwgKGJhc2UpID0+IHtcbiAgICBpZiAoYmFzZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIG9mOiBtYXBEZXJlZihiYXNlLm9mLCBzY29wZSlcbiAgICAgIH07XG4gICAgaWYgKGJhc2UudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKGJhc2UuZGVyZWZlcmVuY2VzVG8gIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIHNjb3BlLmNvbnRleHQubG9va3VwUmVmKGJhc2UuZGVyZWZlcmVuY2VzVG8pO1xuICAgICAgaWYgKGJhc2UucmVzdCAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gbWFwRGVyZWYocmVzb2x2ZUlubGluZShiYXNlLnJlc3QsIHNjb3BlKSwgc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZURlcmVmTm9kZShub2RlLCBzY29wZSkge1xuICAkdHJhY2UoXCJkZXJlZi5ub2RlICVPXCIsIG5vZGUpO1xuICBjb25zdCBkZXJlZmVkTm9kZSA9IG1hcERlcmVmKHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pLCBzY29wZSk7XG4gIHJldHVybiAkdHJhY2UoXCJkZXJlZi5kZXJlZmVkTm9kZSAlT1wiLCBkZXJlZmVkTm9kZSksIGRlcmVmZWROb2RlO1xufVxuZnVuY3Rpb24gaGFuZGxlT2JqZWN0U3BsYXROb2RlKGF0dHIsIHNjb3BlKSB7XG4gIGNvbnN0IHZhbHVlID0gd2Fsayh7IG5vZGU6IGF0dHIudmFsdWUsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwib2JqZWN0LnNwbGF0LnZhbHVlICVPXCIsIHZhbHVlKSwgbWFwTm9kZSh2YWx1ZSwgc2NvcGUsIChub2RlKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4geyB0eXBlOiBcIm9iamVjdFwiLCBhdHRyaWJ1dGVzOiB7fSB9O1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbm9kZS5hdHRyaWJ1dGVzKVxuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIChhdHRyaWJ1dGVzW25hbWVdID0gbm9kZS5hdHRyaWJ1dGVzW25hbWVdKTtcbiAgICBpZiAobm9kZS5yZXN0ICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkUmVzdCA9IHJlc29sdmVJbmxpbmUobm9kZS5yZXN0LCBzY29wZSk7XG4gICAgICBpZiAocmVzb2x2ZWRSZXN0LnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgaWYgKHJlc29sdmVkUmVzdC50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHJlc29sdmVkUmVzdC5hdHRyaWJ1dGVzKVxuICAgICAgICByZXNvbHZlZFJlc3QuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAoYXR0cmlidXRlc1tuYW1lXSA9IHJlc29sdmVkUmVzdC5hdHRyaWJ1dGVzW25hbWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJvYmplY3RcIiwgYXR0cmlidXRlcyB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9iamVjdE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgaWYgKCR0cmFjZShcIm9iamVjdC5ub2RlICVPXCIsIG5vZGUpLCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlczoge31cbiAgICB9O1xuICBjb25zdCBvYmplY3RBdHRyaWJ1dGVzID0gW10sIHNwbGF0VmFyaWFudHMgPSBbXSwgY29uZGl0aW9uYWxWYXJpYW50cyA9IFtdO1xuICBmb3IgKGNvbnN0IFtpZHgsIGF0dHJdIG9mIG5vZGUuYXR0cmlidXRlcy5lbnRyaWVzKCkpIHtcbiAgICBpZiAoYXR0ci50eXBlID09PSBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5vZGUgPSB3YWxrKHsgbm9kZTogYXR0ci52YWx1ZSwgc2NvcGUgfSk7XG4gICAgICBvYmplY3RBdHRyaWJ1dGVzLnB1c2goW1xuICAgICAgICBpZHgsXG4gICAgICAgIGF0dHIubmFtZSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICAgICAgdmFsdWU6IGF0dHJpYnV0ZU5vZGVcbiAgICAgICAgfVxuICAgICAgXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGF0dHIudHlwZSA9PT0gXCJPYmplY3RTcGxhdFwiKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOb2RlID0gaGFuZGxlT2JqZWN0U3BsYXROb2RlKGF0dHIsIHNjb3BlKTtcbiAgICAgIHN3aXRjaCAoJHRyYWNlKFwib2JqZWN0LnNwbGF0LnJlc3VsdCAlT1wiLCBhdHRyaWJ1dGVOb2RlKSwgYXR0cmlidXRlTm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgIHNwbGF0VmFyaWFudHMucHVzaChbaWR4LCBhdHRyaWJ1dGVOb2RlXSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaW9uXCI6IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIGF0dHJpYnV0ZU5vZGUub2YpXG4gICAgICAgICAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgICBzcGxhdFZhcmlhbnRzLnB1c2goW2lkeCwgYXR0cmlidXRlTm9kZV0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHIudHlwZSA9PT0gXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCIpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGJvb2xlYW5WYWx1ZSh3YWxrKHsgbm9kZTogYXR0ci5jb25kaXRpb24sIHNjb3BlIH0pLCBzY29wZSk7XG4gICAgICBpZiAoJHRyYWNlKFwib2JqZWN0LmNvbmRpdGlvbmFsLnNwbGF0LmNvbmRpdGlvbiAlT1wiLCBjb25kaXRpb24pLCBjb25kaXRpb24uY2FuQmVUcnVlID09PSAhMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOb2RlID0gaGFuZGxlT2JqZWN0U3BsYXROb2RlKGF0dHIsIHNjb3BlKTtcbiAgICAgIGlmICgkdHJhY2UoXCJvYmplY3QuY29uZGl0aW9uYWwuc3BsYXQucmVzdWx0ICVPXCIsIGF0dHJpYnV0ZU5vZGUpLCBjb25kaXRpb24uY2FuQmVGYWxzZSA9PT0gITEgJiYgY29uZGl0aW9uLmNhbkJlTnVsbCA9PT0gITEpXG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlTm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICBzcGxhdFZhcmlhbnRzLnB1c2goW2lkeCwgYXR0cmlidXRlTm9kZV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ1bmlvblwiOiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIGF0dHJpYnV0ZU5vZGUub2YpXG4gICAgICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgICAgICAgICBzcGxhdFZhcmlhbnRzLnB1c2goW2lkeCwgYXR0cmlidXRlTm9kZV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgICB9XG4gICAgICBjb25zdCB2YXJpYW50ID0gbWFwTm9kZShhdHRyaWJ1dGVOb2RlLCBzY29wZSwgKGF0dHJpYnV0ZU5vZGUyKSA9PiAoJHRyYWNlKFwib2JqZWN0LmNvbmRpdGlvbmFsLnNwbGF0LnJlc3VsdC5jb25jcmV0ZSAlT1wiLCBhdHRyaWJ1dGVOb2RlMiksIGF0dHJpYnV0ZU5vZGUyLnR5cGUgIT09IFwib2JqZWN0XCIgPyB7IHR5cGU6IFwidW5rbm93blwiIH0gOiB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZU5vZGUyLmF0dHJpYnV0ZXNcbiAgICAgIH0pKTtcbiAgICAgIGlmICh2YXJpYW50LnR5cGUgPT09IFwidW5pb25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIHZhcmlhbnQub2YpXG4gICAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgICB2YXJpYW50Lm9mLnB1c2goeyB0eXBlOiBcIm9iamVjdFwiLCBhdHRyaWJ1dGVzOiB7fSB9KSwgY29uZGl0aW9uYWxWYXJpYW50cy5wdXNoKFtpZHgsIHZhcmlhbnRdKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodmFyaWFudC50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgY29uZGl0aW9uYWxWYXJpYW50cy5wdXNoKFtcbiAgICAgICAgaWR4LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICAgIG9mOiBbeyB0eXBlOiBcIm9iamVjdFwiLCBhdHRyaWJ1dGVzOiB7fSB9LCB2YXJpYW50XVxuICAgICAgICB9XG4gICAgICBdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb2JqZWN0IGF0dHJpYnV0ZSB0eXBlOiAke2F0dHIudHlwZX1gKTtcbiAgfVxuICBjb25zdCBndWFyYW50ZWVkQXR0cmlidXRlcyA9IFtdO1xuICBndWFyYW50ZWVkQXR0cmlidXRlcy5wdXNoKC4uLm9iamVjdEF0dHJpYnV0ZXMpO1xuICBmb3IgKGNvbnN0IFtpZHgsIHNwbGF0Tm9kZV0gb2Ygc3BsYXRWYXJpYW50cykge1xuICAgIGlmIChzcGxhdE5vZGUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHNwbGF0Tm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghc3BsYXROb2RlLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHNwbGF0Tm9kZS5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBndWFyYW50ZWVkQXR0cmlidXRlcy5wdXNoKFtpZHgsIG5hbWUsIGF0dHJpYnV0ZV0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbmRpdGlvbmFsVmFyaWFudHMucHVzaChbaWR4LCBzcGxhdE5vZGVdKTtcbiAgfVxuICBpZiAoZ3VhcmFudGVlZEF0dHJpYnV0ZXMuc29ydCgoW2FdLCBbYl0pID0+IGEgLSBiKSwgY29uZGl0aW9uYWxWYXJpYW50cy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIGd1YXJhbnRlZWRBdHRyaWJ1dGVzLm1hcCgoWywgbmFtZSwgYXR0cmlidXRlXSkgPT4gW25hbWUsIGF0dHJpYnV0ZV0pXG4gICAgICApXG4gICAgfTtcbiAgY29uc3QgbWF0cml4ID0gW107XG4gIGZvciAoY29uc3QgW3VuaW9uSWR4LCB1bmlvbl0gb2YgY29uZGl0aW9uYWxWYXJpYW50cykge1xuICAgIGNvbnN0IHVuaW9uR3VhcmFudGVlZEJlZm9yZSA9IFtdLCB1bmlvbkd1YXJhbnRlZWRBZnRlciA9IFtdO1xuICAgIGZvciAoY29uc3QgW2d1YXJhbnRlZWRJbmRleCwgbmFtZSwgYXR0cmlidXRlXSBvZiBndWFyYW50ZWVkQXR0cmlidXRlcylcbiAgICAgIGd1YXJhbnRlZWRJbmRleCA8IHVuaW9uSWR4ICYmIHVuaW9uR3VhcmFudGVlZEJlZm9yZS5wdXNoKFtndWFyYW50ZWVkSW5kZXgsIG5hbWUsIGF0dHJpYnV0ZV0pLCBndWFyYW50ZWVkSW5kZXggPiB1bmlvbklkeCAmJiB1bmlvbkd1YXJhbnRlZWRBZnRlci5wdXNoKFtndWFyYW50ZWVkSW5kZXgsIG5hbWUsIGF0dHJpYnV0ZV0pO1xuICAgIGNvbnN0IGFsbFZhcmlhbnRzQXR0cmlidXRlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2NvbmRpdGlvbmFsVmFyaWFudElkeCwgb3RoZXJVbmlvbl0gb2YgY29uZGl0aW9uYWxWYXJpYW50cykge1xuICAgICAgY29uc3QgdmFyaWFudEF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgbm9kZTIgb2Ygb3RoZXJVbmlvbi5vZilcbiAgICAgICAgdmFyaWFudEF0dHJpYnV0ZXMucHVzaChub2RlMi5hdHRyaWJ1dGVzKTtcbiAgICAgIGFsbFZhcmlhbnRzQXR0cmlidXRlcy5wdXNoKFtjb25kaXRpb25hbFZhcmlhbnRJZHgsIHZhcmlhbnRBdHRyaWJ1dGVzXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgbm9kZTIgb2YgdW5pb24ub2YpIHtcbiAgICAgIG1hdHJpeC5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIHVuaW9uR3VhcmFudGVlZEJlZm9yZS5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgICAgICksXG4gICAgICAgICAgLi4ubm9kZTIuYXR0cmlidXRlcyxcbiAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICB1bmlvbkd1YXJhbnRlZWRBZnRlci5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IFtvdXRlcklkeCwgb3V0ZXJBdHRyaWJ1dGVzXSBvZiBhbGxWYXJpYW50c0F0dHJpYnV0ZXMpXG4gICAgICAgIGZvciAoY29uc3Qgb3V0ZXIgb2Ygb3V0ZXJBdHRyaWJ1dGVzKVxuICAgICAgICAgIGZvciAoY29uc3QgW2lubmVySWR4LCBpbm5lckF0dHJpYnV0ZXNdIG9mIGFsbFZhcmlhbnRzQXR0cmlidXRlcylcbiAgICAgICAgICAgIGlmIChvdXRlcklkeCAhPT0gaW5uZXJJZHgpXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaW5uZXIgb2YgaW5uZXJBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2JlZm9yZSA9IFsuLi51bmlvbkd1YXJhbnRlZWRCZWZvcmVdLCBfYWZ0ZXIgPSBbLi4udW5pb25HdWFyYW50ZWVkQWZ0ZXJdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvdXRlcilcbiAgICAgICAgICAgICAgICAgIG91dGVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIG91dGVySWR4ICE9PSB1bmlvbklkeCAmJiAob3V0ZXJJZHggPCB1bmlvbklkeCAmJiBfYmVmb3JlLnB1c2goW291dGVySWR4LCBuYW1lLCBvdXRlcltuYW1lXV0pLCBvdXRlcklkeCA+IHVuaW9uSWR4ICYmIF9hZnRlci5wdXNoKFtvdXRlcklkeCwgbmFtZSwgb3V0ZXJbbmFtZV1dKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGlubmVyKVxuICAgICAgICAgICAgICAgICAgaW5uZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgb3V0ZXJJZHggIT09IHVuaW9uSWR4ICYmIChpbm5lcklkeCA8IHVuaW9uSWR4ICYmIF9iZWZvcmUucHVzaChbaW5uZXJJZHgsIG5hbWUsIGlubmVyW25hbWVdXSksIGlubmVySWR4ID4gdW5pb25JZHggJiYgX2FmdGVyLnB1c2goW2lubmVySWR4LCBuYW1lLCBpbm5lcltuYW1lXV0pKTtcbiAgICAgICAgICAgICAgICBfYmVmb3JlLnNvcnQoKFthXSwgW2JdKSA9PiBhIC0gYiksIF9hZnRlci5zb3J0KChbYV0sIFtiXSkgPT4gYSAtIGIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgIF9iZWZvcmUubWFwKChbLCBuYW1lLCBhdHRyaWJ1dGVdKSA9PiBbbmFtZSwgYXR0cmlidXRlXSlcbiAgICAgICAgICAgICAgICApLCBhZnRlciA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgIF9hZnRlci5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbWF0cml4LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYmVmb3JlLFxuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlMi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5hZnRlclxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpbWl6ZVVuaW9ucyh7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiBtYXRyaXhcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVPcENhbGxOb2RlKG5vZGUsIHNjb3BlKSB7XG4gICR0cmFjZShcIm9wY2FsbC5ub2RlICVPXCIsIG5vZGUpO1xuICBjb25zdCBsaHMgPSB3YWxrKHsgbm9kZTogbm9kZS5sZWZ0LCBzY29wZSB9KSwgcmhzID0gd2Fsayh7IG5vZGU6IG5vZGUucmlnaHQsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShcbiAgICBsaHMsXG4gICAgc2NvcGUsXG4gICAgKGxlZnQpID0+IChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50c1xuICAgICAgbWFwTm9kZShyaHMsIHNjb3BlLCAocmlnaHQpID0+IHtcbiAgICAgICAgc3dpdGNoICgkdHJhY2UoJ29wY2FsbC5ub2RlLmNvbmNyZXRlIFwiJXNcIiAlTycsIG5vZGUub3AsIHsgbGVmdCwgcmlnaHQgfSksIG5vZGUub3ApIHtcbiAgICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8geyB0eXBlOiBcImJvb2xlYW5cIiB9IDogbGVmdC50eXBlICE9PSByaWdodC50eXBlID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6ICExXG4gICAgICAgICAgICB9IDogbGVmdC50eXBlID09PSBcIm51bGxcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgfSA6ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKGxlZnQpIHx8ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKHJpZ2h0KSA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBldmFsdWF0ZUNvbXBhcmlzb24obm9kZS5vcCwgbGVmdCwgcmlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgXCIhPVwiOiB7XG4gICAgICAgICAgICBpZiAobGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIilcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJib29sZWFuXCIgfTtcbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgIT09IHJpZ2h0LnR5cGUpXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobGVmdC50eXBlID09PSBcIm51bGxcIilcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghaXNQcmltaXRpdmVUeXBlTm9kZShsZWZ0KSB8fCAhaXNQcmltaXRpdmVUeXBlTm9kZShyaWdodCkpXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBldmFsdWF0ZUNvbXBhcmlzb24oXCI9PVwiLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMCAmJiAodmFsdWUgPSAhdmFsdWUpLCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IGxlZnQudHlwZSAhPT0gcmlnaHQudHlwZSA/IHsgdHlwZTogXCJudWxsXCIgfSA6ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKGxlZnQpIHx8ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKHJpZ2h0KSA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBldmFsdWF0ZUNvbXBhcmlzb24obm9kZS5vcCwgbGVmdCwgcmlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgXCJpblwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IHJpZ2h0LnR5cGUgIT09IFwiYXJyYXlcIiA/IGlzRnVuY0NhbGwobm9kZS5yaWdodCwgXCJnbG9iYWw6OnBhdGhcIikgPyB7IHR5cGU6IFwiYm9vbGVhblwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0gOiAhaXNQcmltaXRpdmVUeXBlTm9kZShsZWZ0KSAmJiBsZWZ0LnR5cGUgIT09IFwibnVsbFwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6ICExXG4gICAgICAgICAgICB9IDogbWFwTm9kZShyaWdodC5vZiwgc2NvcGUsIChhcnJheVR5cGVOb2RlKSA9PiBhcnJheVR5cGVOb2RlLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVsbFwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGFycmF5VHlwZU5vZGUudHlwZSA9PT0gXCJudWxsXCJcbiAgICAgICAgICAgIH0gOiBsZWZ0LnZhbHVlID09PSB2b2lkIDAgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICB9IDogaXNQcmltaXRpdmVUeXBlTm9kZShhcnJheVR5cGVOb2RlKSA/IGFycmF5VHlwZU5vZGUudmFsdWUgPT09IHZvaWQgMCA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSA9PT0gYXJyYXlUeXBlTm9kZS52YWx1ZVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSBcIm1hdGNoXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IHsgdHlwZTogXCJib29sZWFuXCIgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBtYXRjaChsZWZ0LCByaWdodClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8geyB0eXBlOiBcInVua25vd25cIiB9IDogbGVmdC50eXBlID09PSBcInN0cmluZ1wiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgKyByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlICsgcmlnaHQudmFsdWUgOiB2b2lkIDBcbiAgICAgICAgICAgIH0gOiBsZWZ0LnR5cGUgPT09IFwiYXJyYXlcIiAmJiByaWdodC50eXBlID09PSBcImFycmF5XCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb2Y6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgICAgICAgICAgb2Y6IFtsZWZ0Lm9mLCByaWdodC5vZl1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSA6IGxlZnQudHlwZSA9PT0gXCJvYmplY3RcIiAmJiByaWdodC50eXBlID09PSBcIm9iamVjdFwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IC4uLmxlZnQuYXR0cmlidXRlcywgLi4ucmlnaHQuYXR0cmlidXRlcyB9XG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSAtIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSAqIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSAvIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGNhc2UgXCIqKlwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgKiogcmlnaHQudmFsdWUgOiB2b2lkIDBcbiAgICAgICAgICAgIH0gOiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlICUgcmlnaHQudmFsdWUgOiB2b2lkIDBcbiAgICAgICAgICAgIH0gOiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVNlbGVjdE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGxldCBndWFyYW50ZWVkID0gITE7XG4gIGZvciAoY29uc3QgYWx0ZXJuYXRpdmUgb2Ygbm9kZS5hbHRlcm5hdGl2ZXMpIHtcbiAgICBjb25zdCBjb25kaXRpb25WYWx1ZSA9IHdhbGsoeyBub2RlOiBhbHRlcm5hdGl2ZS5jb25kaXRpb24sIHNjb3BlIH0pLCBjb25kaXRpb25TY29wZSA9IHJlc29sdmVGaWx0ZXIoYWx0ZXJuYXRpdmUuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgY29uZGl0aW9uU2NvcGUudHlwZSA9PT0gXCJ1bmlvblwiICYmIGNvbmRpdGlvblNjb3BlLm9mLmxlbmd0aCA+IDAgJiYgdmFsdWVzLnB1c2god2Fsayh7IG5vZGU6IGFsdGVybmF0aXZlLnZhbHVlLCBzY29wZTogc2NvcGUuY3JlYXRlSGlkZGVuKGNvbmRpdGlvblNjb3BlLm9mKSB9KSksIGNvbmRpdGlvblZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGNvbmRpdGlvblZhbHVlLnZhbHVlID09PSAhMCAmJiAoZ3VhcmFudGVlZCA9ICEwKTtcbiAgfVxuICByZXR1cm4gbm9kZS5mYWxsYmFjayAmJiAhZ3VhcmFudGVlZCAmJiB2YWx1ZXMucHVzaCh3YWxrKHsgbm9kZTogbm9kZS5mYWxsYmFjaywgc2NvcGUgfSkpLCB2YWx1ZXMubGVuZ3RoID09PSAwID8geyB0eXBlOiBcIm51bGxcIiB9IDoge1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBvZjogdmFsdWVzXG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVBcnJheUNvZXJjZU5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwiYXJyYXlDb2VyY2UuYmFzZSAlT1wiLCBiYXNlKSwgbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gYmFzZTIpO1xufVxuZnVuY3Rpb24gaGFuZGxlRmxhdE1hcChub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBBcnJheShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSB3YWxrKHsgbm9kZTogbm9kZS5leHByLCBzY29wZTogc2NvcGUuY3JlYXRlSGlkZGVuKFtiYXNlMi5vZl0pIH0pO1xuICAgIHJldHVybiBtYXBOb2RlKFxuICAgICAgaW5uZXIsXG4gICAgICBzY29wZSxcbiAgICAgIChpbm5lcjIpID0+IGlubmVyMi50eXBlID09PSBcImFycmF5XCIgPyBpbm5lcjIgOiB7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IGlubmVyMiB9LFxuICAgICAgKG5vZGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGlubmVyMiA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIG5vZGVzKSB7XG4gICAgICAgICAgaWYgKG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiKSByZXR1cm4geyB0eXBlOiBcImFycmF5XCIsIG9mOiBub2RlMiB9O1xuICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImFycmF5XCIpIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0eXBlOiAke25vZGUyLnR5cGV9YCk7XG4gICAgICAgICAgaW5uZXIyLnB1c2gobm9kZTIub2YpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIG9mOiBvcHRpbWl6ZVVuaW9ucyh7IHR5cGU6IFwidW5pb25cIiwgb2Y6IGlubmVyMiB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlTWFwKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcIm1hcC5iYXNlICVPXCIsIGJhc2UpLCBtYXBBcnJheShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiAoe1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBvZjogd2Fsayh7IG5vZGU6IG5vZGUuZXhwciwgc2NvcGU6IHNjb3BlLmNyZWF0ZUhpZGRlbihbYmFzZTIub2ZdKSB9KVxuICB9KSk7XG59XG5mdW5jdGlvbiBoYW5kbGVQcm9qZWN0aW9uTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiAkdHJhY2UoXCJwcm9qZWN0aW9uLmJhc2UgJU9cIiwgYmFzZSksIG1hcE9iamVjdChcbiAgICBiYXNlLFxuICAgIHNjb3BlLFxuICAgIChiYXNlMikgPT4gd2Fsayh7IG5vZGU6IG5vZGUuZXhwciwgc2NvcGU6IHNjb3BlLmNyZWF0ZU5lc3RlZChbYmFzZTJdKSB9KVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRmlsdGVyU2NvcGUoYmFzZSwgc2NvcGUpIHtcbiAgcmV0dXJuIGJhc2UudHlwZSA9PT0gXCJhcnJheVwiID8gYmFzZS5vZi50eXBlID09PSBcInVuaW9uXCIgPyBzY29wZS5jcmVhdGVOZXN0ZWQoYmFzZS5vZi5vZikgOiBzY29wZS5jcmVhdGVOZXN0ZWQoW2Jhc2Uub2ZdKSA6IHNjb3BlLmNyZWF0ZU5lc3RlZChbYmFzZV0pO1xufVxuZnVuY3Rpb24gaGFuZGxlRmlsdGVyTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiAkdHJhY2UoXCJmaWx0ZXIuYmFzZSAlT1wiLCBiYXNlKSwgbWFwTm9kZShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiB7XG4gICAgaWYgKCR0cmFjZShcImZpbHRlci5yZXNvbHZpbmcgJU9cIiwgYmFzZTIpLCBiYXNlMi50eXBlID09PSBcIm51bGxcIilcbiAgICAgIHJldHVybiBiYXNlMjtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVGaWx0ZXIobm9kZS5leHByLCBjcmVhdGVGaWx0ZXJTY29wZShiYXNlMiwgc2NvcGUpKTtcbiAgICByZXR1cm4gJHRyYWNlKFwiZmlsdGVyLnJlc29sdmVkICVPXCIsIHJlc29sdmVkKSwge1xuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgb2Y6IHJlc29sdmVkXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBY2Nlc3NBdHRyaWJ1dGVOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGxldCBhdHRyaWJ1dGVCYXNlID0gc2NvcGUudmFsdWU7XG4gIHJldHVybiBub2RlLmJhc2UgJiYgKGF0dHJpYnV0ZUJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KSksICR0cmFjZShcImFjY2Vzc0F0dHJpYnV0ZS5iYXNlICVzICVPXCIsIG5vZGUubmFtZSwgYXR0cmlidXRlQmFzZSksIGhhbmRsZUFjY2Vzc0F0dHJpYnV0ZUJhc2UoYXR0cmlidXRlQmFzZSwgbm9kZS5uYW1lLCBzY29wZSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBY2Nlc3NBdHRyaWJ1dGVCYXNlKGJhc2UsIG5hbWUsIHNjb3BlKSB7XG4gIHJldHVybiBtYXBPYmplY3QoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4ge1xuICAgICR0cmFjZSgnTG9va2luZyBmb3IgYXR0cmlidXRlIFwiJXNcIiBpbiBvYmplY3QgJU8nLCBuYW1lLCBiYXNlMik7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYmFzZTIuYXR0cmlidXRlc1tuYW1lXTtcbiAgICByZXR1cm4gYXR0cmlidXRlICE9PSB2b2lkIDAgPyAoJGRlYnVnKGBhY2Nlc3NBdHRyaWJ1dGUuYXR0cmlidXRlIGZvdW5kICR7bmFtZX0gJU9gLCBhdHRyaWJ1dGUpLCBhdHRyaWJ1dGUub3B0aW9uYWwgPyBudWxsVW5pb24oYXR0cmlidXRlLnZhbHVlKSA6IGF0dHJpYnV0ZS52YWx1ZSkgOiBiYXNlMi5yZXN0ID8gaGFuZGxlQWNjZXNzQXR0cmlidXRlQmFzZShiYXNlMi5yZXN0LCBuYW1lLCBzY29wZSkgOiAoJHdhcm4oYGF0dHJpYnV0ZSBcIiR7bmFtZX1cIiBub3QgZm91bmQgaW4gb2JqZWN0YCksIHsgdHlwZTogXCJudWxsXCIgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzRWxlbWVudE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwiYWNjZXNzRWxlbWVudC5iYXNlICVPXCIsIGJhc2UpLCBtYXBBcnJheShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBudWxsVW5pb24oYmFzZTIub2YpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFycmF5Tm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBvZiA9IFtdO1xuICBmb3IgKGNvbnN0IGVsIG9mIG5vZGUuZWxlbWVudHMpIHtcbiAgICBjb25zdCBub2RlMiA9IHdhbGsoeyBub2RlOiBlbC52YWx1ZSwgc2NvcGUgfSk7XG4gICAgbm9kZTIgIT09IG51bGwgJiYgb2YucHVzaChub2RlMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHtcbiAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgIG9mXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlVmFsdWVOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGlmIChub2RlLnZhbHVlID09PSBudWxsKVxuICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gIHN3aXRjaCAodHlwZW9mIG5vZGUudmFsdWUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxuICAgICAgfTtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxuICAgICAgfTtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgIHZhbHVlOiBub2RlLnZhbHVlXG4gICAgICB9O1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBub2RlLnZhbHVlID09PSBudWxsID8geyB0eXBlOiBcIm51bGxcIiB9IDogQXJyYXkuaXNBcnJheShub2RlLnZhbHVlKSA/IHtcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBvZjoge1xuICAgICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgICBvZjogbm9kZS52YWx1ZS5tYXAoKHZhbHVlKSA9PiB3YWxrKHsgbm9kZTogeyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlIH0sIHNjb3BlIH0pKVxuICAgICAgICB9XG4gICAgICB9IDoge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMobm9kZS52YWx1ZSkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHdhbGsoeyBub2RlOiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWUgfSwgc2NvcGUgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKVxuICAgICAgICApXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTbGljZShub2RlLCBzY29wZSkge1xuICAkdHJhY2UoXCJzbGljZS5ub2RlICVPXCIsIG5vZGUpO1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBBcnJheShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMik7XG59XG5mdW5jdGlvbiBoYW5kbGVQYXJlbnROb2RlKHsgbiB9LCBzY29wZSkge1xuICAkdHJhY2UoXCJoYW5kbGUucGFyZW50LmN1cnJlbnRTY29wZSAlZCAlT1wiLCBuLCBzY29wZSk7XG4gIGxldCBjdXJyZW50ID0gc2NvcGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgZm9yICg7IGN1cnJlbnQ/LmlzSGlkZGVuOyApXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgY3VycmVudCA9IGN1cnJlbnQ/LnBhcmVudDtcbiAgfVxuICByZXR1cm4gJHRyYWNlKFwiaGFuZGxlLnBhcmVudC5uZXdTY29wZSAlZCAlT1wiLCBuLCBjdXJyZW50KSwgY3VycmVudCA/IGN1cnJlbnQudmFsdWUub2YubGVuZ3RoID09PSAwID8geyB0eXBlOiBcIm51bGxcIiB9IDogY3VycmVudC52YWx1ZSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vdE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogYmFzZTIudHlwZSA9PT0gXCJib29sZWFuXCIgPyBiYXNlMi52YWx1ZSAhPT0gdm9pZCAwID8geyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6IGJhc2UyLnZhbHVlID09PSAhMSB9IDogeyB0eXBlOiBcImJvb2xlYW5cIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5lZ05vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBiYXNlMi50eXBlICE9PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogYmFzZTIudmFsdWUgIT09IHZvaWQgMCA/IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IC1iYXNlMi52YWx1ZSB9IDogYmFzZTIpO1xufVxuZnVuY3Rpb24gaGFuZGxlUG9zTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IGJhc2UyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGJhc2UyLnR5cGUgIT09IFwibnVtYmVyXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBiYXNlMik7XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVyeXRoaW5nTm9kZShfLCBzY29wZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBvZjoge1xuICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgb2Y6IHNjb3BlLmNvbnRleHQuc2NoZW1hLmZpbHRlcigob2JqKSA9PiBvYmoudHlwZSA9PT0gXCJkb2N1bWVudFwiKS5tYXAoKGRvYykgPT4gKHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczogZG9jLmF0dHJpYnV0ZXNcbiAgICAgIH0pKVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFuZE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgbGVmdCA9IHdhbGsoeyBub2RlOiBub2RlLmxlZnQsIHNjb3BlIH0pLCByaWdodCA9IHdhbGsoeyBub2RlOiBub2RlLnJpZ2h0LCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcE5vZGUoXG4gICAgbGVmdCxcbiAgICBzY29wZSxcbiAgICAobGhzKSA9PiBtYXBOb2RlKHJpZ2h0LCBzY29wZSwgKHJocykgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBib29sZWFuQW5kKGJvb2xlYW5WYWx1ZShsaHMsIHNjb3BlKSwgYm9vbGVhblZhbHVlKHJocywgc2NvcGUpKTtcbiAgICAgIHJldHVybiBib29sZWFuSW50ZXJwcmV0YXRpb25Ub1R5cGVOb2RlKHZhbHVlKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gaGFuZGxlT3JOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGxlZnQgPSB3YWxrKHsgbm9kZTogbm9kZS5sZWZ0LCBzY29wZSB9KSwgcmlnaHQgPSB3YWxrKHsgbm9kZTogbm9kZS5yaWdodCwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKFxuICAgIGxlZnQsXG4gICAgc2NvcGUsXG4gICAgKGxocykgPT4gbWFwTm9kZShyaWdodCwgc2NvcGUsIChyaHMpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYm9vbGVhbk9yKGJvb2xlYW5WYWx1ZShsaHMsIHNjb3BlKSwgYm9vbGVhblZhbHVlKHJocywgc2NvcGUpKTtcbiAgICAgIHJldHVybiBib29sZWFuSW50ZXJwcmV0YXRpb25Ub1R5cGVOb2RlKHZhbHVlKTtcbiAgICB9KVxuICApO1xufVxuY29uc3QgT1ZFUlJJREVfVFlQRV9TWU1CT0wgPSBTeW1ib2woXCJncm9xLWpzLnR5cGVcIik7XG5mdW5jdGlvbiB3YWxrKHsgbm9kZSwgc2NvcGUgfSkge1xuICBpZiAoT1ZFUlJJREVfVFlQRV9TWU1CT0wgaW4gbm9kZSlcbiAgICByZXR1cm4gbm9kZVtPVkVSUklERV9UWVBFX1NZTUJPTF07XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgLy8gRmlsdGVyaW5nLCB0cmF2ZXJzYWwgJiBwcm9qZWN0aW9uc1xuICAgIGNhc2UgXCJNYXBcIjpcbiAgICAgIHJldHVybiBoYW5kbGVNYXAobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJQcm9qZWN0aW9uXCI6XG4gICAgICByZXR1cm4gaGFuZGxlUHJvamVjdGlvbk5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJGaWx0ZXJcIjpcbiAgICAgIHJldHVybiBoYW5kbGVGaWx0ZXJOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiQWNjZXNzQXR0cmlidXRlXCI6XG4gICAgICByZXR1cm4gb3B0aW1pemVVbmlvbnMoaGFuZGxlQWNjZXNzQXR0cmlidXRlTm9kZShub2RlLCBzY29wZSkpO1xuICAgIGNhc2UgXCJBY2Nlc3NFbGVtZW50XCI6XG4gICAgICByZXR1cm4gaGFuZGxlQWNjZXNzRWxlbWVudE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJBcnJheUNvZXJjZVwiOlxuICAgICAgcmV0dXJuIGhhbmRsZUFycmF5Q29lcmNlTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkZsYXRNYXBcIjpcbiAgICAgIHJldHVybiBoYW5kbGVGbGF0TWFwKG5vZGUsIHNjb3BlKTtcbiAgICAvLyBPcGVyYXRpb25zXG4gICAgY2FzZSBcIk9wQ2FsbFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZU9wQ2FsbE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJBbmRcIjpcbiAgICAgIHJldHVybiBoYW5kbGVBbmROb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiT3JcIjpcbiAgICAgIHJldHVybiBoYW5kbGVPck5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJTZWxlY3RcIjpcbiAgICAgIHJldHVybiBoYW5kbGVTZWxlY3ROb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiUGlwZUZ1bmNDYWxsXCI6XG4gICAgICByZXR1cm4gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gICAgLy8gVmFsdWVzXG4gICAgY2FzZSBcIkRlcmVmXCI6XG4gICAgICByZXR1cm4gaGFuZGxlRGVyZWZOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICByZXR1cm4gaGFuZGxlT2JqZWN0Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlZhbHVlXCI6XG4gICAgICByZXR1cm4gaGFuZGxlVmFsdWVOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgIHJldHVybiBoYW5kbGVBcnJheU5vZGUobm9kZSwgc2NvcGUpO1xuICAgIC8vIFNwZWNpYWwgY2FzZXNcbiAgICBjYXNlIFwiRXZlcnl0aGluZ1wiOlxuICAgICAgcmV0dXJuIGhhbmRsZUV2ZXJ5dGhpbmdOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiVGhpc1wiOlxuICAgICAgcmV0dXJuICR0cmFjZShcInRoaXMgJU9cIiwgc2NvcGUudmFsdWUpLCBzY29wZS52YWx1ZTtcbiAgICBjYXNlIFwiUGFyZW50XCI6XG4gICAgICByZXR1cm4gaGFuZGxlUGFyZW50Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkZ1bmNDYWxsXCI6XG4gICAgICByZXR1cm4gaGFuZGxlRnVuY0NhbGxOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgIHJldHVybiB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgICBjYXNlIFwiTm90XCI6XG4gICAgICByZXR1cm4gaGFuZGxlTm90Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlBhcmFtZXRlclwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1bmtub3duXCJcbiAgICAgIH07XG4gICAgY2FzZSBcIlNsaWNlXCI6XG4gICAgICByZXR1cm4gaGFuZGxlU2xpY2Uobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJOZWdcIjpcbiAgICAgIHJldHVybiBoYW5kbGVOZWdOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiUG9zXCI6XG4gICAgICByZXR1cm4gaGFuZGxlUG9zTm9kZShub2RlLCBzY29wZSk7XG4gICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgY2FzZSBcIkFzY1wiOlxuICAgIGNhc2UgXCJEZXNjXCI6XG4gICAgY2FzZSBcIkNvbnRleHRcIjpcbiAgICBjYXNlIFwiVHVwbGVcIjpcbiAgICBjYXNlIFwiU2VsZWN0b3JGdW5jQ2FsbFwiOlxuICAgIGNhc2UgXCJTZWxlY3Rvck5lc3RlZFwiOlxuICAgIGNhc2UgXCJJblJhbmdlXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gbm9kZSB0eXBlICR7bm9kZS50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiBpc1ByaW1pdGl2ZVR5cGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBub2RlLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgbm9kZS50eXBlID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlQ29tcGFyaXNvbihvcGNhbGwsIGxlZnQsIHJpZ2h0KSB7XG4gIGlmICghKGxlZnQudmFsdWUgPT09IHZvaWQgMCB8fCByaWdodC52YWx1ZSA9PT0gdm9pZCAwKSlcbiAgICBzd2l0Y2ggKG9wY2FsbCkge1xuICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlID09PSByaWdodC52YWx1ZTtcbiAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlIDwgcmlnaHQudmFsdWU7XG4gICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQudmFsdWUgPD0gcmlnaHQudmFsdWU7XG4gICAgICBjYXNlIFwiPlwiOlxuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZSA+IHJpZ2h0LnZhbHVlO1xuICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlID49IHJpZ2h0LnZhbHVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGNvbXBhcmlzb24gb3BlcmF0b3IgJHtvcGNhbGx9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlcihleHByLCBzY29wZSkge1xuICAkdHJhY2UoXCJyZXNvbHZlRmlsdGVyLmV4cHIgJU9cIiwgZXhwcik7XG4gIGNvbnN0IGZpbHRlcmVkID0gc2NvcGUudmFsdWUub2YuZmlsdGVyKChub2RlKSA9PiB7XG4gICAgY29uc3Qgc3ViU2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oW25vZGVdKSwgY29uZCA9IHdhbGsoeyBub2RlOiBleHByLCBzY29wZTogc3ViU2NvcGUgfSk7XG4gICAgcmV0dXJuIGJvb2xlYW5WYWx1ZShjb25kLCBzdWJTY29wZSkuY2FuQmVUcnVlO1xuICB9KTtcbiAgcmV0dXJuICR0cmFjZShcbiAgICBgcmVzb2x2ZUZpbHRlciAke2V4cHIudHlwZSA9PT0gXCJPcENhbGxcIiA/IGAke2V4cHIudHlwZX0vJHtleHByLm9wfWAgOiBleHByLnR5cGV9ICVPYCxcbiAgICBmaWx0ZXJlZFxuICApLCB7IHR5cGU6IFwidW5pb25cIiwgb2Y6IGZpbHRlcmVkIH07XG59XG5mdW5jdGlvbiBtYXBBcnJheShub2RlLCBzY29wZSwgbWFwcGVyKSB7XG4gIHJldHVybiBtYXBOb2RlKG5vZGUsIHNjb3BlLCAoYmFzZSkgPT4gYmFzZS50eXBlID09PSBcInVua25vd25cIiA/IGJhc2UgOiBiYXNlLnR5cGUgPT09IFwiYXJyYXlcIiA/IG1hcHBlcihiYXNlKSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG59XG5mdW5jdGlvbiBtYXBPYmplY3Qobm9kZSwgc2NvcGUsIG1hcHBlcikge1xuICByZXR1cm4gbWFwTm9kZShub2RlLCBzY29wZSwgKGJhc2UpID0+IGJhc2UudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBiYXNlIDogYmFzZS50eXBlID09PSBcIm9iamVjdFwiID8gbWFwcGVyKGJhc2UpIDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbn1cbmV4cG9ydCB7XG4gIERhdGVUaW1lLFxuICBQYXRoLFxuICBjcmVhdGVSZWZlcmVuY2VUeXBlTm9kZSxcbiAgZXZhbHVhdGVRdWVyeSBhcyBldmFsdWF0ZSxcbiAgZXZhbHVhdGVRdWVyeVN5bmMgYXMgZXZhbHVhdGVTeW5jLFxuICBpc1NlbGVjdG9yTmVzdGVkLFxuICBpc1NlbGVjdG9yTm9kZSxcbiAgcGFyc2UsXG4gIHRvSlMsXG4gIHR5cGVFdmFsdWF0ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPTEubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.mjs\n");

/***/ })

};
;